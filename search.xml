<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>[心得] 六角學院 JS 工程師養成直播班 - 學習心得</title>
    <url>/2021/12/21/EXPhexschoolJSlive/</url>
    <content><![CDATA[<p><img data-src="/images/hexschool-livejs.png"></p>
<span id="more"></span> 

<p>過去參加過各種『ｏｏ電腦』的實體課程，也在各種平台買了很多線上課程，最近第一次參加了線上直播班課程，以下就來分享課程內容和學習心得。</p>
<h2 id="💎-課程內容"><a href="#💎-課程內容" class="headerlink" title="💎 課程內容"></a>💎 課程內容</h2><ul>
<li>課程名稱：JS 工程師養成直播班 - 2021秋季</li>
<li>授課時間：每週直播一次約 2 小時，共 9 週</li>
<li>授課內容：JavaScript 從零開始 -&gt; 串接 API 製作前、後台功能</li>
<li>其他服務：<ul>
<li>每日練習任務、每週主線任務，並有課程助教協助任務批改及建議</li>
<li>週二加開主線任務講解直播</li>
<li>週三、四不定期主題直播</li>
<li>社群平台提供線上諮詢、履歷檢查…等，想問什麼就問什麼</li>
</ul>
</li>
</ul>
<h2 id="💎-課程比較"><a href="#💎-課程比較" class="headerlink" title="💎 課程比較"></a>💎 課程比較</h2><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">實體課程</th>
<th align="center">線上課程</th>
<th align="center">直播班</th>
</tr>
</thead>
<tbody><tr>
<td align="center">價格</td>
<td align="center">高</td>
<td align="center">低</td>
<td align="center">中</td>
</tr>
<tr>
<td align="center">課程編排</td>
<td align="center">緊湊</td>
<td align="center">考驗自制力</td>
<td align="center">每週搭配練習循序漸進</td>
</tr>
<tr>
<td align="center">課後服務</td>
<td align="center">大概就完課證書？</td>
<td align="center">透過課程平台與開課導師互動</td>
<td align="center">有專屬社群和助教團可詢問</td>
</tr>
<tr>
<td align="center">學員交流</td>
<td align="center">很少</td>
<td align="center">趨近０</td>
<td align="center">校長、助教團 + 一堆同學互助</td>
</tr>
<tr>
<td align="center">學習效率</td>
<td align="center">需要天份，跟不上進度就GG</td>
<td align="center">考驗自制力與學習能力</td>
<td align="center">只要有網路就可以問到懂為止</td>
</tr>
</tbody></table>
<h2 id="💎-學習心得"><a href="#💎-學習心得" class="headerlink" title="💎 學習心得"></a>💎 學習心得</h2><h3 id="個人背景"><a href="#個人背景" class="headerlink" title="個人背景"></a>個人背景</h3><p>我是剛退伍的職業軍人，過去負責維護單位機房、伺服器和網站…等等，有開發 ASP.NET 內部網站也自學撰寫 HTML、CSS、JS 一段時間，會選擇上這門課是過去一直都使用較舊的技術開發網站（沒有API、框架…等），想透過這堂課強化基礎能力，並了解前端工程師在實務上的工作。</p>
<h3 id="課程心得"><a href="#課程心得" class="headerlink" title="課程心得"></a>課程心得</h3><p>六角學院的這堂直播課雖然課程規劃是從０開始，但是不得不佩服他們的專業，考量到上課的同學程度不同，安排了課後筆記、學員分組討論２個內容，雖然直播課的內容對我來說已經熟悉，但是這兩個內容讓我學到了不少。</p>
<ul>
<li><p>課後筆記：題目都是許多 JavaScript 需要釐清的基本觀念，撰寫筆記的過程需要閱讀大量相關文章，再歸納出自己的脈絡，嘗試寫成別人也能理解的文章，這個學習過程會比看一些 JS tricky 的影片更加有效。</p>
</li>
<li><p>學員分組討論：分組的同學中大家的程度不一樣，可以透過小組討論互相學習，也可以在檢視同學的問題時，充當偽助教試著去了解別人的程式碼並給予建議，如果有好的寫法也可以藉機學習新招式。</p>
</li>
</ul>
<p>過去上的一些實體課程，通常到上完後也不會和同學有任何互動，即使有熱心的同學開群組，也只是分享一些教材，完課後也成了廢群，更不用說線上課程就只是自己看看影片，哪來的同學？</p>
<p>六角學院有龐大的社群服務，雖然一開始真的有點摸不著頭緒（有舊的 udemy 課程、新的課程網站、Discord、Slack、Email信件、HackMD…），但是有把 Slack 當 FB、IG 在滑的校長、<del>被迫</del>輪班的助教群和大量的同學可以諮詢交流，這絕對是 CP 爆表的超值服務。</p>
<p>除此之外，每週主線任務的提交平台，可以看到其他同學的作品，不用再擔心卡住時找不到 Code 可以參考，相同的程式從每個人手中寫出來都是不同的樣貌，除了學習該怎麼寫出功能，還可以學習如何寫出讓人容易看懂的程式碼。</p>
<p>最後，要特別提的就是老師大力推廣的 Kata 挑戰，這是第一次遇到課程特別針對撰寫速度要求學生練習的，再結合社群分享，可以看到同學的各種騷操作，可以說速寫又是另一個世界了！</p>
<p>如果看這篇文章的你，正打算轉職前端工程師，或是學習前端技能中卻找不到方向，都非常推薦來參加直播班，這不僅僅是一套學習課程，而是給你一個完整的學習環境。</p>
<blockquote>
<p>課程網站：<br><a href="https://www.hexschool.com/">六角學院</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Course Experience</category>
      </categories>
      <tags>
        <tag>Experience</tag>
      </tags>
  </entry>
  <entry>
    <title>[JS] 參數傳遞方式 Call by what?</title>
    <url>/2021/11/17/JScallby/</url>
    <content><![CDATA[<p><img data-src="/images/js-callby.png"></p>
<span id="more"></span> 
<p>在探討參數傳遞的機制前，先了解一點基本的計算機觀念，電腦中的資料需要有個空間存放起來，才能被拿出來操作（運算），這存放的地方就是『記憶體』，平常會聽到電腦的記憶體有 4G、8G…等，資料不會一次佈滿整個記憶體空間，記憶體會切成許多小區塊（位置）來使用，一般在探討時會用類似 <code>0x01</code>、<code>0x02</code>… 這樣的方法來表示記憶體位置（並非實際記憶體使用位置）。</p>
<hr>
<h2 id="💎-資料型別"><a href="#💎-資料型別" class="headerlink" title="💎 資料型別"></a>💎 資料型別</h2><p>JavaScript 的資料型別分成<code>原始型別</code>和<code>物件型別</code>兩類，兩種型別的傳遞方式有所不同，下個段落繼續說明：</p>
<ul>
<li>原始型別（Primitives）：string, number, boolean, null, undefined, symbol</li>
<li>物件型別（Object）：object, array, function…等都屬於物件型別</li>
</ul>
<blockquote>
<p>詳細說明可以參考我的另一篇文章： <a href="https://stark920.github.io/2021/11/19/JScoercion">[JS] 深入了解型別與轉型</a></p>
</blockquote>
<hr>
<h2 id="💎-差異比較"><a href="#💎-差異比較" class="headerlink" title="💎 差異比較"></a>💎 差異比較</h2><h3 id="🔸-比較運算"><a href="#🔸-比較運算" class="headerlink" title="🔸 比較運算"></a>🔸 比較運算</h3><ul>
<li><p>先看一段簡單的程式碼，使用 <code>基本型別</code> 做相等的比較運算</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let a = 1;</span><br><span class="line">let b = 1;</span><br><span class="line">console.log(a === b); // true</span><br></pre></td></tr></table></figure>
<p>沒意外的結果是 true，記憶體的使用會像下圖：<br><img data-src="https://static.coderbridge.com/img/stark920/8f804e92af4d4299bb01a03c1c0db8fe.png"></p>
<center><small>在一個記憶體存放值，變數名稱 a 指向這個值的記憶體位置</small></center></li>
<li><p>接著改成 <code>物件型別</code> 進行比較</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let obj1 = &#123;a: 1&#125;;</span><br><span class="line">let obj2 = &#123;a: 1&#125;;</span><br><span class="line">console.log(a === b); // false</span><br></pre></td></tr></table></figure>
<p>結果卻變成 false 了，此時記憶體的使用情況變成下圖：<br><img data-src="https://static.coderbridge.com/img/stark920/cfd22c95b0984e4f8100cba3475126b5.png"></p>
<center><small>變數裡面存放了一個指向物件實體的記憶體位置，所以這兩個變數的內容實際是不同的記憶體位置，比較的結果是不相等</small></center></li>
</ul>
<hr>
<h3 id="🔸-拷貝變數"><a href="#🔸-拷貝變數" class="headerlink" title="🔸 拷貝變數"></a>🔸 拷貝變數</h3><ul>
<li><p><code>基本型別</code> 範例程式：將 c 的資料賦予到變數 d，再改變 c 的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let c = 1;</span><br><span class="line">let d = c;</span><br><span class="line">c = 2;</span><br><span class="line"></span><br><span class="line">console.log(c); // 2</span><br><span class="line">console.log(d); // 1</span><br></pre></td></tr></table></figure>
<p>c 的值修改之後， d 沒有同時變動，由此可知 c 的值被『複製』給 d 了，兩個變數指向不同的記憶體位置，這時候記憶體的變化如下圖：</p>
<p><img data-src="https://static.coderbridge.com/img/stark920/31c26d8272ee4121861f06dac62773c2.png"></p>
</li>
<li><p>使用 <code>物件型別</code> 來做相同的操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let obj1 = &#123;a: 1&#125;;</span><br><span class="line">let obj2 = obj1;</span><br><span class="line">obj1.a = 2;</span><br><span class="line"></span><br><span class="line">console.log(obj1); // &#123;a: 2&#125;</span><br><span class="line">console.log(obj2); // &#123;a: 2&#125;</span><br><span class="line">console.log(obj1 === obj2); // true</span><br></pre></td></tr></table></figure>
<p>修改第一個物件變數的內容，第二個物件變數也跟著變動了，表示兩個物件變數都指向同一個記憶體位置，用比較運算也得到相等的結果，如下圖：</p>
<p><img data-src="https://static.coderbridge.com/img/stark920/e290304dab504fc2918d0e2fac624498.png"></p>
</li>
</ul>
<hr>
<h2 id="💎-段落小結"><a href="#💎-段落小結" class="headerlink" title="💎 段落小結"></a>💎 段落小結</h2><ul>
<li><p><code>基本型別</code>是純粹的『值』，這個值是靜態的、不可變的（immutable），在傳遞時會以新的記憶體空間來存放新的（或複製來的）資料，這種參數傳遞模式通常被稱為<code>傳值（call by value）</code>。</p>
</li>
<li><p><code>物件型別</code>的資料是動態的、可變的（mutable），變數內會存放一個記憶體位置指向物件的本體，就像是這個物件的經紀人一樣；因此，做賦值運算時只會取得這個記憶體位置，而不是物件實體，這種複製方式又稱為淺拷貝，而參數傳遞模式通常被稱為<code>傳參考（call by reference）</code>。</p>
</li>
</ul>
<blockquote>
<p>延伸閱讀： <a href="https://medium.com/andy-blog/%E9%97%9C%E6%96%BCjs%E4%B8%AD%E7%9A%84%E6%B7%BA%E6%8B%B7%E8%B2%9D-shallow-copy-%E4%BB%A5%E5%8F%8A%E6%B7%B1%E6%8B%B7%E8%B2%9D-deep-copy-5f5bbe96c122">Andy - 關於JS中的淺拷貝(shallow copy)以及深拷貝(deep copy)</a></p>
</blockquote>
<hr>
<h2 id="💎-Call-by-sharing"><a href="#💎-Call-by-sharing" class="headerlink" title="💎 Call by sharing?"></a>💎 Call by sharing?</h2><ul>
<li><p>如果仔細看會發現上一個段落名稱是<code>段落小結</code>，沒錯，事情還沒結束！接著來看下面這段程式碼，並想想結果會印出什麼？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function share(obj) &#123;</span><br><span class="line">  obj.a = 2;</span><br><span class="line">  obj = &#123; b: 3 &#125;;</span><br><span class="line">  return obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let objA = &#123; a: 1 &#125;;</span><br><span class="line">let objB = share(objA);</span><br><span class="line"></span><br><span class="line">console.log(objA); // &#123; a: 2 &#125;</span><br><span class="line">console.log(objB); // &#123; b: 3 &#125;</span><br></pre></td></tr></table></figure>
<p>以物件傳參考的邏輯來看，objA 裡面存的記憶體位置會傳入函式，在 <code>obj.a = 2</code> 這段也確實透過傳入的位址成功修改 objA 物件內的值。</p>
<p>到了 <code>obj = &#123; b: 3 &#125;</code> 這段卻沒有改變原始的物件（objA)，而是以傳值的方式進行，新增了一個記憶體位置存放物件，再透過 return 回傳給 objB。</p>
<p><code>函式</code>會依傳入的參數型別有所不同（基本型別傳值、物件型別傳參考），但是對參數做<code>賦值運算時（=）</code>，就會<code>指向新的記憶體位置</code>，這種模式常被稱為 <code>call by sharing</code>。</p>
</li>
</ul>
<hr>
<h2 id="💎-總結"><a href="#💎-總結" class="headerlink" title="💎 總結"></a>💎 總結</h2><ul>
<li>JavaScript 並沒有正式文件去定義該怎麼稱呼這些資料傳遞方式，無論是 call by value、reference 或 sharing，亦或是要說 call by 還是 pass by 其實並沒有這麼重要，最重要的是了解 JavaScript 在處理資料時有什麼不同的機制，讓我們在撰寫時不要踩坑，才是實際又有幫助的。</li>
</ul>
<blockquote>
<p>參考資料： <a href="https://blog.techbridge.cc/2018/06/23/javascript-call-by-value-or-reference/">Huli - 深入探討 JavaScript 中的參數傳遞：call by value 還是 reference？</a></p>
</blockquote>
<hr>
<p>以上是我對這參數傳遞的一點認知，如有錯誤或是補充的知識點，也歡迎大家不吝指教，謝謝！</p>
]]></content>
      <categories>
        <category>JavaScript - Basic</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>[JS] 深入了解型別與轉型</title>
    <url>/2021/11/19/JScoercion/</url>
    <content><![CDATA[<p><img data-src="/images/js-coercion.png"></p>
<span id="more"></span> 
<p>JavaScript 不論遇到什麼奇形怪狀的資料運算，都會盡可能讓程式執行下去，這麼貼心的設計也是兩面刃，可能在不知不覺中程式正常運作，也可能突然就報錯了卻毫無頭緒，馬上來認識 JavaScript 的型別系統與轉型吧！</p>
<hr>
<h2 id="💎-型別（type）"><a href="#💎-型別（type）" class="headerlink" title="💎 型別（type）"></a>💎 型別（type）</h2><ul>
<li><p>JavaScript 的型別可以分為『原始型別』和『物件型別』兩類，差異在於：</p>
<ul>
<li>原始型別<code>沒有</code>屬性和方法可以使用</li>
<li>物件型別<code>可以任意存取</code>屬性和方法</li>
</ul>
</li>
<li><p><strong>原始型別（Primitive types）</strong></p>
<ul>
<li>string</li>
<li>number</li>
<li>boolean</li>
<li>null</li>
<li>undefined</li>
<li>symbol (ES 6 新定義)</li>
</ul>
</li>
<li><p><strong>物件型別（Object types）</strong></p>
<ul>
<li>原生物件（Native）<ul>
<li>Object, Array, Function, Date, Math, RegExp</li>
<li>原始型別包裹物件（Primitive Wrapper）：Number, String, Boolean</li>
</ul>
</li>
<li>寄宿物件（Host）<ul>
<li>window</li>
<li>DOM</li>
</ul>
</li>
</ul>
</li>
<li><p>型別檢查（typeof)：<br>除了 null 有原生的 bug 會得到 object 的結果（此 bug 不會修正），其他型別都可以使用 <code>typeof</code> 來檢查。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(typeof &#x27;a&#x27;); // string</span><br><span class="line">console.log(typeof 1); // number</span><br><span class="line">console.log(typeof true); // boolean</span><br><span class="line">console.log(typeof null); // object &lt;== 這是語言本身的bug</span><br><span class="line">console.log(typeof undefined); // undefined</span><br><span class="line">console.log(typeof Symbol()) // symbol</span><br><span class="line">console.log(typeof &#123;&#125;); // object</span><br><span class="line">console.log(typeof []); // object</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="💎-裝箱（boxing）和-拆箱（unboxing）"><a href="#💎-裝箱（boxing）和-拆箱（unboxing）" class="headerlink" title="💎 裝箱（boxing）和 拆箱（unboxing）"></a>💎 裝箱（boxing）和 拆箱（unboxing）</h2><ul>
<li><p>前面提到原始型別是沒有屬性和方法可以使用的，但我們卻可以利用字串方法來修改原始型別的字串（如下方的程式碼），這是因為 JavaScript 有 裝箱（boxing）和 拆箱（unboxing）機制來處理這些操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(&#x27;123.45&#x27;.split(&#x27;.&#x27;));</span><br><span class="line">// [&#x27;123&#x27;, &#x27;45&#x27;]</span><br></pre></td></tr></table></figure></li>
<li><p>上個段落的物件型別中有一項 <code>原始型別包裹物件（Primitive Wrapper）</code>，使用這個方式來建立的字串（數字或布林值）會是物件的形式，並且有許多原生方法可以使用，JavaScript 便是利用這個物件型別來實作裝箱與拆箱。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let str = &#x27;123&#x27;;</span><br><span class="line">let strObj = new String(&#x27;123&#x27;);</span><br><span class="line"></span><br><span class="line">console.log(typeof str); // string</span><br><span class="line">console.log(typeof strObj); // object</span><br></pre></td></tr></table></figure></li>
<li><p>裝箱（boxing）：當 JS 執行方法發現資料是原始型別時，便會使用 <code>new</code> 把原始型別資料建立成物件型別的資料，就可以順利執行物件內的方法。</p>
</li>
<li><p>拆箱（unboxing）：當 JS 完成被裝箱的物件需要執行的方法後，就會把這個物件資料還原成原始型別的資料，這時會用到兩個重要的方法，這會在接下來介紹的『轉型』再次談到：</p>
<ul>
<li><code>valueOf()</code>：回傳 <code>Number</code> 原始型別。</li>
<li><code>toString()</code>：回傳 <code>String</code> 原始型別。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="💎-強制轉型（coercion）"><a href="#💎-強制轉型（coercion）" class="headerlink" title="💎 強制轉型（coercion）"></a>💎 強制轉型（coercion）</h2><ul>
<li>強制轉型分為兩種：<code>顯性轉型</code>（explicit coercion）、<code>隱性轉型</code>（implicit coercion）</li>
</ul>
<h3 id="🔸-顯性轉型（explicit-coercion）："><a href="#🔸-顯性轉型（explicit-coercion）：" class="headerlink" title="🔸 顯性轉型（explicit coercion）："></a>🔸 顯性轉型（explicit coercion）：</h3><ul>
<li><p>顯性轉型指的是在程式碼中<code>直接撰寫</code>的型別轉換。</p>
</li>
<li><p><strong>轉數字</strong></p>
<ul>
<li><p><code>parseInt()</code>：</p>
<ul>
<li>轉整數。</li>
<li>小數點以後無條件捨去。</li>
<li>轉換方式：由左至右，遇到無法轉成數字的時候停止，回傳前面的數字。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(parseInt(&#x27;1.23&#x27;)); // 1</span><br><span class="line">console.log(parseInt(&#x27;1.23a&#x27;)); // 1</span><br><span class="line">console.log(parseInt(&#x27;a1.23&#x27;)); // NaN</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>parseFloat()</code>：</p>
<ul>
<li>轉浮點數（包含小數點以後）。</li>
<li>轉換方式與 parseInt() 相同。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(parseFloat(&#x27;1.23&#x27;)); // 1.23</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>Number()</code>：</p>
<ul>
<li>可以轉整數和浮點數。</li>
<li>數字範圍在正負 2的53次方 -1 間。</li>
<li>轉換方式：整筆字串都可以轉成數字才轉換，否則得到 NaN。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(Number(&#x27;-1.23&#x27;)); // -1.23</span><br><span class="line">console.log(Number(&#x27;-1.23a&#x27;)); // NaN</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>BigInt()</code>：</p>
<ul>
<li>轉整數</li>
<li>範圍可以超過2的53次方（表示方式會在數字後面加上 <code>n</code>）</li>
<li>轉換方式：非整數時直接報錯，不會得到 NaN。</li>
<li>需注意瀏覽器支援度。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(BigInt(&quot;9007199254740991&quot;)); // 9007199254740991n</span><br><span class="line">console.log(typeof 1n); // bigint</span><br><span class="line">console.log(BigInt(&quot;900a&quot;)); // Cannot convert 900a to a BigInt</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>算數運算子</code>：</p>
<ul>
<li>前方加上<code>+</code>：可能會和 <code>++</code> 混淆。</li>
<li>前方加上<code>-</code>：內容若是負數，會被轉成正數。</li>
<li>後方加上<code>- 0</code>：較穩定寫法。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(+&#x27;-1&#x27;); // -1</span><br><span class="line">console.log(++&#x27;-1&#x27;); // Invalid left-hand side expression in prefix operation</span><br><span class="line">console.log(-&#x27;-1&#x27;); // 1</span><br><span class="line">console.log(&#x27;-1&#x27; - 0); // -1</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>轉字串</strong></p>
<ul>
<li><p><code>toString()</code>：不能轉換 null 和 undefined，可以設定進位制。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log((3).toString()); // 3</span><br><span class="line">console.log(undefined.toString()); // Cannot read properties of undefined</span><br><span class="line">console.log((3).toString(2)); // 11</span><br></pre></td></tr></table></figure></li>
<li><p><code>String()</code>：可以轉換 null 和 undefined，不能設定進位制。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(String(3)); // 3</span><br><span class="line">console.log(String(undefined)); // undefined</span><br></pre></td></tr></table></figure></li>
<li><p><code>算數運算子</code>：加上空字串 <code>+ &#39;&#39;</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(typeof (3 + &#x27;&#x27;)); // string</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>轉布林值</strong></p>
<ul>
<li><p>布林值只有兩種值（true 或 false），轉型後會得到 true 的值稱為 truthy，得到 false 的則是 falsy，除了下列項目是 <code>falsy</code>，其他的都是 <code>truthy</code>：</p>
<ul>
<li><code>false</code></li>
<li><code>0</code></li>
<li><code>-0</code></li>
<li><code>0n</code> (BigInt)</li>
<li><code>“”</code> (空字串，包含 ``, ‘’)</li>
<li><code>null</code></li>
<li><code>undefined</code></li>
<li><code>NaN</code></li>
<li><code>document.all</code> (正常情況下不會用到)</li>
</ul>
</li>
<li><p>轉換方式：</p>
<ul>
<li><p><code>Boolean()</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(Boolean([])); // true</span><br></pre></td></tr></table></figure></li>
<li><p><code>邏輯運算子</code>：前方加上雙驚嘆號 <code>!!</code>，單驚嘆號 <code>!</code> 會是相反結果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(!true); // false</span><br><span class="line">console.log(!!&#123;&#125;); // true</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="🔸-隱性轉型（implicit-coercion）"><a href="#🔸-隱性轉型（implicit-coercion）" class="headerlink" title="🔸 隱性轉型（implicit coercion）"></a>🔸 隱性轉型（implicit coercion）</h3><ul>
<li><p>隱性轉型出現在使用運算子時，這在其他程式語言通常是不允許的（需要相同型別才可以運算），JavaScript 則會自動轉型讓程式繼續執行，也因為規則繁雜，容易疏忽出錯。</p>
</li>
<li><p>核心方法 <code>ToPrimitive</code><br>JavaScript 在執行運算時會使用 <code>ToPrimitive</code> 方法將運算元轉換成原始型別後就能繼續運算，<code>ToPrimitive</code> 帶有一個 <code>hint</code>(提示)，用來決定要轉成什麼型別，如果要了解詳細的運作順序可以參考 <strong><a href="https://zhuanlan.zhihu.com/p/29730094">深入理解Javascript中Object类型的转换</a></strong> 這篇文章，裡面引用了 ECMA 的規範詳細解說，非常值得一讀！</p>
</li>
<li><p><strong>原始型別</strong>的隱性轉型</p>
<ul>
<li><p><code>+</code> 算數運算子：加法運算中只要有一個值屬於字串型別，就會全部轉為 string，最高優先。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 有字串</span><br><span class="line">console.log(&#x27;&#x27; + 1 + null + true); // 1nulltrue</span><br><span class="line">// 無字串</span><br><span class="line">console.log(1 + null + true); // 2</span><br></pre></td></tr></table></figure></li>
<li><p>其他算數運算子：<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code> 運算都會轉成 number。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(&#x27;6&#x27; - undefined); // NaN</span><br><span class="line">console.log(9 * [9]); // 81</span><br><span class="line">console.log(&#x27;3&#x27; / &#123;&#125;); // NaN</span><br><span class="line">console.log(6 % true); // 0</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>物件型別</strong>的隱性轉型</p>
<ul>
<li><p><code>ｔoPrimitive</code> 執行物件型別的轉換時會使用到物件內的 <code>valueOf</code> 或 <code>toString</code> 方法來取得原始型別的回傳值，因為這是物件內的方法，我們可以透過覆蓋方法來改變回傳值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 刻意改成 valueOf 回傳字串、toString 回傳數字</span><br><span class="line">let a = &#123;</span><br><span class="line">    valueOf: function() &#123;</span><br><span class="line">        return &#x27;1&#x27;;</span><br><span class="line">    &#125;,</span><br><span class="line">    toString: function() &#123;</span><br><span class="line">        return 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(a + 0); // &quot;10&quot;</span><br><span class="line">console.log(a.toString()); // 2</span><br></pre></td></tr></table></figure></li>
<li><p><code>陣列</code>也是物件，ToPrimitive 會回傳陣列本身內容執行 <code>toString()</code> 方法後的字串。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 空陣列轉字串 &quot;&quot;，空物件轉字串 &quot;[object Object]&quot;</span><br><span class="line">console.log([] + &#123;&#125;); // &quot;[object Object]&quot;</span><br><span class="line"></span><br><span class="line">// 陣列轉字串 &quot;1,2,3&quot;，後方數字配合轉字串</span><br><span class="line">console.log([1,2,3] + 2 + 1); // &quot;1,2,321&quot;</span><br></pre></td></tr></table></figure></li>
<li><p><code>&#123;&#125; + 任意值</code>：</p>
<ol>
<li><code>&#123;&#125;</code> 在運算元前方時會被視為<code>區塊語句</code>，而不是物件，所以實際執行的只有後面的 <code>+ x</code></li>
<li><code>+ 任意值</code>是前一段落提到的<code>顯性轉型</code>轉數字的方法，所以後方的運算元轉為 number 型別。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 強制轉型</span><br><span class="line">console.log(+&#123;&#125;); // NaN</span><br><span class="line"></span><br><span class="line">// 看起來是物件加陣列，實際上是後方的陣列強制轉型為數字</span><br><span class="line">console.log(&#123;&#125; + []); // 0 </span><br><span class="line"></span><br><span class="line">// 上方程式實際執行時等同下面兩行：</span><br><span class="line">&#123;&#125;</span><br><span class="line">+[];</span><br><span class="line"></span><br><span class="line">// 宣告一個物件變數 x 來存放空物件，才能被當成物件來計算</span><br><span class="line">let x = &#123;&#125;;</span><br><span class="line">console.log(x + []); // &quot;[object Object]&quot;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p><code>&#123;&#125; + &#123;&#125;</code>：這是一個特別狀況所以額外說明，不同的瀏覽器會有不同的執行結果：</p>
<ol>
<li>NaN - 第一個 {} 被視為區塊，</li>
<li>“[object Object][object Object]” - 第一個 {} 被視為物件</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>邏輯運算</strong><br>邏輯運算中的運算元都會被轉為 boolean，差別在於其運算後回傳的結果。</p>
<ul>
<li><p>|| (or) 會回傳第一個結果為 true 的運算元，若無，則是最後一個。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(0 || false || null || undefined); // undefined</span><br><span class="line">console.log(0 || false || null || &#123;&#125; || undefined); // &#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>&amp;&amp; (and) 若運算結果為 true，會回傳最後一個運算元，若運算結果為 false，回傳第一個結果為 false 的運算元。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(true &amp;&amp; &#123;&#125; &amp;&amp; -2 &amp;&amp; [&#x27;a&#x27;]); // [&#x27;a&#x27;]</span><br><span class="line">console.log(1 &amp;&amp; 0 &amp;&amp; true &amp; false); // 0</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="💎-結語"><a href="#💎-結語" class="headerlink" title="💎 結語"></a>💎 結語</h2><p>關於轉型的細節實在太多，族繁不及備載，一些極端的範例在實際撰寫時並不會用到，不求成為行走的 MDN，但求踩坑的時候能順利 debug 就好！</p>
<blockquote>
<p>參考文章<br><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/BigInt">MDN-BigInt</a><br><a href="https://medium.com/@sunnyhuang.sc/%E6%8A%80%E8%A1%93%E7%AD%86%E8%A8%98-javascript-%E4%BD%95%E8%AC%82%E5%BC%B7%E5%88%B6%E8%BD%89%E5%9E%8B-coercion-%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E4%BD%9C%E5%88%B0%E8%BD%89%E6%8F%9B%E5%9E%8B%E5%88%A5-d7e39e30083">sunnyhuang-何謂強制轉型（coercion）以及如何作到轉換型別</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toString">MDN-Number.prototype.toString()</a><br><a href="https://codertw.com/%E5%89%8D%E7%AB%AF%E9%96%8B%E7%99%BC/254123/">淺談JS中String()與.toString()的區別 - 程式前沿</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toPrimitive">MDN-Symbol.toPrimitive</a>。<br><a href="https://eddychang.me/js-object-plus-object">Eddy 思考與學習-JS中的 {} + {} 與 {} + [] 的結果是什麼？</a><br><a href="https://eddychang.me/js-object-plus-object"></a></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript - Basic</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>[JS] 提昇（Hoisting）機制</title>
    <url>/2021/11/23/JShoisting/</url>
    <content><![CDATA[<p><img data-src="/images/js-hoisting.png"></p>
<span id="more"></span> 
<p>如果今天想要使用電腦，該怎麼做？</p>
<p>你的答案很可能是，按下電腦開機鍵就好，但實際上得先有主機、滑鼠、鍵盤、螢幕、電源、作業系統…等軟、硬體環境，才有辦法使用電腦。</p>
<p>JavaScript 雖然是直譯式語言（不需透過編譯器轉譯成可執行檔），但是『執行』之前，還是需要先把原本字元組成的程式碼編譯成執行環境（就像是上面提到的準備滑鼠、鍵盤…等等），而其中一個步驟就是先將 <code>變數</code> 和 <code>函數</code> 的名稱放入記憶體，這種行為在 ECMA 的文件中沒有明確定義專有名詞，一般會用 <code>提昇（Hoisting）</code>來稱呼。</p>
<blockquote>
<p>參考文章：<br><a href="https://developer.mozilla.org/zh-TW/docs/Glossary/Hoisting">MDN - 提升（Hoisting）</a></p>
</blockquote>
<hr>
<p>提昇（Hoisting）的方式會因為變數類型有所不同：</p>
<h2 id="💎-var、function："><a href="#💎-var、function：" class="headerlink" title="💎 var、function："></a>💎 var、function：</h2><p>按照逐行執行的邏輯，下面前兩行程式碼會因為還沒有產生這個變數而出現錯誤，但實際上並不會出現任何錯誤。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(a); // undefined</span><br><span class="line">console.log(foo); // foo()&#123;return &#x27;Hello&#x27;;&#125;</span><br><span class="line"></span><br><span class="line">var a;</span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">  return &#x27;Hello&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>從結果回推實際執行的順序會像下面這樣：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a;</span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">  return &#x27;Hello&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(a);</span><br><span class="line">console.log(foo);</span><br></pre></td></tr></table></figure>

<p>這次做小調整，改成賦予 a 變數一個值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(a); // undefined</span><br><span class="line">var a = 1;</span><br><span class="line">console.log(a); // 1</span><br></pre></td></tr></table></figure>

<p>雖然沒有出現錯誤，但是 a 的值並沒有跟著被提昇，回推的執行順序會像下面這樣：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a</span><br><span class="line">console.log(a); // undefined</span><br><span class="line">a = 1;</span><br><span class="line">console.log(a); // 1</span><br></pre></td></tr></table></figure>

<p>再看下面這段程式碼，想想看結果是什麼：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var b = 1;</span><br><span class="line">var b;</span><br><span class="line">console.log(b);</span><br></pre></td></tr></table></figure>

<p>如果不清楚運作 JavaScript 的運作機制，可能會認為答案是 <code>undefined</code>，覺得後者蓋掉前者，但答案其實是 <code>1</code>，回推後的實際執行會像是下面這樣：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var b;</span><br><span class="line">var b;</span><br><span class="line">b = 1;</span><br><span class="line">console.log(b);</span><br></pre></td></tr></table></figure>

<p>『重複宣告』加上『提昇機制』是不是讓人覺得很坑呢？</p>
<h2 id="💎-let、const："><a href="#💎-let、const：" class="headerlink" title="💎 let、const："></a>💎 let、const：</h2><p>ES6 版本提供了 <code>let</code> 和 <code>const</code> 兩種變數宣告方式，這兩種新的方式解決了 <code>var</code> 的許多奇怪問題。</p>
<p>使用 <code>let</code> 和 <code>const</code> 宣告的變數名稱在 JavaScript 從『環境建立』一直執行到『變數實際存在的那一行程式碼』的這段期間，變數名稱都是無法被取用的，這段期間稱為 Temporal Dead Zone（TDZ），暫時性死區。</p>
<p>這個機制就像是我買了對號座的票（宣告），這個位置的票就不能被其他人購買（不能重複宣告），但是在我坐上車位前（實際執行的那段程式碼），都無法在這個位置找到我（TDZ鎖定）。</p>
<p>以下是使用 <code>let</code> 或 <code>const</code> 宣告的輸出結果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(x); // x is not defined</span><br><span class="line">let x = 1;</span><br><span class="line">console.log(x); // 前面已經因為執行階段出錯終止，不會執行到這裡</span><br></pre></td></tr></table></figure>

<blockquote>
<p>參考文章<br>1、<a href="https://blog.techbridge.cc/2018/11/10/javascript-hoisting/">我知道你懂 hoisting，可是你了解到多深？</a><br>2、<a href="https://eddychang.me/es6-tdz">理解ES6中的暫時死區(TDZ)</a></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript - Basic</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>[JS] 陳述式（Statement）與表達式（Expression）</title>
    <url>/2021/11/21/JSstatement/</url>
    <content><![CDATA[<p><img data-src="/images/js-statement.png"></p>
<span id="more"></span> 

<p>陳述式(Statement)與表達式(Expression)不是特定的使用方法或技巧，而是語法觀念，所有的程式碼都可以分成這兩類型的語句。</p>
<h2 id="💎-各種譯名："><a href="#💎-各種譯名：" class="headerlink" title="💎 各種譯名："></a>💎 各種譯名：</h2><ul>
<li>Statement：陳述式。</li>
<li>Expression：表示式、運算式、表達式。</li>
</ul>
<h2 id="💎-兩者的差別："><a href="#💎-兩者的差別：" class="headerlink" title="💎 兩者的差別："></a>💎 兩者的差別：</h2><ul>
<li><code>陳述式：不會回傳結果</code>。</li>
<li><code>表達式：會回傳結果</code>。</li>
</ul>
<h2 id="💎-陳述式的種類"><a href="#💎-陳述式的種類" class="headerlink" title="💎 陳述式的種類"></a>💎 陳述式的種類</h2><ul>
<li>流程控制<ul>
<li>{  } 區塊</li>
<li>if..else</li>
<li>switch</li>
<li>try..catch</li>
</ul>
</li>
<li>宣告<ul>
<li>var</li>
<li>let</li>
<li>const</li>
</ul>
</li>
<li>函式<ul>
<li>function</li>
<li>return</li>
</ul>
</li>
<li>疊代<ul>
<li>for</li>
<li>while</li>
</ul>
</li>
<li>其他<ul>
<li>export</li>
<li>import</li>
</ul>
</li>
</ul>
<blockquote>
<p>詳細可以參考 MDN：<br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements">Statements and declarations</a></p>
</blockquote>
<h2 id="💎-表達式的種類"><a href="#💎-表達式的種類" class="headerlink" title="💎 表達式的種類"></a>💎 表達式的種類</h2><ul>
<li>值：單純一個數字、字串、布林、物件…等等。</li>
<li>變數</li>
<li>賦值（=）</li>
<li>運算子（+, -, /, ==, ===, != ……）</li>
<li>會回傳結果都是</li>
</ul>
<h2 id="💎-陳述式與表達式的混用"><a href="#💎-陳述式與表達式的混用" class="headerlink" title="💎 陳述式與表達式的混用"></a>💎 陳述式與表達式的混用</h2><p>一段程式碼通常不會只使用其中一種方式撰寫，接著用以下範例來解說：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let example = function () &#123;</span><br><span class="line">    if (1 == 1) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>這段程式碼中的<code>陳述式</code>：</p>
<ul>
<li>let</li>
<li>function</li>
<li>if..else</li>
<li>return</li>
</ul>
</li>
<li><p>這段程式碼中的<code>表達式</code>：</p>
<ul>
<li>1</li>
<li>=</li>
<li>==</li>
</ul>
</li>
<li><p>這整段程式碼雖然結合了各種陳述式和表達式，最終是將函式賦予一個變數名稱，所以是一個<code>表達式</code>(賦值是表達式)，又稱為<code>函式表達式</code>，而一般宣告名稱的函式則稱為<code>函式陳述式</code>。</p>
</li>
</ol>
<blockquote>
<p>參考文章：<br><a href="https://wcc723.github.io/development/2020/09/17/js-expression/">卡斯柏 - JavaScript 表達式觀念及運用 - JS Expression</a></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript - Basic</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>[JS] undefined 和 null 的差異</title>
    <url>/2021/11/18/JSundefined/</url>
    <content><![CDATA[<p><img data-src="/images/js-null.png"></p>
<span id="more"></span> 
<p>undefined 是 JavaScript 的特有物之一，新手入門時，常會對 undefined 和 null 這兩個型別產生疑問，以下逐步解說。</p>
<hr>
<h2 id="💎-null"><a href="#💎-null" class="headerlink" title="💎 null"></a>💎 null</h2><ul>
<li><p><code>null</code> 表示一個空值（沒有值），是各種程式語言中常見的型別，如果有後端資料庫的相關經驗，在設計 SQL 資料表時，可以在非必要欄位設定『允許 null』，當資料建立起來的時候，這些沒填的欄位就會塞入 null 來表示空值。</p>
</li>
<li><p>JS 中的 <code>null</code> 是一種<code>原始型別</code>，可以賦予變數的值為 null 來表示他是<code>空值</code>，當看到 null 時，我們可以知道這是人為賦予的空值，不是系統自動產生的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let a = null; // 不要包引號，會變成字串</span><br><span class="line">console.log(a); // null</span><br></pre></td></tr></table></figure></li>
<li><p>JS 裡的 null 還有一些特色：</p>
<ul>
<li>檢查型別（typeof）的設計失誤（因影響久遠，此錯誤不會修正），正確是 null。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(typeof null); // object</span><br></pre></td></tr></table></figure></li>
<li>null 雖然代表著空值，轉型成字串時會照字面上的英文轉。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(null + &#x27;&#x27;); // &#x27;null&#x27;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>參考資料： <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/null">MDN-null</a>、<a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Operators/typeof">MDN-typeof</a></p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="💎-undefined"><a href="#💎-undefined" class="headerlink" title="💎 undefined"></a>💎 undefined</h2><ul>
<li>undefined 從字面上可以理解成『未定義』，表示這個變數並沒有被賦予任何的值，跟已經被賦予空值（null）代表著不一樣的資料狀態，比起 null，undefined 更容易跟 not defined 搞混：<ul>
<li><code>undefined</code> 是變數<code>已被宣告</code>且<code>未賦值</code>，屬於<code>原始型別</code>之一。</li>
<li><code>not defined</code> 是變數<code>未被宣告</code>，不屬於原始型別，是程式<code>執行時的錯誤訊息（runtime error）</code>。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let a;</span><br><span class="line"></span><br><span class="line">console.log(a); // undefined</span><br><span class="line">console.log(typeof a); // undefined</span><br><span class="line">console.log(b); // ReferenceError: b is not defined</span><br><span class="line">console.log(typeof b); // undefined</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h2 id="💎-null-undefined"><a href="#💎-null-undefined" class="headerlink" title="💎 null == undefined ?"></a>💎 null == undefined ?</h2><ul>
<li>看完前面的段落，可以知道 undefined 和 null 意義上是完全不同，接著來比較看看：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(undefined == null); // true</span><br></pre></td></tr></table></figure>
不是說好不一樣的嗎？<br>可能是轉型在作亂，改用嚴格比較（===）看看。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(undefined === null); // false</span><br></pre></td></tr></table></figure>
果然是轉型搞的鬼，但是為什麼 undefined 和 null 轉型後會相等？下個段落繼續說明。</li>
</ul>
<hr>
<h2 id="💎-truthy-amp-falsy"><a href="#💎-truthy-amp-falsy" class="headerlink" title="💎 truthy &amp; falsy"></a>💎 truthy &amp; falsy</h2><ul>
<li><p>JavaScript 中的各種值都可以被轉換成布林值（Boolean），轉換後為 true 的值稱為 <code>truthy</code>，反之則稱為 <code>falsy</code>，除了以下所列的值屬於 falsy 值，其他都是 truthy 值。<br>（完整的圖表可以參考 <a href="https://dorey.github.io/JavaScript-Equality-Table/">JS Comparison Table</a>）</p>
<ul>
<li>false</li>
<li>0</li>
<li>-0</li>
<li>0n (BigInt)</li>
<li>“” (空字串，包含 <code>單引號</code>、<code>反引號</code>)</li>
<li>null</li>
<li>undefined</li>
<li>NaN</li>
<li>document.all (正常不會用到)</li>
</ul>
</li>
<li><p>由上可知，<code>null</code>和<code>undefined</code>都是<code>falsy</code>值，在做一般相等的比較時，都會被轉成 false，所以得到的結果是 true。</p>
</li>
<li><p>truthy 和 falsy 的運用：檢查資料是否存在時可以運用轉成布林值的方法減少程式碼撰寫長度。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 原始寫法：</span><br><span class="line">if (arr[0] === undefined) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 轉型為布林值</span><br><span class="line">if (!arr[0]) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>參考資料： <a href="https://developer.mozilla.org/en-US/docs/Glossary/Falsy">MDN-Falsy</a>、<a href="https://dorey.github.io/JavaScript-Equality-Table/">dorey-JS Comparison Table</a></p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="💎-null-和-undefined-出現時機"><a href="#💎-null-和-undefined-出現時機" class="headerlink" title="💎 null 和 undefined 出現時機"></a>💎 null 和 undefined 出現時機</h2><p>除了未賦值的 undefined 和自己定義的 null 外，還有什麼時候會出現呢？</p>
<ul>
<li><code>null</code>：會出現在 BOM(Browser Object Model)中不存在的資料，例如：document.querySelector、localStorage、 sessionStorage…等，不存在時會得到 null。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">localStorage.getItem(&#x27;a&#x27;); // null</span><br><span class="line">sessionStorage.getItem(&#x27;a&#x27;); // null</span><br></pre></td></tr></table></figure></li>
<li><code>undefined</code>：取用不存在 JS 程式碼中或是未賦值的資料會得到 undefined。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let arr = [];</span><br><span class="line">let obj = &#123;&#125;;</span><br><span class="line">console.log(arr[1]); // undefined</span><br><span class="line">console.log(obj.a); // undefined</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<p>以上是我對這兩個型別的一點認知，如有錯誤或是補充的知識點，也歡迎大家不吝指教，謝謝觀看！</p>
]]></content>
      <categories>
        <category>JavaScript - Basic</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>[JS] 物件與 JSON 格式操作技巧</title>
    <url>/2021/11/22/JSobject/</url>
    <content><![CDATA[<p><img data-src="/images/js-json.png"></p>
<span id="more"></span> 
<p>物件操作和串接 API 是 JavaScript 在現代網頁開發中的精華，這篇就來介紹物件取值的基本方法和小技巧。</p>
<h2 id="💎-物件（Object）"><a href="#💎-物件（Object）" class="headerlink" title="💎 物件（Object）"></a>💎 物件（Object）</h2><h3 id="🔸-基本結構，使用-來存放資料："><a href="#🔸-基本結構，使用-來存放資料：" class="headerlink" title="🔸 基本結構，使用{}來存放資料："></a>🔸 基本結構，使用<code>&#123;&#125;</code>來存放資料：</h3><p>(本篇文章不討論使用 create、new 和 prototype 的操作)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const obj = &#123;&#125; // 空物件</span><br></pre></td></tr></table></figure>

<h3 id="🔸-內容結構是-key-value-pair-的格式："><a href="#🔸-內容結構是-key-value-pair-的格式：" class="headerlink" title="🔸 內容結構是 key/value pair 的格式："></a>🔸 內容結構是 key/value pair 的格式：</h3><ul>
<li>前方的 key 在 JavaScript 中為物件的屬性（property）。</li>
<li>後方的 value 可以是各種型別的值。<br>以下為一個物件範例，接下來的段落都使用這個物件來示範操作。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const obj = &#123;</span><br><span class="line">  a: function()&#123;return &#x27;a&#x27;&#125;,</span><br><span class="line">  b: null,</span><br><span class="line">  c: &#123;</span><br><span class="line">    d: [&#123;e: 2&#125;]</span><br><span class="line">  &#125;,</span><br><span class="line">  1: &#x27;bad&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="🔸-物件取值"><a href="#🔸-物件取值" class="headerlink" title="🔸 物件取值"></a>🔸 物件取值</h3></li>
<li>方法１：<code>objectName.propertyName</code>，使用<code>.</code>加上屬性名稱來取值，如果是多層級的物件，就繼續往下使用<code>.</code>加屬性名稱，使用<code>.</code>時需要遵守變數名稱規範，不然會報錯。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(obj.a); // f ()&#123;return &#x27;a&#x27;&#125;</span><br><span class="line">console.log(obj.a()); // &#x27;a&#x27;</span><br><span class="line">console.log(obj.c.d[0].e); // 2</span><br><span class="line">console.log(obj.1); // Uncaught SyntaxError: Unexpected number</span><br></pre></td></tr></table></figure></li>
<li>方法２：<code>objectName[propertyName or 變數]</code><br>這種方法不受物件屬性名稱限制，並且可以帶入變數，但使用時須注意<code>[]</code>內若不是帶入變數，需要加上<code>&#39;&#39;（引號）</code>，否則找不到變數會報錯。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(obj[&#x27;a&#x27;]]); // f ()&#123;return &#x27;a&#x27;&#125;</span><br><span class="line">console.log(obj[a]); // ReferenceError: a is not defined</span><br><span class="line">console.log(obj[&#x27;c&#x27;].d[0][&#x27;e&#x27;]); // 2  (方式１、2混用)</span><br><span class="line">console.log(obj[&#x27;1&#x27;]); // &#x27;bad&#x27;</span><br><span class="line">let num = 1;</span><br><span class="line">console.log(obj[num]); // &#x27;bad&#x27;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="🔸-物件賦值"><a href="#🔸-物件賦值" class="headerlink" title="🔸 物件賦值"></a>🔸 物件賦值</h3><p>方法同取值，只要加上 <code>=</code> 就能賦值，也可以用新的屬性名稱來新增物件屬性；同樣也能用 <code>.</code> 和 <code>[]</code> 兩種方式操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">obj.a = 1; // 變更原有屬性 a 的值</span><br><span class="line">obj[&#x27;a&#x27;] = 2; // 變更原有屬性 a 的值</span><br><span class="line">obj.f = 0; // 原本沒有屬性 f ，新增屬性 f 且值為 0</span><br></pre></td></tr></table></figure>

<h3 id="🔸-物件取所有屬性"><a href="#🔸-物件取所有屬性" class="headerlink" title="🔸 物件取所有屬性"></a>🔸 物件取所有屬性</h3><p><code>Object.keys()</code> 方法會回傳一個陣列，並列出該物件第一層（直屬於物件）的所有屬性名稱，且這個陣列會由小至大排序。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object.keys(obj); // [&#x27;1&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span><br></pre></td></tr></table></figure>

<h3 id="🔸-物件取所有屬性的值"><a href="#🔸-物件取所有屬性的值" class="headerlink" title="🔸 物件取所有屬性的值"></a>🔸 物件取所有屬性的值</h3><p><code>Object.values()</code> 方法會回傳一個陣列，並列出該物件第一層（直屬於物件）的所有屬性值，且這個陣列會依照屬性名稱由小至大排序。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object.values(obj); // [&#x27;bad&#x27;, ƒ, null, &#123;…&#125;]</span><br></pre></td></tr></table></figure>

<h3 id="🔸-物件轉陣列"><a href="#🔸-物件轉陣列" class="headerlink" title="🔸 物件轉陣列"></a>🔸 物件轉陣列</h3><p><code>Object.entries()</code> 方法會回傳一個陣列，並以二維陣列的方式列出該物件第一層（直屬於物件）的所有屬性和值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object.entries(obj); </span><br><span class="line">// [[&#x27;1&#x27;, &#x27;bad&#x27;],[&#x27;a&#x27;, ƒ], [&#x27;b&#x27;, null], [&#x27;c&#x27;, &#123;…&#125;]]</span><br></pre></td></tr></table></figure>

<h3 id="🔸-物件屬性檢查"><a href="#🔸-物件屬性檢查" class="headerlink" title="🔸 物件屬性檢查"></a>🔸 物件屬性檢查</h3><p>物件陣列的操作很常遇到，當物件資料不完整時，可能會造成執行中斷，這時候就需要先檢查物件的屬性是否存在：</p>
<ul>
<li><p>方法１：檢查該屬性是否為<code>undefined</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(obj.x === undefined); // true</span><br></pre></td></tr></table></figure></li>
<li><p>方法２：使用<code>hasOwnProperty()</code>方法檢查有沒有該屬性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(obj.hasOwnProperty(&#x27;x&#x27;)); // false</span><br></pre></td></tr></table></figure></li>
<li><p>方法３：<strong>推薦</strong>使用<code>Optional chaining operator</code>，只要一個<code>?</code>就能判斷，並且繼續往下取值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(obj?.x)); // undefined</span><br><span class="line">console.log(obj?.c?.d[0]?.e); // 2</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="💎-JSON（JavaScript-Object-Notation）"><a href="#💎-JSON（JavaScript-Object-Notation）" class="headerlink" title="💎 JSON（JavaScript Object Notation）"></a>💎 JSON（JavaScript Object Notation）</h2><p>JSON 是一種通用資料交換格式，許多程式語言都能夠解析並被廣泛使用，通常在串接 api 時都是以 JSON 格式為主，和 JavaScript 的 Object 同樣是 key/value pair 的格式，但是屬性名稱會用引號包起來，範例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;John&quot;,</span><br><span class="line">  &quot;sex&quot;: &quot;male&quot;,</span><br><span class="line">  &quot;age&quot;: 20</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="🔸-解析-JSON-格式資料"><a href="#🔸-解析-JSON-格式資料" class="headerlink" title="🔸 解析 JSON 格式資料"></a>🔸 解析 JSON 格式資料</h3><ul>
<li><code>JSON 的型別是字串</code>，所以需要轉換成物件才能使用，JavaScript 中提供了<code>JSON.parse()</code>的方法來轉換成可以操作的物件。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let data = ...json file...</span><br><span class="line">console.log(JSON.parse(data)); Object&#123;...&#125;</span><br></pre></td></tr></table></figure></li>
<li>過去實作 ajax 功能時使用的 XMLHttpRequest 取得的 json 資料都需要經過轉換才能使用，而現在常用的 <code>Fetch</code>、<code>Axios</code> 已經包裝成物件格式，<code>不需要再轉換</code>。</li>
<li>JavaScript 也提供了<code>JSON.stringify()</code>的方法，可以將物件轉成 JSON 字串格式。</li>
<li>localStorage、sessionStorage 存放資料為字串格式，如果要存放物件時需要先使用<code>JSON.stringify()</code>轉換存入，取出後再使用<code>JSON.parse()</code>轉回物件格式。</li>
</ul>
<blockquote>
<p>參考資料：<br><a href="https://zh.wikipedia.org/wiki/JSON">Wiki-JSON</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object">MDN-Object</a><br><a href="https://pjchender.blogspot.com/2016/01/javascriptobjectjson.html">JavaScript中物件(object)和JSON格式的轉換</a></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript - Basic</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>[JS] 搞懂 Promise、Async、Await</title>
    <url>/2022/03/17/async/</url>
    <content><![CDATA[<p>WIP…</p>
]]></content>
      <categories>
        <category>JavaScript - Basic</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>[JS] 變數宣告方式：let、const、var</title>
    <url>/2021/11/16/JSvariable/</url>
    <content><![CDATA[<p><img data-src="/images/js-variables.png"></p>
<span id="more"></span> 

<p>JavaScript 過去只有 <code>var</code> 一種變數宣告方式，直到 2015 年發表的 ECMAScript 2015（ES2015），第 6 版，又被稱為 ECMAScript 6（通常簡稱為 ES6 ），才有 <code>let</code> 和 <code>const</code> 兩種新的變數宣告方式，這個版本有相當多的革新，現在常用的箭頭函式、樣板字串…等都包含在其中。</p>
<blockquote>
<p>參考資料： <a href="https://zh.wikipedia.org/wiki/ECMAScript">Wiki - ECMAScript</a></p>
</blockquote>
<hr>
<h2 id="💎-Can-I-Use"><a href="#💎-Can-I-Use" class="headerlink" title="💎 Can I Use?"></a>💎 Can I Use?</h2><p>雖然 2015 年距今已經超過 6 年了，但是仍有些企業或公司在使用 IE 這類過時的瀏覽器，<code>let</code> 和 <code>const</code> 在 IE 11 只有部分支援、 IE 10 以下版本則是完全不支援，如有支援需求就需要搭配 Babel 來轉換成兼容的程式碼。</p>
<blockquote>
<p>參考資料： <a href="https://caniuse.com/">Can I Use</a></p>
</blockquote>
<hr>
<h2 id="💎-變數宣告方式的差異"><a href="#💎-變數宣告方式的差異" class="headerlink" title="💎 變數宣告方式的差異"></a>💎 變數宣告方式的差異</h2><p><code>var</code> 規範較鬆，有許多小陷阱需要小心使用，<code>let</code> 和 <code>const</code> 有了進一步的規範，可以針對不同需求運用，使用上較安全，兩者間有５個主要的差異在下個段落逐一說明。：</p>
<ul>
<li>可否重複宣告</li>
<li>可否重新賦值</li>
<li>是否需要初始值</li>
<li>作用域的範圍</li>
<li>提昇（Hoisting）機制的差異</li>
</ul>
<hr>
<h3 id="🔸-1、重複宣告"><a href="#🔸-1、重複宣告" class="headerlink" title="🔸 1、重複宣告"></a>🔸 1、重複宣告</h3><ul>
<li><p><code>var</code> 可以重複宣告同一個變數名稱，後者會覆蓋前者，而且程式不會報錯，使用起來較危險，萬一不小心使用了相同的名稱，可能造成其他段落程式碼出錯。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">var a = 2;</span><br><span class="line">console.log(a); // 2</span><br></pre></td></tr></table></figure></li>
<li><p><code>let</code> 和 <code>const</code> 不允許重複宣告，使用起來較安全。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let b = 1;</span><br><span class="line">let b = 2;</span><br><span class="line">// Uncaught SyntaxError: Identifier &#x27;b&#x27; has already been declared</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="🔸-2、重新賦值"><a href="#🔸-2、重新賦值" class="headerlink" title="🔸 2、重新賦值"></a>🔸 2、重新賦值</h3><ul>
<li><p>如果不知道『常數』是什麼，可以先看一下維基百科的說明。</p>
<blockquote>
<p>摘錄自維基百科：<br>常數，又稱定數（Constant），是指一個數值固定不變的常量，例如圓周率，與之相反的是變數。</p>
<p>參考資料： <a href="https://zh.wikipedia.org/wiki/%E5%B8%B8%E6%95%B0">Wiki - 常數</a>   </p>
</blockquote>
</li>
<li><p>過去只有 <code>var</code> 時，如果想要宣告一個不能被變更的常數，通常會用全部大寫，加上 <code>_</code> 連接單字來標示，但是名稱只能幫助辨識，實際操作並不具有常數的限制。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var DO_NOT_TOUCH_ME = &#x27;X&#x27;;</span><br><span class="line">DO_NOT_TOUCH_ME = &#x27;我偏要改&#x27;;</span><br><span class="line">console.log(DO_NOT_TOUCH_ME); // 我偏要改</span><br></pre></td></tr></table></figure></li>
<li><p>ES6 提供的 <code>const</code> 宣告方式可以實際的宣告一個常數，有了 <code>const</code> 之後不需要使用大寫格式命名來區別是不是常數，看宣告方式即可（視團隊開發時的規範而定）；而 <code>let</code> 則是和 <code>var</code> 一樣可以重新賦值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const doNotTouchMe = &#x27;X&#x27;;</span><br><span class="line">doNotTouchMe = &#x27;我偏要碰&#x27;;</span><br><span class="line">// Uncaught TypeError: Assignment to constant variable.</span><br></pre></td></tr></table></figure></li>
<li><p><code>const</code> 的使用時機：對 JS 新手來說，大概只會想到圓周率、太陽數量…等，在撰寫時遇到下列的情形都建議使用 <code>const</code> 宣告。</p>
<ul>
<li><code>DOM</code>：使用 <code>querySelector</code> 這類方法取得的 DOM 如果被改變，容易造成邏輯混亂，維護困難。</li>
<li><code>陣列</code>：使用陣列方法來操作，避免被 <code>=</code> 賦值給覆蓋掉。</li>
<li><code>物件</code>：使用物件方法來操作，避免被 <code>=</code> 賦值給覆蓋掉。</li>
<li><code>函式表示式</code>：避免被 <code>=</code> 賦值給覆蓋掉。</li>
</ul>
<blockquote>
<p><strong>延伸問題：</strong><br>使用 const 宣告的變數應該不能被變更才對，為什麼『陣列』和『物件』要使用 const 來宣告？<br><strong>Ans：</strong><br>變數裡面存放的陣列和物件並不是實體，而是指向實體的記憶體位置，就像是變數名稱存放了帝寶的地址，透過這個變數名稱的值能到達帝寶的實體位置，對大樓做變更操作。<br>詳細可以參考我的另一篇文章 <a href="https://stark920.github.io/2021/11/17/JScallby/">參數傳遞方式 Call by what?</a></p>
</blockquote>
</li>
</ul>
<hr>
<h3 id="🔸-3、初始值"><a href="#🔸-3、初始值" class="headerlink" title="🔸 3、初始值"></a>🔸 3、初始值</h3><ul>
<li>常數是不能更動的值，在一開始設定好值也是相當合理，因此 <code>const</code> 在宣告的時候一定要賦予值，<code>var</code> 和 <code>let</code> 則無此限制。  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const a;</span><br><span class="line">// Uncaught SyntaxError: Missing initializer in const declaration</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="🔸-4、作用域"><a href="#🔸-4、作用域" class="headerlink" title="🔸 4、作用域"></a>🔸 4、作用域</h3><ul>
<li>作用域（Scope）是變數可以被使用的區域，也代表著在相同的作用域才會有重複命名的衝突問題，只要作用域不同就可以宣告相同名稱的變數。<ul>
<li><code>var</code>：函式作用域，只在 function 間區隔作用域，範圍大，不好區分。</li>
<li><code>let、const</code>：區塊作用域，在 {…}（大括弧）間區隔作用域，範圍小，容易區分。</li>
</ul>
</li>
</ul>
<blockquote>
<p>詳細說明可以參考我的另一篇文章： <a href="https://stark920.github.io/2022/01/04/JSscope">[JS] 作用域（Scope）與範圍鏈（Scope Chain）</a></p>
</blockquote>
<hr>
<h3 id="🔸-5、提昇（Hoisting）"><a href="#🔸-5、提昇（Hoisting）" class="headerlink" title="🔸 5、提昇（Hoisting）"></a>🔸 5、提昇（Hoisting）</h3><ul>
<li>JavaScript 在進入執行階段前會將文件中所有宣告的變數、函式（函式陳述式）提前到最上方，差異如下：<ul>
<li><code>var</code>：變數提到最上方後<code>會實體化</code>（寫入記憶體，但尚未賦值），在實際執行到該行變數宣告的程式碼前<code>可以被取用</code>（取值結果為 undefined）。</li>
<li><code>let、const</code>：變數提前到最上方後<code>不會實體化</code>，在實際執行到該行變數宣告的程式碼前<code>不可以取用</code>（取值結果為 執行階段錯誤），這段不能取用的期間又稱為<code>暫時性死區（TDZ）</code>。</li>
</ul>
</li>
</ul>
<blockquote>
<p>詳細說明可以參考我的另一篇文章： <a href="https://stark920.github.io/2021/11/23/JShoisting">[JS] 提昇（Hoisting）機制</a></p>
</blockquote>
<hr>
<h2 id="💎-總結"><a href="#💎-總結" class="headerlink" title="💎 總結"></a>💎 總結</h2><p>整理後的變數宣告方式差異列表如下：</p>
<table>
<thead>
<tr>
<th align="center"><img width=100/></th>
<th align="center">var<img width=100/></th>
<th align="center">let<img width=100/></th>
<th align="center">const<img width=100/></th>
</tr>
</thead>
<tbody><tr>
<td align="center">重複宣告</td>
<td align="center">✅</td>
<td align="center">❌</td>
<td align="center">❌</td>
</tr>
<tr>
<td align="center">重新賦值</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">❌</td>
</tr>
<tr>
<td align="center">強制賦予初始值</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">✅</td>
</tr>
<tr>
<td align="center">作用域</td>
<td align="center">function</td>
<td align="center">{ }</td>
<td align="center">{ }</td>
</tr>
<tr>
<td align="center">提升機制</td>
<td align="center">可被取用</td>
<td align="center">TDZ</td>
<td align="center">TDZ</td>
</tr>
</tbody></table>
<p>以上是我對變數型別的一點認知，如有錯誤或是補充的知識點，也歡迎大家不吝指教，謝謝！</p>
<blockquote>
<p>參考資料： <a href="https://www.youtube.com/watch?v=FGdKdn_CnWo&ab_channel=%E5%85%AD%E8%A7%92%E5%AD%B8%E9%99%A2">六角學院－JavaScript 那個 let, const, var 到底差在哪？</a></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript - Basic</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>[Node.JS] 建立伺服器、掌握基本知識</title>
    <url>/2022/02/22/nodejs1/</url>
    <content><![CDATA[<p><img data-src="/images/nodejs-logo.png"></p>
<span id="more"></span> 

<p>這篇文章記錄了如何建立一個本地網頁服務，讓我們可以透過瀏覽器看到伺服器回傳的資料。</p>
<hr>
<h2 id="💎-基本技能-－-模組引用"><a href="#💎-基本技能-－-模組引用" class="headerlink" title="💎 基本技能 － 模組引用"></a>💎 基本技能 － 模組引用</h2><p>在 Node.js 中會使用 JavaScript 的模組方法來載入各種功能，這個段落會先介紹如何操作，如果已經熟悉可以跳過，進入下個段落。</p>
<p>範例情境：</p>
<ul>
<li>主要檔案：a.js</li>
<li>模組－寫法１：b.js</li>
<li>模組－寫法２：c.js</li>
</ul>
<h3 id="a-js"><a href="#a-js" class="headerlink" title="a.js"></a>a.js</h3><ul>
<li>使用 require 來引入其他資源<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自己的變數</span></span><br><span class="line"><span class="keyword">let</span> contentA = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 引用 b.js，如果被引用的檔案在相同目錄，路徑前方加上 ./ </span></span><br><span class="line"><span class="keyword">const</span> contentB = <span class="built_in">require</span>(<span class="string">&#x27;./b&#x27;</span>);</span><br><span class="line"><span class="comment">// 引用 c.js</span></span><br><span class="line"><span class="keyword">const</span> contentC = <span class="built_in">require</span>(<span class="string">&#x27;./c&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(contentA); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 變數存放了回傳的整個物件</span></span><br><span class="line"><span class="built_in">console</span>.log(contentB); <span class="comment">// &#123;...&#125;</span></span><br><span class="line"><span class="comment">// 可以使用物件方法取得裡面的值</span></span><br><span class="line"><span class="built_in">console</span>.log(contentB.title) <span class="comment">// B</span></span><br><span class="line"><span class="built_in">console</span>.log(contentB.getNum()) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(contentC); <span class="comment">// &#123;...&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(contentC.title) <span class="comment">// C</span></span><br><span class="line"><span class="built_in">console</span>.log(contentC.getNum()) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="b-js"><a href="#b-js" class="headerlink" title="b.js"></a>b.js</h3><ul>
<li>使用 module.exports 設定被引用時提供的資料<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法１－ 直接設定要輸出的資料，多個資料時通常用物件格式來存放</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;B&#x27;</span>,</span><br><span class="line">    <span class="attr">getNum</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="c-js"><a href="#c-js" class="headerlink" title="c.js"></a>c.js</h3><ul>
<li>使用 exports.屬性名稱 設定被引用時提供的資料<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法２－ 新增屬性的方式逐一增加輸出的資料</span></span><br><span class="line"><span class="built_in">exports</span>.title = <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line"><span class="built_in">exports</span>.getNum = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="💎-創建本地伺服器-－-createServer"><a href="#💎-創建本地伺服器-－-createServer" class="headerlink" title="💎 創建本地伺服器 － createServer"></a>💎 創建本地伺服器 － createServer</h2><p>學會模組引用的操作後，就可以試著撰寫第一個 js 檔案，讓 Node.js 建立一個伺服器服務：<br><code>以下開發環境都使用 VS Code</code></p>
<ol>
<li><p><strong>建立伺服器 js 檔 （檔名自定)</strong><br>下面這段程式碼是 node.js 官方範例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引用 http 模組</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"><span class="comment">// 建立一個本地伺服器，設定接收到請求後的回傳資料</span></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;<span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;text/plain&quot;</span>&#125;);</span><br><span class="line">    res.write(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    res.end();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 使用 8000 port</span></span><br><span class="line">server.listen(<span class="number">8000</span>);</span><br></pre></td></tr></table></figure></li>
<li><p><strong>啟動伺服器</strong><br>開啟終端機（熱鍵為 Ctrl + <code>`</code>），使用 Node.js 執行撰寫好的檔案，如果沒有跳出錯誤訊息就表示本地伺服器成功運行了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">** 請先將路徑切換到 js 存放的位置，檔案名稱修改為自己設定的名稱 **</span><br><span class="line">node 檔案名稱.js</span><br></pre></td></tr></table></figure></li>
<li><p><strong>關閉伺服器</strong><br>伺服器執行的狀態下，在終端機視窗內按下 <code>Ctrl+C</code> 就可以終止。</p>
</li>
<li><p><strong>連線測試</strong><br>伺服器正常運作後可以開啟瀏覽器，輸入網址 <code>http://127.0.0.1:8000</code>，沒有問題的話就會顯示 <code>Hello</code>，這段網址中的 127.0.0.1 表示這部電腦的本地位置，冒號加上數字 8000 就可以指定使用前面步驟設定的 port 來連線。</p>
</li>
<li><p><strong>修改測試</strong><br>試著修改 Content-Type 或 res.write 的內容，讓網頁顯示不一樣的資訊。<br>每次修改儲存後都需要重起 node，可以透過 npm 安裝 <code>nodemon</code> 這個套件，就能在編輯檔案後自動重新載入伺服器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">** 安裝指令（建議全域安裝）**</span><br><span class="line">npm i -g nodemon</span><br><span class="line"></span><br><span class="line">** 使用 nodemon 來執行 js 檔案 **</span><br><span class="line">nodemon app.js</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://www.npmjs.com/package/nodemon">npm - nodemon</a></p>
</blockquote>
</li>
</ol>
<h2 id="💎-程式碼說明"><a href="#💎-程式碼說明" class="headerlink" title="💎 程式碼說明"></a>💎 程式碼說明</h2><h3 id="http"><a href="#http" class="headerlink" title="http"></a>http</h3><p>程式一開始引用了 node.js 中的 <code>http</code> 模組，並使用 createServer 方法來建立伺服器，模組的其他功能可以參考官方文件。</p>
<blockquote>
<p><a href="https://nodejs.org/dist/latest-v16.x/docs/api/http.html#httpcreateserveroptions-requestlistener">官方說明文件 - http</a></p>
</blockquote>
<h3 id="監聽連線請求"><a href="#監聽連線請求" class="headerlink" title="監聽連線請求"></a>監聽連線請求</h3><p>createServer 方法裡面傳入的函式像是 addEventListener 事件偵測，但監聽的<code>行為</code>是有沒有<code>連線請求</code>傳送到這台伺服器主機，這個監聽函式也可以使用變數獨立出來，增加一點可讀性，改寫後如下方程式碼：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"><span class="comment">// 監聽連線請求的函式</span></span><br><span class="line"><span class="keyword">const</span> requestListener = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;<span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;text/plain&quot;</span>&#125;);</span><br><span class="line">    res.write(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    res.end();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 建立伺服器的參數帶入儲存函式的變數</span></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(requestListener);</span><br><span class="line">server.listen(<span class="number">8000</span>);</span><br></pre></td></tr></table></figure>

<h3 id="request"><a href="#request" class="headerlink" title="request"></a>request</h3><p>監聽函式帶有兩個參數，<code>req</code> 是 request（請求）的簡寫，當我們在瀏覽器網址列輸入網址送出連線，就會對該網址對應的伺服器主機發出請求，請求資訊會包含瀏覽器版本、需要的資源、請求的方式…等資訊，在 node.js 中可以透過 req 變數來查看詳細資訊。</p>
<ul>
<li>觀察 req 的內容：<br>修改監聽函式 &gt; 儲存檔案 &gt; 重啟伺服器 &gt; 瀏覽本地網址 &gt; 在終端機查看 req 資訊<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> requestListener = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 新增下面這段程式碼，來顯示請求的內容</span></span><br><span class="line">    <span class="built_in">console</span>.log(req);</span><br><span class="line"></span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;<span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;text/plain&quot;</span>&#125;);</span><br><span class="line">    res.write(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    res.end();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>req 的常用屬性：<ul>
<li><code>req.url</code>：取得請求的資源路徑。一個網站會有好幾個檔案，透過這個屬性就可以取得請求的路徑，如果請求的網址後面沒有任何路徑，就會得到根目錄（/)，通常會設置回應首頁頁面。</li>
<li><code>req.method</code>：取得請求的方法。一般連線請求會使用 GET 方法，但是若有夾帶其他資訊時就會使用其他方法，各種方法可以參考 MDN 的說明。<blockquote>
<p><a href="https://developer.mozilla.org/zh-TW/docs/Web/HTTP/Methods">MDN - HTTP 請求方法</a></p>
</blockquote>
</li>
<li><code>req.on(&quot;data&quot;, ...)</code>：取得請求夾帶的資料。當連線使用 POST、PATCH…等方法時通常回夾帶資料給伺服器處理，就會需要使用這個方法來接收。</li>
<li><code>req.on(&quot;end&quot;, ...)</code>：資料接收完成後執行動作。網路封包傳遞會把資料切成片段，不會每次都一次傳完，所以在 on(data) 的階段無法確認收到的資料已經完成，要用這個方法才能確保資料接收完，再執行對應的程式碼。</li>
</ul>
</li>
</ul>
<h3 id="response"><a href="#response" class="headerlink" title="response"></a>response</h3><ul>
<li><code>res</code> 是 response（回應）的簡寫，伺服器收到請求後，就會把設定好的資訊傳回用戶端，在簡易的範例中只會回應 Hello 的文字，可以撰寫程式碼結合 req.url 和 req.method 判斷來回應不同的內容。</li>
<li><code>res.writeHead(status, header)</code>：回傳的表頭資訊。就像 req 一樣，res 不會只傳送單純的資料，需要包含各種資訊，status code 是狀態碼，200 就是成功，而 header 會告訴對方提供了哪些連線方法，這也是開發實務上容易採坑的地方，詳細的資訊都可以在 MDN 的 HTTP 主題中查看。<blockquote>
<p><a href="https://developer.mozilla.org/zh-TW/docs/Web/HTTP">MDN - HTTP</a></p>
</blockquote>
</li>
<li><code>Content-Type</code>：檔案格式。瀏覽器會依據這個屬性來決定怎麼讀取接收到的資料，常見的有 JSON(application/json)、HTML(text/html)、純文字(text/plain)…等。</li>
<li><code>res.end()</code>：程式運作不像人類會自主開始或停止，所以需要執行一段程式碼明確的告知『我傳完了』，否則用瀏覽器連網頁後頁籤上方會一直出現轉圈圈的圖示（表示持續等待回應中）。</li>
</ul>
<h3 id="listen-port"><a href="#listen-port" class="headerlink" title="listen(port)"></a>listen(port)</h3><ul>
<li><code>listen(8000)</code>：使用的通訊埠。HTTP 協定預設使用 80 port，1-1023 是系統保留，所以在自訂 port 的時候通常都是 X000 起跳。<blockquote>
<p><a href="https://zh.wikipedia.org/wiki/%E9%80%9A%E8%A8%8A%E5%9F%A0">Wiki - Port</a></p>
</blockquote>
</li>
<li><code>較安全的寫法</code>：寫好的網頁服務通常會放在各種雲端代管主機上，這些服務會由系統自動分配 port，如果程式碼寫死特定的 port，就無法跟雲端環境匹配，理所當然的就連不到，這時候可以利用環境變數 process.env.PORT 來取得執行環境的 port 號，就能動態調整讓服務正常運行，改寫如下：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PORT = process.env.PORT || XXXX;</span><br><span class="line"><span class="comment">// ES6 寫法</span></span><br><span class="line"><span class="keyword">const</span> &#123; PORT = XXXX &#125; = process.env;</span><br><span class="line"></span><br><span class="line">server.listen(PORT);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="💎-探索-Req-與-Res-－-Postman"><a href="#💎-探索-Req-與-Res-－-Postman" class="headerlink" title="💎 探索 Req 與 Res － Postman"></a>💎 探索 Req 與 Res － Postman</h2><p>Postman 是一套網頁請求模擬工具，相較於用瀏覽器的 Dev 工具，Postman 專注於檢查 Request &amp; Response，也能模擬各種請求行為（GET、POST、PATCH…等），有助於 API 的測試和 debug。</p>
<h3 id="安裝-Postman"><a href="#安裝-Postman" class="headerlink" title="安裝 Postman"></a>安裝 Postman</h3><p>前往 <a href="https://www.postman.com/downloads/">Postman 官方下載</a>，完成後執行安裝會跳轉至註冊會員網站，完成註冊後就可以使用了。</p>
<h3 id="使用-Postman"><a href="#使用-Postman" class="headerlink" title="使用 Postman"></a>使用 Postman</h3><p>進入操作介面後，一些設定或導覽可以都先略過，接著照以下步驟操作：</p>
<ol>
<li>先點擊上方選單 <code>HOME</code></li>
<li>點擊左側選單 <code>Workspaces</code></li>
<li>選擇 <code>My Workspace</code></li>
<li>點擊內容區塊上方分頁的 <code>+</code></li>
<li>在網址列裡面輸入任一網址或是本地的網址（例如本篇文章練習的 <code>http://127.0.0.1:8000</code>）</li>
<li>送出後就能查看詳細資訊了</li>
</ol>
<blockquote>
<p>詳細教學也可以參考：<br><a href="https://ithelp.ithome.com.tw/articles/10201503">六角學院 － Postman 教學文章</a></p>
</blockquote>
<hr>
<h2 id="💎-補充知識"><a href="#💎-補充知識" class="headerlink" title="💎 補充知識"></a>💎 補充知識</h2><h3 id="Global-全域物件"><a href="#Global-全域物件" class="headerlink" title="Global 全域物件"></a>Global 全域物件</h3><p>每個執行中的軟體或是瀏覽器頁面就像是一個星球，每個星球就像是一個全域物件，囊括了星球上的所有東西，在網頁環境中的全域物件是 <code>window</code>，而 Node.js 中是 <code>global</code>。</p>
<p>雖然都是全域，除了名稱外也有些差異，假如在全域中引入兩個檔案（a.js 和 b.js），裡面都撰寫了 <code>var a = 1</code>，這時網頁的 <code>window.a</code> 會得到 <code>1</code> 的結果，Node.js 的 <code>global.a</code> 則是 <code>undefined</code>。</p>
<p>Node.js 中的每個模組都會是獨立的，不會互相干擾也不會變成全域變數（除非直接操作 global 物件），網頁中的 window 則可能被 var 變數影響（ES6 後建議全部改用 let 才不會污染全域）。</p>
<h3 id="檔案路徑"><a href="#檔案路徑" class="headerlink" title="檔案路徑"></a>檔案路徑</h3><p>一個專案中會有許多資料夾和檔案，要存取這些資源就需要知道檔案的路徑位置，才能順利找到檔案，Node.js 提供 <code>path</code> 模組，可以快速的分解、組合路徑。</p>
<ul>
<li>全域變數：<code>__dirname</code>、<code>__filename</code> 可以取得當前的目錄和檔案名稱。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 目錄名稱</span></span><br><span class="line"><span class="built_in">console</span>.log(__dirname);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 檔案名稱</span></span><br><span class="line"><span class="built_in">console</span>.log(__filename);</span><br></pre></td></tr></table></figure></li>
<li><code>Path</code>：Node.js 的 path 模組提供許多方法來處理路徑。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 範例路徑</span></span><br><span class="line"><span class="keyword">const</span> url = <span class="string">&#x27;/aa/bb/cc.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用 path 模組</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取得目錄</span></span><br><span class="line">path.dirname(url); <span class="comment">// /aa/bb</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取得檔名</span></span><br><span class="line">path.basename(url); <span class="comment">// cc.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取得副檔名</span></span><br><span class="line">path.extname(url); <span class="comment">// js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 拆解路徑（回傳物件格式）</span></span><br><span class="line">path.parse(url); <span class="comment">// &#123; root: &#x27;/&#x27;, dir: &#x27;/aa/bb&#x27;, base: &#x27;cc.js&#x27;, ext: &#x27;.js&#x27;, name: &#x27;cc&#x27; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 組合路徑</span></span><br><span class="line">path.join(<span class="string">&#x27;/ii&#x27;</span>, <span class="string">&#x27;jj&#x27;</span>, <span class="string">&#x27;kk.js&#x27;</span>); <span class="comment">// /ii/jj/kk.js</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://nodejs.org/api/path.html">Node.js - path</a></p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="💎-結語"><a href="#💎-結語" class="headerlink" title="💎 結語"></a>💎 結語</h2><p>本篇的筆記記錄了如何使用 Node.js 本地建立伺服器、透過 Postman 檢查 Request &amp; Response，接下來會記錄如何製作一個簡單的 todolist api。</p>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>[Node.JS] 打造 todolist api 1 - 行前準備</title>
    <url>/2022/02/24/nodejs2/</url>
    <content><![CDATA[<p><img data-src="/images/nodejs-logo.png"></p>
<span id="more"></span>
<p>上一篇文章完成了網頁伺服器服務的建置，這一次就更進一步的製作一個簡單的 todolist API，讓他有新增、修改、刪除的功能。</p>
<hr>
<h2 id="💎-流程、架構規劃"><a href="#💎-流程、架構規劃" class="headerlink" title="💎 流程、架構規劃"></a>💎 流程、架構規劃</h2><p>六角學院的課程中都會以流程圖的方式，這對於循序漸進完成程式功能會非常有幫助，在完成第一個版本後就可以嘗試重構和模組化，下面是我整理出的結構，每個人在撰寫程式碼時的構思不盡相同，可以自行規劃。</p>
<ul>
<li><code>工具</code><ul>
<li>NPM/Yarn：套件管理工具</li>
<li>UUID 套件：用來建立待辦事項的 id</li>
<li>nodemon 套件：建立可即時更新的本地伺服器</li>
<li>POSTMAN 軟體：模擬 http 請求，做功能測試</li>
<li>Git/GitHub：版本控制</li>
<li>代管平台（heroku）：api 服務上線</li>
</ul>
</li>
<li><code>server</code>：啟用 api 的主要程式碼<ul>
<li>http：使用 node.js 原生的模組</li>
<li>headers：回傳 json 格式，開放跨域（CORS），提供 route 的五種請求方法</li>
<li>port：要加入環境變數（process.env.PORT）</li>
</ul>
</li>
<li><code>route</code>：依請求決定要執行的動作<ul>
<li>OPTIONS：回應表頭就好</li>
<li>GET：回應全部待辦</li>
<li>POST：新增一筆待辦、回應全部待辦，需要檢查 body 內容</li>
<li>DELETE<ul>
<li>單筆：刪除一筆待辦、回應全部待辦，需要檢查 url 的 id</li>
<li>全部：刪除全部待辦、回應全部待辦</li>
</ul>
</li>
<li>PATCH：修改一筆待辦、回應全部待辦，需要檢查 url 的 id、body 內容</li>
</ul>
</li>
<li><code>response</code>：回傳資料優化<ul>
<li>success：回傳（無內容或待辦資料）</li>
<li>false：回傳錯誤代碼及錯誤訊息</li>
</ul>
</li>
<li><code>constants</code>：常用的常數<ul>
<li>（視實際撰寫的重複使用狀況獨立出來）</li>
</ul>
</li>
</ul>
<hr>
<h2 id="💎-建立專案環境"><a href="#💎-建立專案環境" class="headerlink" title="💎 建立專案環境"></a>💎 建立專案環境</h2><ol>
<li>建立一個新專案資料夾。</li>
<li>執行 <code>npm init</code> 指令來製作 package.json 檔案。</li>
<li>執行 <code>npm i uuid</code> 來安裝 UUID 套件（後續待辦事項的編號使用）。<blockquote>
<p><a href="https://zh.wikipedia.org/zh-tw/%E9%80%9A%E7%94%A8%E5%94%AF%E4%B8%80%E8%AF%86%E5%88%AB%E7%A0%81">Wiki - UUID</a><br><a href="https://www.npmjs.com/package/uuid">npm - uuid</a></p>
</blockquote>
</li>
<li>在專案資料夾中建立一個 server.js 檔案。</li>
<li>先參考官方範例在 server.js 內撰寫啟用伺服器的程式碼：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;<span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;text/plain&quot;</span>&#125;);</span><br><span class="line">    res.write(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    res.end();</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="number">8000</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>段落測試：</p>
<ol>
<li>執行 <code>nodemon server.js</code> 測試是否有錯誤資訊（如果環境沒有 nodemon，請執行 <code>npm i -g nodemon</code> 全域安裝）</li>
<li>開啟任一瀏覽器，連線本地網址 <code>http://127.0.0.1:8000</code>，確認是否正常顯示回傳的資料。</li>
</ol>
</blockquote>
<hr>
<h2 id="💎-伺服器設定調整"><a href="#💎-伺服器設定調整" class="headerlink" title="💎 伺服器設定調整"></a>💎 伺服器設定調整</h2><ol>
<li><strong>修改預設 header</strong></li>
</ol>
<ul>
<li>todolist api 設計成回傳 json 檔，所以要把 <code>Content-Type</code> 改成 <code>application/json</code>。</li>
<li>加入開放哪些 <code>Headers</code> 和 <code>Methods</code> 的設定。</li>
<li>加入允許所有來源的跨域連線請求（<code>CORS</code>）。<blockquote>
<p>跨域請求可以參考 <a href="https://developer.mozilla.org/zh-TW/docs/Web/HTTP/CORS">MDN - CORS</a></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// header 獨立成一個常數</span></span><br><span class="line"><span class="keyword">const</span> headers = &#123;</span><br><span class="line">    <span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>: <span class="string">&#x27;Content-Type, Authorization, Content-Length, X-Requested-With&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>: <span class="string">&#x27;*&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span>: <span class="string">&#x27;PATCH, POST, GET, OPTIONS, DELETE&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 修改成使用變數</span></span><br><span class="line">    res.writeHead(<span class="number">200</span>, headers);</span><br><span class="line">    <span class="comment">// 修改成回傳 json 格式的內容</span></span><br><span class="line">    <span class="comment">// 此處需要注意，網路封包傳送的資料只有純字串，需要先轉換</span></span><br><span class="line">    res.write(<span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">       <span class="string">&quot;test&quot;</span>: <span class="string">&quot;Hello&quot;</span></span><br><span class="line">    &#125;));</span><br><span class="line">    res.end();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li><strong>修改預設 port</strong></li>
</ol>
<ul>
<li>加入環境變數，佈署到代管服務才能正常運行。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; PORT = <span class="number">3000</span> &#125; = process.env;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">server.listen(PORT);</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>段落測試：<br>開啟任一瀏覽器，連線本地網址 <code>http://127.0.0.1:3000</code>，確認是否正常顯示回傳的資料。</p>
</blockquote>
<hr>
<h2 id="💎-結語"><a href="#💎-結語" class="headerlink" title="💎 結語"></a>💎 結語</h2><p>本篇文章已經完成基本的環境建立，並且整理出程式需要撰寫的內容，下一篇文章就可以依照這個結構逐步完成所有的功能。</p>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>[JS] 作用域（Scope）與範圍鏈（Scope Chain）</title>
    <url>/2022/01/04/JSscope/</url>
    <content><![CDATA[<p><img data-src="/images/js-scope.png"></p>
<span id="more"></span> 

<p><code>作用域(Scope)</code>是<code>變數可以被使用的區域</code>，區分作用域可以避免變數的衝突。</p>
<p>舉例來說，甲、乙班各有一位同學叫小明，分別在兩個班上點名，點到小明都不會有問題，但若是全校廣播找小明，就會出現衝突，不知道要找哪一個小明。</p>
<p>作用域也有上下（內外）層級關係，當自己的作用域不存在特定變數時，可以向上（外）層尋找。</p>
<p>換個例子，雖然自己的班上找不到校長，但可以從自己的學校找到校長。</p>
<p>接著就來看 JavaScript 如何去實現這些功能。</p>
<hr>
<h2 id="💎-作用域（Scope）"><a href="#💎-作用域（Scope）" class="headerlink" title="💎 作用域（Scope）"></a>💎 作用域（Scope）</h2><h3 id="🔸-1、全域作用域（Global-Scope）"><a href="#🔸-1、全域作用域（Global-Scope）" class="headerlink" title="🔸 1、全域作用域（Global Scope）"></a>🔸 1、全域作用域（Global Scope）</h3><p>  全域顧名思義就是全部的區域，網頁中的全域物件就是 <code>window</code>。<br>  在初學 JS 時，會先練習開啟一個空白檔案，並且撰寫變數宣告，這時的變數就屬於全域變數。</p>
<p>  不同的宣告方式產生的全域變數也有差異：</p>
<ul>
<li>var：宣告後會成為 window 物件底下的一個屬性。</li>
<li>let、const：宣告後不會放到 window 底下，而是一個區塊作用域。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">let b = 2;</span><br><span class="line">const c = 3;</span><br><span class="line"></span><br><span class="line">console.log(a); // 1</span><br><span class="line">console.log(window.a); // 1</span><br><span class="line"></span><br><span class="line">console.log(b); // 2</span><br><span class="line">console.log(window.b); // undefined</span><br><span class="line"></span><br><span class="line">console.log(c); // 3</span><br><span class="line">console.log(window.c); // undefined</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="🔸-2、函式作用域-Function-Scope"><a href="#🔸-2、函式作用域-Function-Scope" class="headerlink" title="🔸 2、函式作用域(Function Scope)"></a>🔸 2、函式作用域(Function Scope)</h3><p>  用 <code>var</code> 宣告的變數會在<code>函式 (function)</code> 內區隔，先來看看下面的範例碼：<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function f1() &#123;</span><br><span class="line">  var a = 1;</span><br><span class="line">  f2();</span><br><span class="line">&#125;</span><br><span class="line">function f2() &#123;</span><br><span class="line">  console.log(a)</span><br><span class="line">&#125;</span><br><span class="line">f1();</span><br><span class="line"></span><br><span class="line">// 執行結果：</span><br><span class="line">// Uncaught ReferenceError: a is not defined</span><br></pre></td></tr></table></figure></p>
<p>  上面的範例可以知道 f2 函式無法取得 f1 函式內宣告的變數。</p>
<p>  再來看看另一個經典題目，當 var 遇到 call stack 時出現的詭異狀況。<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (var i = 1; i &lt; 5; i++) &#123;</span><br><span class="line">  setTimeout(() =&gt; console.log(i), 500);</span><br><span class="line">&#125;</span><br><span class="line">console.log(i);</span><br><span class="line"></span><br><span class="line">// 5  </span><br><span class="line">// 5</span><br><span class="line">// 5</span><br><span class="line">// 5</span><br><span class="line">// 5</span><br></pre></td></tr></table></figure><br>  如果你覺得這個輸出結果非常奇怪，不要忘了 var 的作用域是在函式中，上面這段 for 迴圈並不是函式，所以 <code>var i</code> 是<code>宣告在全域</code>，迴圈總共執行了四次，但是每次都是覆蓋掉全域中的 i ，<code>最後只有一個全域變數 i </code>存放數值 <code>5</code>，接著 setTimeout 裡面的函式執行時因為作用域裡面沒有變數 i，向外找到全域的 i (此時迴圈已經執行完，值是5)，才會都印出一樣的結果；除此之外，印出的第一個 5 是來自程式碼最後一行全域的呼叫，也證實了這個變數存在全域。</p>
<p>  函式的範圍較大，撰寫時常使用的邏輯判斷都沒辦法區隔作用域，為了區隔作用域，衍生出閉包、立即函式等各種應用技巧，這個問題在 ES6 的版本後才獲得改善。</p>
<blockquote>
<p>延伸閱讀<br>1、<a href="https://hsiangfeng.github.io/javascript/20201118/707576253/">JavaScript 核心觀念(36)-函式以及 This 的運作-立即函式</a><br>2、<a href="https://eyesofkids.gitbooks.io/javascript-start-from-es6/content/part4/closure.html">閉包</a></p>
</blockquote>
<h3 id="🔸-3、區塊作用域-Block-Scope"><a href="#🔸-3、區塊作用域-Block-Scope" class="headerlink" title="🔸 3、區塊作用域(Block Scope)"></a>🔸 3、區塊作用域(Block Scope)</h3><p>  ES6 版本加入的 <code>let</code> 和 <code>const</code> 兩種變數宣告方式，作用域會在大括號 <code>&#123;&#125;</code> 內區隔：<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  const a = 1;</span><br><span class="line">  &#123;</span><br><span class="line">    let b = 2;</span><br><span class="line">    var c = 3;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(a); // 1</span><br><span class="line">  console.log(b); // b is not defined</span><br><span class="line">  console.log(c); // 3   </span><br><span class="line">&#125;</span><br><span class="line">console.log(a); // a is not defined</span><br><span class="line">console.log(b); // b is not defined</span><br><span class="line">console.log(c); // 3</span><br></pre></td></tr></table></figure></p>
<p>  上面的範例可以看到 <code>var</code> 無論在哪個大括號內都可以取用，但 <code>let</code> 和 <code>const</code> 無法在自己存在的大括號外被取用。</p>
<p>  常用的 <code>if-else</code>、<code>for</code>等方法都會使用大括號，相對於 <code>function</code>，可以把作用域區分的更細。</p>
<p>  前個段落 <code>setTimeout</code> 範例內的 <code>var</code> 改成 <code>let</code>：<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (let i = 1; i &lt; 5; i++) &#123;</span><br><span class="line">  setTimeout(() =&gt; console.log(i), 500);</span><br><span class="line">&#125;</span><br><span class="line">console.log(i);</span><br><span class="line">// Uncaught ReferenceError: i is not defined</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br><span class="line">// 3</span><br><span class="line">// 4</span><br></pre></td></tr></table></figure></p>
<p>  從結果可以發現，每次的 <code>let i</code> 都是獨立的作用域，所以 setTimeout 實際執行時能夠找到該次迴圈區塊內產生的變數 i，除此之外，全域環境中也不會找到在區塊作用域中的變數 i （出現未定義的錯誤）。</p>
<blockquote>
<p>參考資料<br><a href="https://ithelp.ithome.com.tw/articles/10217481">JS 原力覺醒 Day04 - Function Scope / Block Scope</a></p>
</blockquote>
<ul>
<li>直接宣告(不加前綴詞)，無論放在 <code>區塊&#123;&#125;</code> 或 <code>函式</code> 內都會成為 window 物件底下的一個屬性。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dirtyA = 11;</span><br><span class="line">console.log(window.dirtyA); // 11</span><br><span class="line"></span><br><span class="line">function dirtyVariable() &#123;</span><br><span class="line">  dirtyB = 12;</span><br><span class="line">&#125;</span><br><span class="line">dirtyVariable();</span><br><span class="line">console.log(window.dirtyB); // 12</span><br></pre></td></tr></table></figure></li>
<li>直接宣告在 <code>window</code> 底下的變數可以使用 <code>delete</code> 物件方法刪除；而使用 <code>var</code> 宣告的全域變數無法使用 <code>delete</code> 刪除(<del>介於屬性與非屬性之間</del>)。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = 1;</span><br><span class="line">delete window.x; // true</span><br><span class="line">console.log(x); // x is not defined</span><br><span class="line"></span><br><span class="line">var y = 2;</span><br><span class="line">delete window.y; // false</span><br><span class="line">console.log(y); // 2</span><br></pre></td></tr></table></figure></li>
<li>在 ES5 時可以透過<code>&#39;use strict&#39;</code>（嚴格模式）來避免這些不好的操作，ES6 以後一律使用 <code>let</code> 和 <code>const</code>。</li>
</ul>
<blockquote>
<p>延伸閱讀：<br>1、<a href="https://iter01.com/56454.html">深入JavaScript系列（一）：詞法環境</a><br>2、<a href="https://medium.com/itsems-frontend/javascript-strict-mode-d0a3aa74458b">Javascript 的嚴格模式 (Strict Mode)</a></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript - Basic</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>[Node.JS] 打造 todolist api 2 - 撰寫程式基本架構</title>
    <url>/2022/03/02/nodejs3/</url>
    <content><![CDATA[<p><img data-src="/images/nodejs-logo.png"></p>
<span id="more"></span>
<p>前一篇整理的資訊中共有 5 種請求方法和延伸的處理結果需要撰寫，在這篇文章中就要建立這些功能的結構。</p>
<hr>
<h2 id="💎-基礎-route-撰寫"><a href="#💎-基礎-route-撰寫" class="headerlink" title="💎 基礎 route 撰寫"></a>💎 基礎 route 撰寫</h2><p>前面練習的網址都是使用根目錄（/），在網址加上一個路徑名稱才能方便辨識這個 api 的用途，方法很簡單，加入一個 if…else 來判斷 <code>req.url</code> 即可。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 比對請求的網址後名的路徑是不是設定好的字串</span></span><br><span class="line">   <span class="keyword">if</span> (req.url == <span class="string">&#x27;/todo&#x27;</span>) &#123;</span><br><span class="line">      res.writeHead(<span class="number">200</span>, headers);</span><br><span class="line">      <span class="comment">// 調整回傳的內容</span></span><br><span class="line">      res.write(<span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">         <span class="string">&quot;status&quot;</span>: <span class="string">&quot;true&quot;</span></span><br><span class="line">      &#125;));</span><br><span class="line">      res.end();</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 不符合路徑就傳 404 錯誤</span></span><br><span class="line">      res.writeHead(<span class="number">404</span>, headers);</span><br><span class="line">      <span class="comment">// 調整回傳的內容</span></span><br><span class="line">      res.write(<span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">         <span class="string">&quot;status&quot;</span>: <span class="string">&quot;false&quot;</span></span><br><span class="line">      &#125;));</span><br><span class="line">      res.end();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>段落測試</strong>：使用瀏覽器連 <code>http://127.0.0.1:3000</code> 和 <code>http://127.0.0.1:3000/todo</code> 查看是否有不同結果。</p>
</blockquote>
<hr>
<h2 id="💎-建立回應函式"><a href="#💎-建立回應函式" class="headerlink" title="💎 建立回應函式"></a>💎 建立回應函式</h2><p>前一個步驟中加入了第一個判斷，就可以發現 <code>res</code> 有許多程式碼重複，後續還有各種方法的判斷，可以先把它抽出來寫成函式避免後續產生大量重複程式碼。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sendResponse = <span class="function">(<span class="params">res, statusCode, data</span>) =&gt;</span> &#123;</span><br><span class="line">   res.writeHead(statusCode, headers);</span><br><span class="line">   res.write(<span class="built_in">JSON</span>.stringify(data));</span><br><span class="line">   res.end();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (req.url == <span class="string">&#x27;/todo&#x27;</span>) &#123;</span><br><span class="line">      sendResponse(res, <span class="number">200</span>, &#123;</span><br><span class="line">         <span class="string">&quot;status&quot;</span>: <span class="string">&quot;true&quot;</span></span><br><span class="line">      &#125;);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      sendResponse(res, <span class="number">404</span>, &#123;</span><br><span class="line">         <span class="string">&quot;status&quot;</span>: <span class="string">&quot;false&quot;</span></span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>段落測試</strong>：使用瀏覽器連 <code>http://127.0.0.1:3000</code> 和 <code>http://127.0.0.1:3000/todo</code> 查看是否運作正常。</p>
</blockquote>
<hr>
<h2 id="💎-判斷各種連線方法"><a href="#💎-判斷各種連線方法" class="headerlink" title="💎 判斷各種連線方法"></a>💎 判斷各種連線方法</h2><p>用來判別各種狀況的基本寫法是 <code>if...else</code> 和 <code>switch...case</code>，這部份的判斷方式因人而異，可以自行思考設計，以下個人的寫法僅供參考，也歡迎大家提出改善建議。</p>
<h3 id="🚩-OPTIONS"><a href="#🚩-OPTIONS" class="headerlink" title="🚩 OPTIONS"></a>🚩 OPTIONS</h3><p>本次練習中提供了 5 種連線方法，其中 <code>OPTIONS</code> 較為特別，這個方法像是打招呼一樣，只需要回傳 <code>狀態碼</code> 和 <code>headers</code> 即可（就像互相問候，不用說具體的內容），可以放在判斷條件的第一條處理。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sendResponse = <span class="function">(<span class="params">statusCode, data</span>) =&gt;</span> &#123;</span><br><span class="line">   res.writeHead(statusCode, headers);</span><br><span class="line">   <span class="comment">// 增加判斷，有資料時才回傳</span></span><br><span class="line">   <span class="keyword">if</span> (data) &#123;</span><br><span class="line">      res.write(<span class="built_in">JSON</span>.stringify(data));</span><br><span class="line">   &#125;</span><br><span class="line">   res.end();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 修改成使用變數</span></span><br><span class="line">   <span class="keyword">if</span> (req.method == <span class="string">&#x27;OPTIONS&#x27;</span>) &#123;</span><br><span class="line">      sendResponse(res, <span class="number">200</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.url == <span class="string">&#x27;/todo&#x27;</span>) &#123;</span><br><span class="line">      sendResponse(res, <span class="number">200</span>, &#123;</span><br><span class="line">         <span class="string">&quot;status&quot;</span>: <span class="string">&quot;true&quot;</span></span><br><span class="line">      &#125;);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      sendResponse(res, <span class="number">404</span>, &#123;</span><br><span class="line">         <span class="string">&quot;status&quot;</span>: <span class="string">&quot;false&quot;</span></span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>💡💡 重要 💡💡</code><br><strong>段落測試</strong>：此處開始（包含後續的步驟）需要使用 POSTMAN 軟體來模擬各種連線方法測試。<br><strong>測試內容</strong>：方法 <code>OPTIONS</code>、網址 <code>http://127.0.0.1:3000(後方可加任意字串來測試不同的回應)</code><br><strong>參考資料</strong>：<a href="https://israynotarray.com/other/20211207/427026/">是 Ray 不是 Array - POSTMAN 教學</a></p>
</blockquote>
<h3 id="🚩-其他方法"><a href="#🚩-其他方法" class="headerlink" title="🚩 其他方法"></a>🚩 其他方法</h3><p>先把其他會用到的方法加到程式碼中，再針對每個項目補完功能，此處我使用的是 switch…case，也可以 elseif 到底。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (req.method == <span class="string">&#x27;OPTIONS&#x27;</span>) &#123;</span><br><span class="line">      sendResponse(res, <span class="number">200</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.url == <span class="string">&#x27;/todo&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// 新增各種方法的判斷，並稍微調整回傳內容來測試</span></span><br><span class="line">      <span class="keyword">switch</span> (req.method) &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">&#x27;GET&#x27;</span>:</span><br><span class="line">            sendResponse(res, <span class="number">200</span>, &#123;</span><br><span class="line">               <span class="string">&quot;status&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">               <span class="string">&quot;method&quot;</span>: <span class="string">&quot;GET&quot;</span></span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">            sendResponse(res, <span class="number">200</span>, &#123;</span><br><span class="line">               <span class="string">&quot;status&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">               <span class="string">&quot;method&quot;</span>: <span class="string">&quot;POST&quot;</span></span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">&#x27;PATCH&#x27;</span>:</span><br><span class="line">            sendResponse(res, <span class="number">200</span>, &#123;</span><br><span class="line">               <span class="string">&quot;status&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">               <span class="string">&quot;method&quot;</span>: <span class="string">&quot;PATCH&quot;</span></span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">&#x27;DELETE&#x27;</span>:</span><br><span class="line">            sendResponse(res, <span class="number">200</span>, &#123;</span><br><span class="line">               <span class="string">&quot;status&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">               <span class="string">&quot;method&quot;</span>: <span class="string">&quot;DELETE&quot;</span></span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="comment">// 不符合這些請求方式就回傳錯誤碼</span></span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">            sendResponse(res, <span class="number">405</span>, &#123;</span><br><span class="line">               <span class="string">&quot;status&quot;</span>: <span class="string">&quot;false&quot;</span></span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      sendResponse(res, <span class="number">404</span>, &#123;</span><br><span class="line">         <span class="string">&quot;status&quot;</span>: <span class="string">&quot;false&quot;</span></span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>段落測試</strong><br><strong>測試網址</strong>：<code>http://127.0.0.1:3000/todo</code><br><strong>測試方法</strong>：GET、POST、PATCH、DELETE（使用 POSTMAN）</p>
</blockquote>
<h3 id="🚩-修改、刪除指定資料"><a href="#🚩-修改、刪除指定資料" class="headerlink" title="🚩 修改、刪除指定資料"></a>🚩 修改、刪除指定資料</h3><p>指定資料的修改（PATCH）、刪除（DELETE）在設計上會使用 <code>http://網域/路徑/參數 (例如：http://127.0.0.1:3000/todo/abcd12345)</code> 這個格式的網址，在參數內帶入指定資料的 ID，這時候就無法使用 <code>req.url == &#39;/todo&#39;</code> 來比對（結果會是 false），需要分開判斷。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (req.method == <span class="string">&#x27;OPTIONS&#x27;</span>) &#123;</span><br><span class="line">      sendResponse(res, <span class="number">200</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.url == <span class="string">&#x27;/todo&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (req.method) &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">&#x27;GET&#x27;</span>:</span><br><span class="line">            sendResponse(res, <span class="number">200</span>, &#123;</span><br><span class="line">               <span class="string">&quot;status&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">               <span class="string">&quot;method&quot;</span>: <span class="string">&quot;GET&quot;</span></span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">            sendResponse(res, <span class="number">200</span>, &#123;</span><br><span class="line">               <span class="string">&quot;status&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">               <span class="string">&quot;method&quot;</span>: <span class="string">&quot;POST&quot;</span></span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="comment">/* PATCH 方法調整到下一個判斷 */</span></span><br><span class="line">         <span class="comment">// case &#x27;PATCH&#x27;:</span></span><br><span class="line">         <span class="comment">//    sendResponse(res, 200, &#123;</span></span><br><span class="line">         <span class="comment">//       &quot;status&quot;: &quot;true&quot;,</span></span><br><span class="line">         <span class="comment">//       &quot;method&quot;: &quot;PATCH&quot;</span></span><br><span class="line">         <span class="comment">//    &#125;);</span></span><br><span class="line">         <span class="comment">//    break;</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">// DELETE 方法有兩種操作（單筆或全部），這邊保留的用來刪除全部（不需要ID）</span></span><br><span class="line">         <span class="keyword">case</span> <span class="string">&#x27;DELETE&#x27;</span>:</span><br><span class="line">            sendResponse(res, <span class="number">200</span>, &#123;</span><br><span class="line">               <span class="string">&quot;status&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">               <span class="string">&quot;method&quot;</span>: <span class="string">&quot;DELETE&quot;</span></span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="comment">// 不符合這些請求方式就回傳錯誤碼</span></span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">            sendResponse(res, <span class="number">405</span>, &#123;</span><br><span class="line">               <span class="string">&quot;status&quot;</span>: <span class="string">&quot;false&quot;</span></span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="comment">// 使用 startsWith 方法來比對路徑開頭</span></span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.url.startsWith(<span class="string">&#x27;/todo/&#x27;</span>)) &#123;</span><br><span class="line">      <span class="comment">// 修改單筆資料</span></span><br><span class="line">      <span class="keyword">if</span> (req.method == <span class="string">&#x27;PATCH&#x27;</span>) &#123;</span><br><span class="line">         sendResponse(res, <span class="number">200</span>, &#123;</span><br><span class="line">            <span class="string">&quot;status&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">            <span class="string">&quot;method&quot;</span>: <span class="string">&quot;PATCH + id&quot;</span></span><br><span class="line">         &#125;);</span><br><span class="line">      <span class="comment">// 刪除單筆資料</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.method == <span class="string">&#x27;DELETE&#x27;</span>) &#123;</span><br><span class="line">         sendResponse(res, <span class="number">200</span>, &#123;</span><br><span class="line">            <span class="string">&quot;status&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">            <span class="string">&quot;method&quot;</span>: <span class="string">&quot;DELETE + id&quot;</span></span><br><span class="line">         &#125;);</span><br><span class="line">      <span class="comment">// 不符合上述兩種方法時回應錯誤</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         sendResponse(res, <span class="number">405</span>, &#123;</span><br><span class="line">            <span class="string">&quot;status&quot;</span>: <span class="string">&quot;false&quot;</span></span><br><span class="line">         &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      sendResponse(res, <span class="number">404</span>, &#123;</span><br><span class="line">         <span class="string">&quot;status&quot;</span>: <span class="string">&quot;false&quot;</span></span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>段落測試</strong><br><strong>測試網址</strong>：<code>http://127.0.0.1:3000/todo/(任一字串)</code><br><strong>測試方法</strong>：PATCH、DELETE（使用 POSTMAN）</p>
</blockquote>
<hr>
<h2 id="💎-結語"><a href="#💎-結語" class="headerlink" title="💎 結語"></a>💎 結語</h2><p>本篇的筆記已經完成所有方法的架構，下一篇完結篇就會補上所有的功能。</p>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>[JS] if 和 switch 的使用時機</title>
    <url>/2021/11/18/JSswitch/</url>
    <content><![CDATA[<p><img data-src="/images/js-if.png"></p>
<span id="more"></span> 
<p>if 和 switch 時常會被拿來比較，無論是可讀性、嚴謹性、效能…等，在比較前先了解基本的撰寫結構。</p>
<hr>
<h2 id="💎-if…else-的寫法"><a href="#💎-if…else-的寫法" class="headerlink" title="💎 if…else 的寫法"></a>💎 if…else 的寫法</h2><ul>
<li><p>基本結構，至少要有一個條件判斷：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (true) &#123;</span><br><span class="line">    console.log(&quot;Hello, if!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>非 A 及 B（二選一）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let agreement = true;</span><br><span class="line">if (agreement) &#123;</span><br><span class="line">    console.log(&quot;同意&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    console.log(&quot;不同意&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>多個判斷：</p>
<ul>
<li>JavaScript 中的 else if 需要空白隔開（其他程式語言有些是連在一起的elseif）。</li>
<li>else 不是必要項目，會在不符合所有的 if 或 else if 時執行。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let x = 100;</span><br><span class="line">if (x &gt;= 10000) &#123;</span><br><span class="line">    /* do something */</span><br><span class="line">&#125; else if (money &gt;= 1000) &#123;</span><br><span class="line">    /* do something */</span><br><span class="line">&#125; else if (money &gt;= 100) &#123;</span><br><span class="line">    /* do something */</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    /* do something */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>巢狀判斷</p>
<ul>
<li>可以在 if-else 內再加入 if-else 逐步判斷。</li>
<li>層級過多時不易閱讀。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (temperature &gt; 28) &#123;</span><br><span class="line">    console.log(&quot;stay home&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    if (humidity &gt; 50) &#123;</span><br><span class="line">        console.log(&quot;stay home&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (traffic === &#x27;nice&#x27;) &#123;</span><br><span class="line">            console.log(&quot;stay home&quot;);</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h2 id="💎-switch-的寫法"><a href="#💎-switch-的寫法" class="headerlink" title="💎 switch 的寫法"></a>💎 switch 的寫法</h2><ul>
<li><p>基本結構：</p>
<ul>
<li>條件數量可以自行增減。</li>
<li>每個條件結束後需加上 break 終止執行。</li>
<li>default 不一定要放在最後，可以插在中間或最前面，不影響程式執行。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">switch (要判斷的資料) &#123;</span><br><span class="line">  case 條件1:</span><br><span class="line">    /* do something */</span><br><span class="line">    break;</span><br><span class="line">  case 條件2:</span><br><span class="line">    /* do something */</span><br><span class="line">    break;</span><br><span class="line">  ...</span><br><span class="line">  case 條件n:</span><br><span class="line">    /* do something */</span><br><span class="line">    break;</span><br><span class="line">  default:</span><br><span class="line">    /* 上述條件都不符合時執行 */</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>switch 中的 break 不能遺漏</code><br>如果忘記在 case 結束時撰寫 break 來中斷，無論接下來的條件是否符合，都會一直執行到出現 break 或 switch 結尾為止，這會是相當嚴重的錯誤。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var x = 0;</span><br><span class="line">switch (x) &#123;</span><br><span class="line">  case 0:</span><br><span class="line">    console.log(0); // 此處漏掉 break</span><br><span class="line">  case 1: </span><br><span class="line">    console.log(1); // 繼續執行，此處也漏掉 break</span><br><span class="line">  case 2:</span><br><span class="line">    console.log(2); // 繼續執行</span><br><span class="line">    break; // 終止執行</span><br><span class="line">  case 3:</span><br><span class="line">    console.log(3); </span><br><span class="line">    break;</span><br><span class="line">  default:</span><br><span class="line">    console.log(&#x27;default&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---執行結果---</span><br><span class="line">console:</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="💎-if-和-switch-簡單比較"><a href="#💎-if-和-switch-簡單比較" class="headerlink" title="💎 if 和 switch 簡單比較"></a>💎 if 和 switch 簡單比較</h2><ul>
<li>爬了各種文章後，大致歸納出以下幾點比較：<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">if</th>
<th align="center">switch</th>
</tr>
</thead>
<tbody><tr>
<td align="center">易讀性</td>
<td align="center">判斷條件少時較佳</td>
<td align="center">判斷條件多時佳</td>
</tr>
<tr>
<td align="center">效能</td>
<td align="center">專案複雜時較差</td>
<td align="center">專案複雜時較佳</td>
</tr>
<tr>
<td align="center">判斷方式</td>
<td align="center">撰寫者決定嚴謹度</td>
<td align="center">嚴格比較（===）</td>
</tr>
<tr>
<td align="center">使用時機</td>
<td align="center">適合在少量決策、連續區間</td>
<td align="center">適合大量決策、獨立區間</td>
</tr>
</tbody></table>
</li>
</ul>
<hr>
<h2 id="💎-延伸技巧"><a href="#💎-延伸技巧" class="headerlink" title="💎 延伸技巧"></a>💎 延伸技巧</h2><h3 id="🔸-條件（三元）運算子"><a href="#🔸-條件（三元）運算子" class="headerlink" title="🔸 條件（三元）運算子"></a>🔸 條件（三元）運算子</h3><ul>
<li>條件運算子像是 if…else 的簡化版，寫法如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 條件 ? 結果為truthy時執行 : 結果為falsy時執行 */</span><br><span class="line"></span><br><span class="line">let a = 1;</span><br><span class="line">a &gt; 1 ? console.log(&#x27;yes&#x27;) : console.log(&#x27;no&#x27;);</span><br></pre></td></tr></table></figure></li>
<li>條件運算子也可以做到 else if，但是可讀性不太好，寫起來也容易漏掉符號：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let a = 1;</span><br><span class="line">a &gt; 3 ? console.log(`$&#123;a&#125; &gt; 3`)</span><br><span class="line">: a &gt; 2 ? console.log(`$&#123;a&#125; &gt; 2`)</span><br><span class="line">: a &gt; 1 ? console.log(`$&#123;a&#125; &gt; 1`)</span><br><span class="line">: console.log(`$&#123;a&#125; &lt;= 1`);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="🔸-Early-Return"><a href="#🔸-Early-Return" class="headerlink" title="🔸 Early Return"></a>🔸 Early Return</h3><ul>
<li><p>當條件判斷多的時候，很容易寫出好幾層的巢狀判斷，不但不好閱讀，也降低執行效能。<br>這時可以挑出一些必要的條件，不符合就直接終止（return），可以減少巢狀、提高可讀性，也能提昇程式執行效率。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function doSomething(a, b)&#123;</span><br><span class="line">  // 不是數字就結束</span><br><span class="line">  if(isNaN(parseFloat(num1))||isNaN(parseFloat(num2))) return;</span><br><span class="line">  // 主要判斷邏輯</span><br><span class="line">  if(...)&#123;</span><br><span class="line">    if(...)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>參考資料：<br><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Statements/if...else">MDN-if…else</a><br><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Statements/switch">MDN-switch</a><br><a href="https://hsiangfeng.github.io/javascript/20200117/3217748743/">Ray-JavaScript 的 if 跟 switch 效能</a><br><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Operators/Conditional_Operator">MDN-條件運算子</a><br><a href="https://askie.today/javascript-good-condition-statement/">askie-五個小技巧讓你寫出更好的 JavaScript 條件語句</a></p>
</blockquote>
</li>
</ul>
<hr>
<p>以上是我對 if 和 switch 的一點認知，如有錯誤或是需要補充的知識點，也歡迎大家不吝指教，謝謝！</p>
]]></content>
      <categories>
        <category>JavaScript - Basic</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>[Node.JS] 打造 todolist api 4 - 部署上線</title>
    <url>/2022/03/04/nodejs5/</url>
    <content><![CDATA[<p><img data-src="/images/nodejs-logo.png"></p>
<span id="more"></span> 
<p>寫了好幾篇，功能終於做完了，這篇來記錄如何把寫好的功能放到雲端上，讓這個 API 不再只是本地戳，真正的上線運行。</p>
<hr>
<h2 id="💎-需要工具"><a href="#💎-需要工具" class="headerlink" title="💎 需要工具"></a>💎 需要工具</h2><ul>
<li>雲端平台：Heroku</li>
<li>部署工具：Git</li>
</ul>
<hr>
<h2 id="💎-Git"><a href="#💎-Git" class="headerlink" title="💎 Git"></a>💎 Git</h2><p>要把做好的專案部署到 Heroku 上，會需要用到 Git 來發佈，加入 git 版控只需要在 todolist 練習的資料夾下一個初始化的指令即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果還沒有 Git，可以到 <a href="https://git-scm.com/">Git 官方網站</a> 下載</p>
</blockquote>
<p>完成初始化後可以建立在專案資料夾建立 .gitignore 檔案（例外清單），並打開編輯，在裡面加入 node_modules，當上傳專案到 heroku 平台上時，平台會自動根據 package.json 裡面的 dependancies 來安裝套件，所以可以把模組的實體檔案加到例外，不用一起部署上線。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node_modules</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="💎-環境設定"><a href="#💎-環境設定" class="headerlink" title="💎 環境設定"></a>💎 環境設定</h2><p>在部署上線前，需要（）做一些調整，才能順利運行：</p>
<ul>
<li>package.json<ul>
<li>“scripts” 內加入啟動伺服器的指令<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;start&quot;: &quot;node server.js&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
<li>新增 “engines” 屬性來指定運行的 node.js 版本<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;engines&quot;: &#123;</span><br><span class="line">    &quot;node&quot;: &quot;16.x&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>確認 server.js 裡面的 PORT 設定有沒有使用 process.env.PORT 來獲取環境變數，沒有的話伺服器會無法連線。</li>
<li>完成環境設定後記得用 Git 提交版本<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &#x27;todolist v1(名稱自訂)&#x27;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="💎-Heroku-申請與安裝"><a href="#💎-Heroku-申請與安裝" class="headerlink" title="💎 Heroku 申請與安裝"></a>💎 Heroku 申請與安裝</h2><ol>
<li>如果還沒有 Heroku 帳號，可以先到 <a href="https://www.heroku.com/">Heroku 官方網站</a> 註冊。</li>
<li>註冊完成後回到開發環境（VS Code）。</li>
<li>安裝 Heroku CLI（建議使用全域安裝）。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i -g heroku</span><br></pre></td></tr></table></figure>
<code>安裝完會出現不少衝突警告，但可以先無視</code></li>
<li>測試一下 Heroku CLI 能不能正常使用（下面是檢查版本資訊的指令）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">heroku --version</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="💎-Heroku-上線！"><a href="#💎-Heroku-上線！" class="headerlink" title="💎 Heroku 上線！"></a>💎 Heroku 上線！</h2><ol>
<li><p>先回到 VScode，並且進入 todolist 專案資料夾，在終端機執行登入 heroku 的指令，送出後按任意按鍵會跳轉到登入的網頁，接著再網頁登入成功後，終端機也會跳出登入成功訊息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">heroku login</span><br></pre></td></tr></table></figure></li>
<li><p>執行建立伺服器指令，執行後系統會產生一組專案名稱，可以複製名稱最後的幾個數字，在網頁介面的搜尋列找到這個專案。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">heroku create</span><br></pre></td></tr></table></figure>
<blockquote>
<p>建立伺服器成功後，同時也會把這個遠端專案加到本地中，可以用指令 <code>git remote</code> 檢查，會發現多了一組 <code>heroku</code>。</p>
</blockquote>
</li>
<li><p>發佈專案！運用 git push 把心血結晶上傳吧！<br>（指令最後的本地分支名稱視版本有所不同，需要自行調整）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push heroku main/master</span><br></pre></td></tr></table></figure></li>
<li><p>如果上傳部署成功，就可以執行指令來啟用伺服器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">heroku open</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="💎-線上功能測試"><a href="#💎-線上功能測試" class="headerlink" title="💎 線上功能測試"></a>💎 線上功能測試</h2><p>把所有的可能性從頭到尾測一遍。<br><strong>測試網址</strong>：</p>
<ul>
<li><code>http://(heroku給的網域名稱)/todo</code></li>
<li><code>http://(heroku給的網域名稱)/todo/</code></li>
<li><code>http://(heroku給的網域名稱)/todo/(任一筆id)</code></li>
<li><code>http://(heroku給的網域名稱)/(亂打)</code></li>
</ul>
<p><strong>測試方法</strong>：</p>
<ul>
<li>OPTIONS</li>
<li>GET</li>
<li>POST</li>
<li>PATCH</li>
<li>DELETE</li>
<li>其他 POSTMAN 上有的方法都可以試試</li>
</ul>
<p><strong>測試資料</strong>： </p>
<ul>
<li><code>&#123;&quot;title&quot;: &quot;隨意&quot;&#125;</code></li>
<li>各種奇怪資料</li>
</ul>
<hr>
<h2 id="💎-結語"><a href="#💎-結語" class="headerlink" title="💎 結語"></a>💎 結語</h2><p>這系列文章是參考六角學院的課程撰寫的，這些基本的功能照著課程走，花了很大篇幅和時間才寫出來，寫了才發現每個環節都有詳細的說明，儘管實作的內容還只是皮毛，但是能穩紮穩打的進步，真的比到論壇複製貼上慢慢摸索前進還要有成就感。</p>
<blockquote>
<p>我的 <a href="https://github.com/stark920/todolistDemo">GitHub - todolistDemo</a> 也存放了照著這些文章寫出來的成果，如果操作有問題也可以參考上面的檔案。</p>
</blockquote>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>[Node.JS] 打造 todolist api 3 - 完成所有功能</title>
    <url>/2022/03/04/nodejs4/</url>
    <content><![CDATA[<p><img data-src="/images/nodejs-logo.png"></p>
<span id="more"></span> 
<p>前一篇已經把整個架構寫好，這次就直接照著架構補完所有功能！</p>
<hr>
<h2 id="💎-GET-取得待辦清單"><a href="#💎-GET-取得待辦清單" class="headerlink" title="💎 GET - 取得待辦清單"></a>💎 GET - 取得待辦清單</h2><p>在前端撰寫 todolist 的練習時，都會使用一個陣列變數來存放待辦資料，現在搭配後端，就由 Node.js 負責管理這個陣列變數。<br>GET 方法非常簡單，只要回傳這個存放待辦事項的變數即可。<br><code>目前的練習中，變數只是存放在伺服器執行環境的記憶體中，並沒有存成實體檔案（資料庫），當伺服器重啟時記憶體釋放，資料就會遺失</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 宣告用來存放待辦事項的陣列</span></span><br><span class="line"><span class="keyword">const</span> todos = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123; </span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;GET&#x27;</span>:</span><br><span class="line">        sendResponse(res, <span class="number">200</span>, &#123;</span><br><span class="line">            <span class="string">&quot;status&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">            <span class="comment">// 改成回傳待辦事項的變數 </span></span><br><span class="line">            <span class="string">&quot;data&quot;</span>: todos</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>段落測試</strong><br><strong>測試網址</strong>：<code>http://127.0.0.1:3000/todo</code><br><strong>測試方法</strong>：GET（只要順利回傳空陣列就成功了）</p>
</blockquote>
<hr>
<h2 id="💎-POST-新增一筆待辦"><a href="#💎-POST-新增一筆待辦" class="headerlink" title="💎 POST - 新增一筆待辦"></a>💎 POST - 新增一筆待辦</h2><p>在撰寫這段時，需要先規劃好一筆待辦事項會有哪些欄位，本次練習只放『標題』、『ID』就好，格式設計如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;title&quot;</span>: <span class="string">&quot;吃飯&quot;</span>,</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;xxxxxxxxxxx&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>標題</strong><ul>
<li>需要接收 <code>req</code> 傳來的資料，使用 node.js 的 req.on 方法來監聽資料接收的事件。</li>
<li>封包大小有限，當傳送的資料大時就會被切成好幾個片段，接收端需要在收到所有的片段之後組合起來，才會取得完整可用的資料。</li>
<li>要確保資料已經確實接收，分別使用 <code>req.on(&#39;data&#39;, function)</code> 來處理資料傳送中的行為，<code>req.on(&#39;end&#39;, function)</code> 處理接收完的行為。</li>
<li>資料檢查：格式設計了使用 title 存放標題，如果傳入的資料不是 JSON 格式，或是沒有這個屬性都可能讓伺服器掛掉，所以需要先檢查是不是符合規範。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="comment">// 建立一個變數來接收傳入的資料</span></span><br><span class="line">    <span class="keyword">let</span> body = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="comment">// 當有資料傳入就加到 body 變數裡面</span></span><br><span class="line">    req.on(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="params">chunk</span> =&gt;</span> &#123;</span><br><span class="line">        body += chunk;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        <span class="comment">// 資料接收完才會執行</span></span><br><span class="line">        req.on(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 取出 body 裡面的 title，如果沒有會得到 undefined</span></span><br><span class="line">            <span class="keyword">let</span> title = <span class="built_in">JSON</span>.parse(body)?.title;</span><br><span class="line">            <span class="comment">// 有 title 就加到陣列裡面，並且回傳全部待辦</span></span><br><span class="line">            <span class="keyword">if</span> (title) &#123;</span><br><span class="line">                todos.push(&#123;</span><br><span class="line">                    title</span><br><span class="line">                &#125;);</span><br><span class="line">                sendResponse(res, <span class="number">200</span>, &#123;</span><br><span class="line">                    <span class="string">&quot;status&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;data&quot;</span>: todos</span><br><span class="line">                &#125;)</span><br><span class="line">            <span class="comment">// 沒 title 回傳錯誤</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sendResponse(res, <span class="number">400</span>, &#123;</span><br><span class="line">                    <span class="string">&quot;status&quot;</span>: <span class="string">&quot;false&quot;</span></span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>ID</strong><ul>
<li>ID 需要是不會重複的數值，使用 UUID 套件來完成。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入 uuid 模組，請確認有無安裝該套件</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">v4</span>: uuidv4 &#125; = <span class="built_in">require</span>(<span class="string">&#x27;uuid&#x27;</span>);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123; </span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        req.on(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> (title) &#123;</span><br><span class="line">                todos.push(&#123;</span><br><span class="line">                    title,</span><br><span class="line">                    <span class="comment">// 加入 ID</span></span><br><span class="line">                    <span class="attr">id</span>: uuidv4()</span><br><span class="line">                &#125;);</span><br><span class="line">            ...</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>防錯</strong><ul>
<li>雖然前面已經針對 title 檢查，還是需要甚防有心人傳入奇怪的資料，可以使用 try…catch 來捕捉問題。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">    req.on(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> title = <span class="built_in">JSON</span>.parse(body)?.title;</span><br><span class="line">            <span class="keyword">if</span> (title) &#123;</span><br><span class="line">                todos.push(&#123;</span><br><span class="line">                    title,</span><br><span class="line">                    <span class="string">&#x27;id&#x27;</span>: uuidv4()</span><br><span class="line">                &#125;)</span><br><span class="line">                sendResponse(res, <span class="number">200</span>, &#123;</span><br><span class="line">                    <span class="string">&quot;status&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;data&quot;</span>: todos</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sendResponse(res, <span class="number">400</span>, &#123;</span><br><span class="line">                    <span class="string">&quot;status&quot;</span>: <span class="string">&quot;false&quot;</span></span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            sendResponse(res, <span class="number">400</span>, &#123;</span><br><span class="line">                <span class="string">&quot;status&quot;</span>: <span class="string">&quot;false&quot;</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>段落測試</strong>（需要使用 POSTMAN）<br><strong>測試網址</strong>：<code>http://127.0.0.1:3000/todo</code><br><strong>測試方法</strong>：POST（需要在 body 加入 JSON 資料）<br><strong>測試資料</strong>： <code>&#123;&quot;title&quot;: &quot;test&quot;&#125;</code> or 各種奇怪資料</p>
</blockquote>
<hr>
<h2 id="💎-DELETE-刪除全部待辦"><a href="#💎-DELETE-刪除全部待辦" class="headerlink" title="💎 DELETE - 刪除全部待辦"></a>💎 DELETE - 刪除全部待辦</h2><p>刪除全部非常簡單，只要把陣列清空就好，要注意的是陣列和物件都盡量避免賦值（=）操作，以方法操作為主，所以我在一開始宣告 todos 時是使用 const ，這樣就無法使用 <code>todos = []</code>，而是使用陣列方法 <code>todos.length = 0</code> 來清空陣列。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;DELETE&#x27;</span>:</span><br><span class="line">    <span class="comment">// 陣列長度為 0 = 沒資料</span></span><br><span class="line">    todos.length = <span class="number">0</span>;</span><br><span class="line">    sendResponse(res, <span class="number">200</span>, &#123;</span><br><span class="line">        <span class="string">&quot;status&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">        <span class="string">&quot;data&quot;</span>: todos</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>段落測試</strong>（需要使用 POSTMAN）<br><strong>測試網址</strong>：<code>http://127.0.0.1:3000/todo</code><br><strong>測試方法</strong>：DELETE</p>
</blockquote>
<hr>
<h2 id="💎-DELETE-刪除一筆待辦"><a href="#💎-DELETE-刪除一筆待辦" class="headerlink" title="💎 DELETE - 刪除一筆待辦"></a>💎 DELETE - 刪除一筆待辦</h2><ul>
<li><strong>取得傳入的 ID</strong>：<br>前一篇文章有提到，把待辦的 ID 塞到網址後面的格式會是 <code>http://網域/路徑/參數</code>，使用 <code>req.url</code> 會得到 <code>/路徑/參數</code>，接著用字串方法 <code>split(&#39;/&#39;)</code> 切割成陣列，再使用 <code>pop()</code> 取得最後一筆資料就是參數了。</li>
<li><strong>找出 ID 相符的資料</strong>：<br>使用 <code>findIndex</code> 方法來找出待辦事項的陣列中有沒有 ID 相符的資料，符合時會取得該筆資料的 <code>index</code>，沒有符合資料時會得到 <code>-1</code>。</li>
<li><strong>刪除陣列資料</strong><br>成功取得指定資料在陣列中的 index 後就可以使用 <code>splice(index, 1)</code> 的方法刪除 1 筆資料，第一個參數是起始的索引位置，第二個參數是要往後刪除幾筆資料。</li>
<li><strong>架構調整</strong><br>調整前：<code>確認網址開頭</code>(/todo/) &gt; <code>確認請求方法</code>（PATCH or DELETE）<br>調整後：<code>確認網址開頭</code>(/todo/) &gt; <code>確認 ID 是否存在</code> &gt; <code>確認請求方法</code>（PATCH or DELETE）<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.url.startsWith(<span class="string">&#x27;/todo/&#x27;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 取得請求網址最後一段帶的 ID</span></span><br><span class="line">        <span class="keyword">let</span> id = req.url.split(<span class="string">&#x27;/&#x27;</span>).pop();</span><br><span class="line">        <span class="comment">// 找出 todos 裡面有沒有符合 id 的項目</span></span><br><span class="line">        <span class="keyword">let</span> index = todos.findIndex(<span class="function"><span class="params">el</span> =&gt;</span> el.id == id);</span><br><span class="line">        <span class="comment">// 先判斷有沒有指定 ID</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (req.method == <span class="string">&#x27;PATCH&#x27;</span>) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.method == <span class="string">&#x27;DELETE&#x27;</span>) &#123;</span><br><span class="line">                todos.splice(index, <span class="number">1</span>);</span><br><span class="line">                sendResponse(res, <span class="number">200</span>, &#123;</span><br><span class="line">                    <span class="string">&quot;status&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;data&quot;</span>: todos</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sendResponse(res, <span class="number">405</span>, &#123;</span><br><span class="line">                    <span class="string">&quot;status&quot;</span>: <span class="string">&quot;false&quot;</span></span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sendResponse(res, <span class="number">405</span>, &#123;</span><br><span class="line">                <span class="string">&quot;status&quot;</span>: <span class="string">&quot;false&quot;</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p><strong>段落測試</strong>（需要使用 POSTMAN）<br><strong>測試網址</strong>：<code>http://127.0.0.1:3000/todo/(任一筆id)</code><br>（先用 POST 方法建立幾筆資料，才有 ID 可用）<br><strong>測試方法</strong>：DELETE</p>
</blockquote>
<hr>
<h2 id="💎-PATCH-編輯一筆待辦"><a href="#💎-PATCH-編輯一筆待辦" class="headerlink" title="💎 PATCH - 編輯一筆待辦"></a>💎 PATCH - 編輯一筆待辦</h2><p>終於到了最後一步，也是集大成的一步，『路徑 ID』和『接收資料』都會用上，可以參考 <code>POST</code> 和 <code>DELETE(單筆)</code> 的寫法自行整合在一起，流程大致如下：</p>
<ol>
<li>檢查連結（url）</li>
<li>檢查ID (url)</li>
<li>檢查方法 (method)</li>
<li>確認接收完資料 (req.on(end))</li>
<li>偵錯 （try…catch）</li>
<li>檢查接收的待辦資料（title）</li>
<li>更新待辦資料（title）</li>
<li>回傳待辦資料<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (req.method == <span class="string">&#x27;PATCH&#x27;</span>) &#123;</span><br><span class="line">        req.on(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> title = <span class="built_in">JSON</span>.parse(body)?.title;</span><br><span class="line">                <span class="keyword">if</span> (title) &#123;</span><br><span class="line">                    <span class="comment">// 修改對應 ID 的 title</span></span><br><span class="line">                    todos[index].title = title;</span><br><span class="line">                    sendResponse(res, <span class="number">200</span>, &#123;</span><br><span class="line">                        <span class="string">&quot;status&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;data&quot;</span>: todos</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    sendResponse(res, <span class="number">400</span>, &#123;</span><br><span class="line">                        <span class="string">&quot;status&quot;</span>: <span class="string">&quot;false&quot;</span></span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                sendResponse(res, <span class="number">405</span>, &#123;</span><br><span class="line">                    <span class="string">&quot;status&quot;</span>: <span class="string">&quot;false&quot;</span></span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; </span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p><strong>段落測試</strong>（需要使用 POSTMAN）<br><strong>測試網址</strong>：<code>http://127.0.0.1:3000/todo/(任一筆id)</code><br>（先用 POST 方法建立幾筆資料，才有 ID 可用）<br><strong>測試方法</strong>：PATCH<br><strong>測試資料</strong>： <code>&#123;&quot;title&quot;: &quot;test&quot;&#125;</code> or 各種奇怪資料</p>
</blockquote>
<hr>
<h2 id="💎-結語"><a href="#💎-結語" class="headerlink" title="💎 結語"></a>💎 結語</h2><p>寫到這邊，總算把所有功能完成，後續還有許多可以調整優化的（回傳詳細的錯誤訊息、模組化…等），就自行發揮吧！</p>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>[Node.JS] 打造 todolist api 5 - 加入資料庫（MongoDB）</title>
    <url>/2022/03/06/nodejs6/</url>
    <content><![CDATA[<p><img data-src="/images/nodejs-logo.png"></p>
<span id="more"></span>
<p>todolist api 在前一篇文章雖然已經上線運行，但是待辦事項沒有存放到資料庫，只要閒置久了資料就會消失，這篇文章會介紹 MongoDB 的操作，並應用資料庫讓每筆待辦都能被儲存下來。<br>如果已經熟悉 MongoDB 的操作，可以直接跳到最後一個段落。</p>
<hr>
<h2 id="💎-安裝-MongoDB"><a href="#💎-安裝-MongoDB" class="headerlink" title="💎 安裝 MongoDB"></a>💎 安裝 MongoDB</h2><h3 id="安裝"><a href="#安裝" class="headerlink" title="安裝"></a>安裝</h3><ul>
<li><p>MacOS</p>
<ul>
<li>方法１：下載壓縮檔，解壓縮後的 bin 資料夾內有４個檔案（mongo、mongod…），透過終端機指令（<code>sudo cp 完整路徑/mongodb-directory/bin/* /usr/local/bin/</code>）或是 Finder 把這４個檔案移動到 <code>/usr/local/bin/</code> 路徑裡面。<blockquote>
<p><a href="https://www.mongodb.com/try/download/community">MongoDB官方下載頁</a>、<a href="https://docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x-tarball/">操作文件</a></p>
</blockquote>
</li>
<li>方法２：使用 Homebrew 安裝，指令為 <code>brew install mongodb-community</code>，安裝的內容較多、較佔空間，但是安裝好後可以直接開始使用。<blockquote>
<p><a href="https://github.com/mongodb/homebrew-brew">操作文件 (GitHub)</a></p>
</blockquote>
</li>
</ul>
</li>
<li><p>Windows：下載安裝檔執行安裝即可。</p>
<blockquote>
<p><a href="https://www.mongodb.com/try/download/community">MongoDB官方下載頁</a></p>
</blockquote>
</li>
</ul>
<h3 id="環境測試與操作指令"><a href="#環境測試與操作指令" class="headerlink" title="環境測試與操作指令"></a>環境測試與操作指令</h3><ol>
<li><p>使用終端機執行 mongo 和 mongod 指令，成功執行時會顯示很多訊息（可先略過內容），失敗時則顯示找不到該指令。<br><code>使用 MacOS 解壓縮方式安裝，在首兩次執行時會跳出安全性提示，需要開啟相關設定才能執行指令（跳出的提示會有選項可以導向設定頁面）</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mongo</span><br><span class="line">mongod</span><br></pre></td></tr></table></figure></li>
<li><p>建立本地資料庫所需的資料夾和檔案，結構如下：</p>
</li>
</ol>
<ul>
<li>MongoDB (目錄)<ul>
<li>data (目錄)</li>
<li>logs (目錄)<ul>
<li>mongo.log (檔案)</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="3">
<li><p>開啟終端機，輸入指令啟用資料庫，成功啟用後會發現指定為資料庫路徑的目錄裡面多了好幾個檔案。<br>（可以先 cd 到 MongoDB 目錄，指令內的路徑就能少打一些）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mongod --dbpath 完整路徑/MongoDB/data --logpath 完整路徑/MongoDB/logs/mongo.log</span><br></pre></td></tr></table></figure>
<p>指令說明：</p>
<ul>
<li>mongod：啟動資料庫</li>
<li>–dbpath：參數，設定資料庫的路徑</li>
<li>–logpath：參數，設定 log檔 的路徑</li>
<li>Ctrl+C：關閉資料庫</li>
</ul>
</li>
<li><p>開啟另一個終端機，輸入 mongo 指令連線資料庫，成功連線時會出現許多訊息，其中可以看到資料庫使用本機的 27017 port（127.0.0.1:27017），進入資料庫後可以執行一些指令來測試。<br><code>MongoDB 的結構是 db(資料庫) -&gt; Collection(集合) -&gt; document(文件/資料)，透過以下指令就會依這個順序看到每個層級的資訊</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mongo <span class="comment"># 連線資料庫</span></span><br><span class="line">show dbs  <span class="comment"># 顯示所有資料庫</span></span><br><span class="line">use <span class="built_in">local</span> <span class="comment"># 切換到 local 資料庫</span></span><br><span class="line">show collections <span class="comment"># 顯示所有集合</span></span><br><span class="line">db.startup_log.find() <span class="comment"># 顯示 startup_log 裡面的所有資料</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="💎-註冊-MongoDB-雲端服務"><a href="#💎-註冊-MongoDB-雲端服務" class="headerlink" title="💎 註冊 MongoDB 雲端服務"></a>💎 註冊 MongoDB 雲端服務</h2><ul>
<li>前往 <a href="https://www.mongodb.com/">MongoDB 首頁</a> 右上方區塊點擊註冊或登入，註冊帳號的過程也很簡單，選項大致選完就完成了。</li>
<li>登入後會跳轉到 Create Cluster 頁面，只是練習的話就選擇免費的就好，雲端主機的種類也使用預設的，過程請<code>注意頁面底下顯示的收費金額</code>。</li>
<li>接著會跳轉到『建立使用者名稱和密碼』、『網路存取』的設定，使用者名稱和密碼是連接資料庫時需要使用，網路存取因為是本地練習，可以選擇取得我的 ip 後加入。<br><code>如果自己連網的 ip 會浮動就需要再次來這邊更改</code><br><code>API 經常會設計開放給眾人戳，但是資料庫通常都是白名單開放，全開非常危險</code></li>
<li>完成後就可以從左側選單的 Database 查看建立好的資料庫。<br><img data-src="/images/mongo1.png"></li>
</ul>
<hr>
<h2 id="💎-安裝-Compass"><a href="#💎-安裝-Compass" class="headerlink" title="💎 安裝 Compass"></a>💎 安裝 Compass</h2><ul>
<li>Compass 是 MongoDB 的 GUI 工具，使用 Windows 系統不需額外安裝（已經包含在 MongoDB 安裝裡），MacOS 需要到 <a href="https://www.mongodb.com/try/download/compass">MongoDB 官方網站</a> 下載，安裝方式很簡單，不需要另行設定。</li>
<li>連接本地資料庫：<br>Compass 主要操作介面有輸入資料庫連結的地方（如圖），只要空著直接點連線就會連接本地資料庫（請先確認有用 mongod 指令開啟本地資料庫）<br><img data-src="/images/compass.png"></li>
<li>連接遠端資料庫：<ol>
<li>回到上個步驟完成的 Mongo 雲端資料庫網頁</li>
<li>點選『Connect』<img data-src="/images/mongo2.png"></li>
<li>建立 IP，如果已經建立了就不會出現這個步驟)</li>
<li>點選『Connect using MongoDB Compass』</li>
<li>點選『I have MongoDB Compass』</li>
<li>出現一串連結複製下來，長得像這樣：<br><code>mongodb+srv://xxxxx:&lt;password&gt;@cluster0.uklck.mongodb.net/xxxxx</code></li>
<li>回到 Compass 介面輸入資料庫連結的地方貼上，把<code>&lt;password&gt;</code>的部份修改成先前建立的使用者密碼。</li>
<li>連線成功就完成了！</li>
</ol>
</li>
</ul>
<hr>
<h2 id="💎-資料庫操作指令"><a href="#💎-資料庫操作指令" class="headerlink" title="💎 資料庫操作指令"></a>💎 資料庫操作指令</h2><p>MongoDB Shell 可以用來直接操作資料庫，在學習 Node.js、PHP、C#… 等後端語言操作方式之前，可以先熟悉 MongoDB Shell，因為除了不同的後端語言會有自己的起手勢、撰寫格式外，資料庫操作的方法名稱都是大同小異的，接下來就介紹 MongoDB 的 CRUD 使用哪些指令（只有記錄部分指令，完整可以參考 <a href="https://docs.mongodb.com/manual/">官方文件</a>）。<br><code>以下都是在本地資料庫做練習</code></p>
<h3 id="C-Create-："><a href="#C-Create-：" class="headerlink" title="C (Create)："></a>C (Create)：</h3><ul>
<li><p><code>use &lt;dbName&gt;</code>：切換到指定資料庫。<br>初始環境中只有 admin、config、local 3個資料庫，可以透過 use 指令來切換到不同資料庫，CRUD 操作前也需要先用這個指令來切換到指定資料庫中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">use 資料庫名稱</span><br></pre></td></tr></table></figure></li>
<li><p><code>db.&lt;collectionName&gt;.insertOne()</code>：在指定集合內新增一筆資料。<br><code>&lt;collectionName&gt;</code> 要換成集合的名稱，<code>()括弧</code>裡面帶入要新增的資料。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.集合名稱.insertOne(&#123;<span class="string">&quot;greeting&quot;</span>: <span class="string">&quot;Hello&quot;</span>&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>新增資料庫：<br>使用資料庫時不會在初始的資料庫裡操作，而是針對專案新增專用的資料庫，MongoDB 沒有新增資料庫的專用指令，需要兩個指令來完成：</p>
<ol>
<li><code>use 新資料庫名稱</code>：送出這個指令後就會切換到新的資料庫名稱中，此時只是暫時的狀態，尚未真正建立資料庫。</li>
<li><code>db.&lt;collectionName&gt;.insertOne(...)</code>：利用新增資料的指令，設定了集合的名稱，並加入新的資料，資料庫也會同時建立起來。</li>
</ol>
<p>以 todolist 為例，環境設計和對應指令如下：</p>
<ul>
<li>資料庫名稱：todolist</li>
<li>集合名稱：todos</li>
<li>新增一筆資料：{“title”: “eat”}<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">use todolist</span><br><span class="line">db.todos.insertOne(&#123;<span class="string">&quot;title&quot;</span>: <span class="string">&quot;eat&quot;</span>&#125;)</span><br><span class="line"><span class="comment"># 執行上面兩個指令後，資料庫、集合、資料都建立好了</span></span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>官方文件：<a href="https://www.mongodb.com/basics/create-database">How to Create a Database in MongoDB</a></p>
</blockquote>
</li>
</ul>
<ul>
<li><code>db./&lt;collectionName&gt;.insertMany()</code>：在指定集合內新增多筆資料。<br>和單筆新增差不多，括弧內改成陣列格式來存放多筆資料。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 新增兩筆</span></span><br><span class="line">db.todos.insertMany([</span><br><span class="line">   &#123;<span class="string">&quot;title&quot;</span>: <span class="string">&quot;sleep&quot;</span>&#125;,</span><br><span class="line">   &#123;<span class="string">&quot;title&quot;</span>: <span class="string">&quot;walk&quot;</span>&#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<blockquote>
<p>官方文件：<a href="https://docs.mongodb.com/manual/tutorial/insert-documents/">Insert</a></p>
</blockquote>
</li>
</ul>
<h3 id="R-Read"><a href="#R-Read" class="headerlink" title="R (Read)"></a>R (Read)</h3><ul>
<li><code>db.&lt;collectionName&gt;.find()</code>：取得指定集合內符合條件的所有資料。</li>
</ul>
<ol>
<li>取得全部資料：不加任何參數，在練習新增、刪除、修改操作時，都可以使用這個指令檢查成果。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 找出 todos 集合內的所有資料</span></span><br><span class="line">db.todos.find()</span><br></pre></td></tr></table></figure></li>
<li>條件查詢：括弧() 內加入篩選條件，取得所有符合的資料。<br>篩選條件有非常多種，以下大致列出一些用法。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 單一條件</span></span><br><span class="line">db.todos.find(&#123;</span><br><span class="line">  <span class="string">&quot;title&quot;</span>: <span class="string">&quot;sleep&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多種條件</span></span><br><span class="line">db.todos.find(&#123;</span><br><span class="line">  <span class="string">&quot;title&quot;</span>: <span class="string">&quot;sleep&quot;</span>,</span><br><span class="line">  <span class="string">&quot;content&quot;</span>: <span class="string">&quot;...&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 數值區間</span></span><br><span class="line">db.todos.find(&#123;</span><br><span class="line">  <span class="string">&quot;price&quot;</span>: &#123;<span class="variable">$gt</span>:500&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 關鍵字</span></span><br><span class="line">db.todos.find(&#123;</span><br><span class="line">  <span class="string">&quot;title&quot;</span>: /a/</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保護欄位：第二個參數指定的屬性不會被取出</span></span><br><span class="line">db.todos.find(</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;title&quot;</span>: /a/</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;_id&quot;</span>: 0</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜尋陣列裡面的值</span></span><br><span class="line">db.todos.find(</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;tools&quot;</span>: &#123;<span class="variable">$in</span>:[<span class="string">&quot;vscode&quot;</span>]&#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="查詢參數"><a href="#查詢參數" class="headerlink" title="查詢參數"></a>查詢參數</h4><table>
<thead>
<tr>
<th align="center">參數</th>
<th align="center">功用</th>
<th align="center">參數</th>
<th align="center">功用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$eq</td>
<td align="center">等於</td>
<td align="center">$ne</td>
<td align="center">不等於</td>
</tr>
<tr>
<td align="center">$gt</td>
<td align="center">大於</td>
<td align="center">$lt</td>
<td align="center">小於</td>
</tr>
<tr>
<td align="center">$gte</td>
<td align="center">大於等於</td>
<td align="center">$lte</td>
<td align="center">小於等於</td>
</tr>
<tr>
<td align="center">$in</td>
<td align="center">存在某個值</td>
<td align="center">$nin</td>
<td align="center">不存在某個值</td>
</tr>
</tbody></table>
<ul>
<li><p><code>db.&lt;collectionName&gt;.findOne()</code>：取得指定集合內符合條件的一筆資料。<br>篩選條件通常用 id（建立時會自動產生），不會有重複的問題。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.todos.findOne(&#123;<span class="string">&quot;_id&quot;</span>: PbjectId(<span class="string">&quot;xxxxxxxx實際的IDxxxxxxxx&quot;</span>)&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>官方文件：<a href="https://docs.mongodb.com/manual/reference/method/db.collection.find/">Find</a>、<a href="https://docs.mongodb.com/manual/reference/method/db.collection.findOne/">FindeOne</a></p>
</blockquote>
</li>
</ul>
<h3 id="U-Update"><a href="#U-Update" class="headerlink" title="U (Update)"></a>U (Update)</h3><ul>
<li><p><code>db.&lt;collectionName&gt;.updateOne()</code>：修改指定集合內的一筆資料。<br>需要知道要改哪筆資料，所以放入兩個參數，<code>篩選條件</code> 和 <code>新的資料內容</code>。</p>
<ul>
<li>篩選條件通常用 id（建立時會自動產生），不會有重複的問題。</li>
<li>新的資料<code>需要</code>放到 $set 屬性裡面。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.todos.updateOne(</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;_id&quot;</span>: PbjectId(<span class="string">&quot;xxxxxxxx實際的IDxxxxxxxx&quot;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;<span class="variable">$set</span>&quot;</span>: &#123;</span><br><span class="line">      &#123;<span class="string">&quot;title&quot;</span>: <span class="string">&quot;run&quot;</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>db.&lt;collectionName&gt;.updateMany()</code>：修改指定集合內的多筆資料。</p>
<ul>
<li>多筆資料不會使用 id（只能找到一筆），改用其他條件來篩選。</li>
<li>新的資料<code>需要</code>放到 $set 屬性裡面，所有符合的結果都會被修改。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.todos.updateMany(</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;title&quot;</span>: <span class="string">&quot;walk&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;<span class="variable">$set</span>&quot;</span>: &#123;</span><br><span class="line">      &#123;<span class="string">&quot;title&quot;</span>: <span class="string">&quot;run&quot;</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>官方文件：<a href="https://docs.mongodb.com/manual/tutorial/update-documents/">Update</a></p>
</blockquote>
</li>
</ul>
</li>
<li><p><code>db.&lt;collectionName&gt;.replaceOne()</code>：取代指定集合內的一筆資料。</p>
<ul>
<li>replace 和 update 的差異在於，update 只會更新對應屬性，replace 則是覆蓋全部。</li>
<li>新的資料<code>不需要</code>放到 $set 屬性裡面。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 假設原始資料長這樣</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;title&quot;</span>: <span class="string">&quot;run&quot;</span>,</span><br><span class="line">  <span class="string">&quot;distance&quot;</span>: <span class="string">&quot;2000m&quot;</span>,</span><br><span class="line">  <span class="string">&quot;time&quot;</span>: <span class="string">&quot;1700&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
使用 updateOne()<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.todos.updateOne(</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;title&quot;</span>: <span class="string">&quot;run&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;<span class="variable">$set</span>&quot;</span>: &#123;</span><br><span class="line">      &#123;<span class="string">&quot;title&quot;</span>: <span class="string">&quot;walk&quot;</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 執行結果：</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;title&quot;</span>: <span class="string">&quot;walk&quot;</span>,</span><br><span class="line">  <span class="string">&quot;distance&quot;</span>: <span class="string">&quot;2000m&quot;</span>,</span><br><span class="line">  <span class="string">&quot;time&quot;</span>: <span class="string">&quot;1700&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
使用 replaceOne()<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.todos.replaceOne(</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;title&quot;</span>: <span class="string">&quot;run&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;title&quot;</span>: <span class="string">&quot;walk&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 執行結果：</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;title&quot;</span>: <span class="string">&quot;walk&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>官方文件：<a href="https://docs.mongodb.com/manual/reference/method/db.collection.replaceOne/">ReplaceOne</a></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="D-Delete"><a href="#D-Delete" class="headerlink" title="D (Delete)"></a>D (Delete)</h3><ul>
<li><p><code>db.&lt;collectionName&gt;.deleteOne()</code>：刪除指定集合內的一筆資料。<br>只需要傳入篩選條件就可以，刪除的對象會是整筆資料，不是單一屬性。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.todos.deleteOne(</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;title&quot;</span>: <span class="string">&quot;walk&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li><p><code>db.&lt;collectionName&gt;.deleteMany()</code>：刪除指定集合內的多筆資料。<br>符合條件的都會被刪除。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.todos.deleteMany(</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;title&quot;</span>: <span class="string">&quot;walk&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li><p><code>db.dropDatabase()</code>：刪除指定資料庫。<br>需要兩個步驟，use 資料庫，再執行刪除指令，高風險操作請謹慎使用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">use DBname</span><br><span class="line">db.dropDatabase()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>官方文件：<a href="https://docs.mongodb.com/manual/tutorial/remove-documents/">Delete</a>、<a href="https://docs.mongodb.com/manual/reference/method/db.dropDatabase/">db.dropDatabase()</a></p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="💎-Todolist-API-結合-MongoDB"><a href="#💎-Todolist-API-結合-MongoDB" class="headerlink" title="💎 Todolist API 結合 MongoDB"></a>💎 Todolist API 結合 MongoDB</h2><p>學會 MongoDB 後就可以迎來 todolist 的第二次進化！以下就是改造的步驟。</p>
<h3 id="安裝-mongodb-driver-套件"><a href="#安裝-mongodb-driver-套件" class="headerlink" title="安裝 mongodb driver 套件"></a>安裝 mongodb driver 套件</h3><p>有了 driver 就可讓 node.js 和 MongoDB 交流了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i mongodb</span><br><span class="line"><span class="comment"># 也可以全域安裝</span></span><br><span class="line">npm i -g mongodb</span><br></pre></td></tr></table></figure>

<h3 id="認識基本程式碼"><a href="#認識基本程式碼" class="headerlink" title="認識基本程式碼"></a>認識基本程式碼</h3><p>以下參考官方文件 <a href="https://docs.mongodb.com/drivers/node/current/quick-start/">Quick Start</a> ，可以先試著放到專案測試，沒問題後再來改寫。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; MongoClient &#125; = <span class="built_in">require</span>(<span class="string">&quot;mongodb&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 這串改成自己的 mongodb 雲端服務連結</span></span><br><span class="line"><span class="keyword">const</span> uri =</span><br><span class="line">  <span class="string">&quot;mongodb+srv://&lt;user&gt;:&lt;password&gt;@&lt;cluster-url&gt;?retryWrites=true&amp;writeConcern=majority&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> client = <span class="keyword">new</span> MongoClient(uri);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> client.connect();</span><br><span class="line">    <span class="comment">// 改成自己的資料庫名稱</span></span><br><span class="line">    <span class="keyword">const</span> database = client.db(<span class="string">&#x27;sample_mflix&#x27;</span>);</span><br><span class="line">    <span class="comment">// 改成自己的集合名稱，變數名稱也順便調整</span></span><br><span class="line">    <span class="keyword">const</span> movies = database.collection(<span class="string">&#x27;movies&#x27;</span>);</span><br><span class="line">    <span class="comment">// 這是查詢字串</span></span><br><span class="line">    <span class="keyword">const</span> query = &#123; <span class="attr">title</span>: <span class="string">&#x27;Hello&#x27;</span> &#125;;</span><br><span class="line">    <span class="comment">// movie 和 movies 變數名稱請自行修改</span></span><br><span class="line">    <span class="comment">// query 可以拿掉，變成查詢所有資料</span></span><br><span class="line">    <span class="keyword">const</span> movie = <span class="keyword">await</span> movies.findOne(query);</span><br><span class="line">    <span class="comment">// 變數名稱自行修改，成功顯示資料就沒問題了</span></span><br><span class="line">    <span class="built_in">console</span>.log(movie);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 每次連線完成都要記得關閉，佔用滿了資料庫就掛了</span></span><br><span class="line">    <span class="keyword">await</span> client.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">run().catch(<span class="built_in">console</span>.dir);</span><br></pre></td></tr></table></figure>

<h3 id="改寫程式碼"><a href="#改寫程式碼" class="headerlink" title="改寫程式碼"></a>改寫程式碼</h3><p>可以依照官方的程式碼自由改寫，以下寫法僅供參考：</p>
<ol>
<li><p>串連資料庫的目的是取代原本使用陣列存放 todolist，第一步就可以把原本寫的 <code>let todos = []</code> 拿掉。</p>
</li>
<li><p>把官方範例中的常數宣告放到 todolist 程式最上方，或是模組化寫到另一個檔案來引入。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; MongoClient &#125; = <span class="built_in">require</span>(<span class="string">&quot;mongodb&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> uri = <span class="string">&quot;mongodb+srv://自己的 mongodb 雲端服務連結&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> client = <span class="keyword">new</span> MongoClient(uri);</span><br></pre></td></tr></table></figure></li>
<li><p>剩下的部份可以把「連接資料庫 -&gt; 關閉資料庫」抽出來寫成函式，此處我設計成可以傳入參數，讓 switch…case 判斷要執行哪個對應的 CRUD。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">connectDB</span>(<span class="params">res, method, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> client.connect();</span><br><span class="line">    <span class="keyword">const</span> database = client.db(<span class="string">&#x27;todolist&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> todos = database.collection(<span class="string">&#x27;todos&#x27;</span>);</span><br><span class="line">    <span class="comment">// 判斷傳入的參數</span></span><br><span class="line">    <span class="keyword">switch</span>(action) &#123;</span><br><span class="line">      <span class="attr">case</span> :</span><br><span class="line">        <span class="comment">//...先空著...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> client.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>函式的架構完成後，原本 todolist 的 5 隻 api 對應的陣列操作程式碼可以修改成呼叫連接資料庫的函式，傳入參數來執行對應行為，改寫的內容依序如下：</p>
<h4 id="修改回傳函式："><a href="#修改回傳函式：" class="headerlink" title="修改回傳函式："></a>修改回傳函式：</h4><p>前面的文章原本只設計用一個函式來處理 response，為了方便，我拆成 sendRes 和 sendErr 兩個方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> headers = &#123;</span><br><span class="line">    <span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>: <span class="string">&#x27;Content-Type, Authorization, Content-Length, X-Requested-With&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>: <span class="string">&#x27;*&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span>: <span class="string">&#x27;PATCH, POST, GET, OPTIONS, DELETE&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> statusMsg = &#123;</span><br><span class="line">    <span class="string">&#x27;400&#x27;</span>: <span class="string">&#x27;Bad Request&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;401&#x27;</span>: <span class="string">&#x27;Unauthorized&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;403&#x27;</span>: <span class="string">&#x27;Forbidden&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;404&#x27;</span>: <span class="string">&#x27;Not Found&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;405&#x27;</span>: <span class="string">&#x27;Method Not Allowed&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> sendRes = <span class="function">(<span class="params">res, data</span>) =&gt;</span> &#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, headers);</span><br><span class="line">    <span class="keyword">if</span> (data) &#123;</span><br><span class="line">        res.write(<span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">            <span class="string">&#x27;status&#x27;</span>: <span class="string">&#x27;true&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;data&#x27;</span>: data</span><br><span class="line">        &#125;))</span><br><span class="line">    &#125;</span><br><span class="line">    res.end();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> sendErr = <span class="function">(<span class="params">res, statusCode</span>) =&gt;</span> &#123;</span><br><span class="line">    res.writeHead(statusCode, headers);</span><br><span class="line">    res.write(<span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">        <span class="string">&#x27;status&#x27;</span>: <span class="string">&#x27;false&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;msg&#x27;</span>: statusMsg[statusCode]</span><br><span class="line">    &#125;))</span><br><span class="line">    res.end();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    sendRes,</span><br><span class="line">    sendErr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="功能：取得全部"><a href="#功能：取得全部" class="headerlink" title="功能：取得全部"></a>功能：取得全部</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原本的內容</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;GET&#x27;</span>:</span><br><span class="line">    sendResponse(res, <span class="number">200</span>, &#123;</span><br><span class="line">        <span class="string">&quot;status&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">        <span class="comment">// 改成回傳待辦事項的變數</span></span><br><span class="line">        <span class="string">&quot;data&quot;</span>: todos</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改寫成呼叫資料庫連結函式</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;GET&#x27;</span>:</span><br><span class="line">    run(res, <span class="string">&#x27;getAll&#x27;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函式功能修改</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">res, method, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 新增一個變數來存放資料庫回傳的訊息</span></span><br><span class="line">        <span class="keyword">let</span> result;</span><br><span class="line">        <span class="keyword">switch</span>(method) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;getAll&#x27;</span>:</span><br><span class="line">                <span class="comment">// find()查詢結果需要用 toArray() 方法轉換格式才能讀取</span></span><br><span class="line">                result = <span class="keyword">await</span> todos.find().toArray();</span><br><span class="line">                <span class="keyword">await</span> sendRes(res, result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="功能：新增一筆"><a href="#功能：新增一筆" class="headerlink" title="功能：新增一筆"></a>功能：新增一筆</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原本的內容</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改寫成呼叫資料庫連結函式</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">    req.on(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> title = <span class="built_in">JSON</span>.parse(body)?.title;</span><br><span class="line">        title ? run(res, <span class="string">&#x27;insertOne&#x27;</span>, &#123;title&#125;) : sendErr(res, <span class="number">400</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函式功能修改</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">res, method, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">let</span> result;</span><br><span class="line">        <span class="keyword">switch</span>(method) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;insertOne&#x27;</span>:</span><br><span class="line">                result = <span class="keyword">await</span> todos.insertOne(data);</span><br><span class="line">                <span class="keyword">await</span> sendRes(res, result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="功能：刪除一筆"><a href="#功能：刪除一筆" class="headerlink" title="功能：刪除一筆"></a>功能：刪除一筆</h4><p>原本的 ID 檢查是透過陣列方法，連結資料庫後如果要這樣做會變成先送出查詢指令，確認有資料再送出一次刪除指令，所以這邊我改成檢查 ID 格式是否正確，確認正確後直接送出，讓資料庫回應刪除是否成功。<br>檢查 MongoDB 的 ID 可以安裝 <a href="https://mongoosejs.com/docs/index.html">mongoose</a> 這個套件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i mongoose</span><br></pre></td></tr></table></figure>
<p>除此之外，檢查通過後還需要生成帶有 ObjectId 的物件，可以從 mongodb 引用，套件都沒問題後在程式碼的最上方引入這些功能。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多引用了 ObjectId</span></span><br><span class="line"><span class="keyword">const</span> &#123; MongoClient, ObjectId &#125; = <span class="built_in">require</span>(<span class="string">&#x27;mongodb&#x27;</span>);</span><br><span class="line"><span class="comment">// 引用 mongoose 來驗證ID</span></span><br><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">&#x27;mongoose&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>程式碼修改</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原本的內容</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.url.startsWith(<span class="string">&#x27;/todo/&#x27;</span>)) &#123;</span><br><span class="line">      <span class="keyword">let</span> id = req.url.split(<span class="string">&#x27;/&#x27;</span>).pop();</span><br><span class="line">      <span class="keyword">let</span> index = todos.findIndex(<span class="function"><span class="params">el</span> =&gt;</span> el.id == id);</span><br><span class="line">      <span class="keyword">if</span> (index &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (req.method == <span class="string">&#x27;PATCH&#x27;</span>) &#123;</span><br><span class="line">              ...</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.method == <span class="string">&#x27;DELETE&#x27;</span>) &#123;</span><br><span class="line">              todos.splice(index, <span class="number">1</span>);</span><br><span class="line">              sendResponse(res, <span class="number">200</span>, &#123;</span><br><span class="line">                  <span class="string">&quot;status&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">                  <span class="string">&quot;data&quot;</span>: todos</span><br><span class="line">              &#125;);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          ...</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改寫成呼叫資料庫連結函式</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.url.startsWith(<span class="string">&#x27;/todo/&#x27;</span>)) &#123;</span><br><span class="line">    <span class="keyword">let</span> id = req.url.split(<span class="string">&#x27;/&#x27;</span>).pop();</span><br><span class="line">    <span class="comment">// 檢查 ID 格式是否正確</span></span><br><span class="line">    <span class="keyword">let</span> idIsValid = mongoose.Types.ObjectId.isValid(id);</span><br><span class="line">    <span class="keyword">if</span> (idIsValid) &#123;</span><br><span class="line">        <span class="keyword">if</span> (req.method == <span class="string">&#x27;PATCH&#x27;</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.method == <span class="string">&#x27;DELETE&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 傳入第三個參數：ID 物件</span></span><br><span class="line">            run(res, <span class="string">&#x27;deleteOne&#x27;</span>, &#123;<span class="string">&quot;_id&quot;</span>: ObjectId(id)&#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sendErr(res, <span class="number">405</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sendErr(res, <span class="number">405</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函式功能修改</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">res, method, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">switch</span>(method) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;deleteOne&#x27;</span>:</span><br><span class="line">                result = <span class="keyword">await</span> todos.deleteOne(data);</span><br><span class="line">                <span class="keyword">await</span> sendRes(res, result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="功能：刪除全部"><a href="#功能：刪除全部" class="headerlink" title="功能：刪除全部"></a>功能：刪除全部</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原本的內容</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;DELETE&#x27;</span>:</span><br><span class="line">    todos.length = <span class="number">0</span>;</span><br><span class="line">    sendResponse(res, <span class="number">200</span>, &#123;</span><br><span class="line">        <span class="string">&quot;status&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">        <span class="string">&quot;data&quot;</span>: todos</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改寫成呼叫資料庫連結函式</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;GET&#x27;</span>:</span><br><span class="line">    run(res, <span class="string">&#x27;deleteAll&#x27;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函式功能修改</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">res, method, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 新增一個變數來存放資料庫回傳的訊息</span></span><br><span class="line">        <span class="keyword">let</span> result;</span><br><span class="line">        <span class="keyword">switch</span>(method) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;deleteAll&#x27;</span>:</span><br><span class="line">                result = <span class="keyword">await</span> todos.deleteMany();</span><br><span class="line">                <span class="keyword">await</span> sendRes(res, result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="功能：更新一筆"><a href="#功能：更新一筆" class="headerlink" title="功能：更新一筆"></a>功能：更新一筆</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原本的內容</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (req.method == <span class="string">&#x27;PATCH&#x27;</span>) &#123;</span><br><span class="line">    req.on(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> title = <span class="built_in">JSON</span>.parse(body)?.title;</span><br><span class="line">            <span class="keyword">if</span> (title) &#123;</span><br><span class="line">                <span class="comment">// 修改對應 ID 的 title</span></span><br><span class="line">                todos[index].title = title;</span><br><span class="line">                sendResponse(res, <span class="number">200</span>, &#123;</span><br><span class="line">                    <span class="string">&quot;status&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;data&quot;</span>: todos</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sendResponse(res, <span class="number">400</span>, &#123;</span><br><span class="line">                    <span class="string">&quot;status&quot;</span>: <span class="string">&quot;false&quot;</span></span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            sendResponse(res, <span class="number">405</span>, &#123;</span><br><span class="line">                <span class="string">&quot;status&quot;</span>: <span class="string">&quot;false&quot;</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改寫成呼叫資料庫連結函式</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.url.startsWith(<span class="string">&#x27;/todo/&#x27;</span>)) &#123;</span><br><span class="line">    <span class="keyword">let</span> id = req.url.split(<span class="string">&#x27;/&#x27;</span>).pop();</span><br><span class="line">    <span class="comment">// 檢查 ID 格式是否正確</span></span><br><span class="line">    <span class="keyword">let</span> idIsValid = mongoose.Types.ObjectId.isValid(id);</span><br><span class="line">    <span class="keyword">if</span> (idIsValid) &#123;</span><br><span class="line">        <span class="keyword">if</span> (req.method == <span class="string">&#x27;PATCH&#x27;</span>) &#123;</span><br><span class="line">          req.on(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="keyword">let</span> title = <span class="built_in">JSON</span>.parse(body)?.title;</span><br><span class="line">                  title ? run(res, <span class="string">&#x27;updateOne&#x27;</span>, [&#123;<span class="string">&quot;_id&quot;</span>: ObjectId(id)&#125;, &#123;title&#125;]) : sendErr(res, <span class="number">400</span>);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                  sendErr(res, <span class="number">405</span>);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函式功能修改</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">res, method, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">switch</span>(method) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;updateOne&#x27;</span>:</span><br><span class="line">                <span class="comment">// 因為我只提供傳入一個 data 參數，這邊用陣列來放 id 跟 新資料，也可以用物件處理</span></span><br><span class="line">                result = <span class="keyword">await</span> todos.updateOne(data[<span class="number">0</span>], &#123;<span class="attr">$set</span>: data[<span class="number">1</span>]&#125;);</span><br><span class="line">                <span class="keyword">await</span> sendRes(res, result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="最終測試"><a href="#最終測試" class="headerlink" title="最終測試"></a>最終測試</h4><p>其實改寫的過程中就會一直使用 POSTMAN 來測試，最後從頭到尾測試一遍也許會發現漏掉的 bug，像我就出現連不上雲端資料庫的問題，才發現是我的連線 IP 變更所以被阻擋掉了。</p>
</li>
</ol>
<hr>
<h2 id="💎-總結"><a href="#💎-總結" class="headerlink" title="💎 總結"></a>💎 總結</h2><p>API 大致的流程：<br>收到req -&gt; 檢查內容決定行為 -&gt; 連結資料庫（關閉連線）-&gt; 發送 Res(回應結束)<br>要做這樣基本功能的 API 要學不少新技能，但是完成後會對整個流程有進一步的認識，這系列文章的完成品 Code 我也放在 <a href="https://github.com/stark920/TodolistApiFullVersion">GitHub</a> 上，希望能對同樣是新手的同學們有所幫助。</p>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>[Node.JS] 一次認識 NVM、Node.js、NPM、NPX</title>
    <url>/2022/02/21/nodejsStart/</url>
    <content><![CDATA[<p><img data-src="/images/nodejs-logo.png"></p>
<span id="more"></span>
<p>對於前端新手來說 Node.js 做為後端工具感覺已經很遙遠了，打電動只知道 NPC，各種 N 什麼的到底是啥玩意兒？這次就來一次認識清楚！</p>
<hr>
<h2 id="💎-Node-js"><a href="#💎-Node-js" class="headerlink" title="💎 Node.js"></a>💎 Node.js</h2><p>JavaScript 過去都只在前端上（瀏覽器）應用，直到 2009 年 Node.js 問世後才逐漸讓 JavaScript 跨足到後端（伺服器），讓後端工程師除了 Apache 或 IIS 外有了新的選擇。</p>
<h3 id="V8"><a href="#V8" class="headerlink" title="V8"></a>V8</h3><p>Node.js 採用了 Google 的 V8 引擎開發，V8 是為了 Chrome 瀏覽器打造的 JavaScript 引擎，使用 C++ 程式語言撰寫，V8 引擎可以將 JavaScipt 的原始碼編譯成機器語言來執行，就能像其他程式語言一樣在瀏覽器以外的環境使用。</p>
<blockquote>
<p>參考資料： <a href="https://https//zh.wikipedia.org/wiki/Node.js">Wiki - Node.js</a></p>
</blockquote>
<h3 id="安裝"><a href="#安裝" class="headerlink" title="安裝"></a>安裝</h3><ol>
<li><p>前往官方網站下載 Node.js 安裝檔（建議選左邊的穩定版本），按『下一步』到完成即可。</p>
<ul>
<li>LTS：穩定支援版本。</li>
<li>Current：最新版本，可能會有一些套件不支援的問題，新版本的網路相關資訊也較少，較舊版本的作法可能不適用。<blockquote>
<p>官網連結： <a href="https://nodejs.org/en/">Node.js</a><br>各版本支援時間列表： <a href="https://nodejs.org/en/about/releases/">Long Term Support (LTS) schedule</a></p>
</blockquote>
</li>
</ul>
</li>
<li><p>完成安裝後可以開啟終端機（Windows -&gt; cmd, Mac -&gt; Terminal），鍵入指令 <code>node --version (node -v)</code> 來檢查版本資訊。</p>
</li>
</ol>
<h3 id="簡單操作"><a href="#簡單操作" class="headerlink" title="簡單操作"></a>簡單操作</h3><p><code>以下指令都是在終端機內執行</code></p>
<ol>
<li>進入 node.js 執行環境<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node</span><br></pre></td></tr></table></figure></li>
<li>進入環境後可以輸入 JavaScript 程式碼，就像瀏覽器的檢查工具一樣<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> a = 1</span><br><span class="line"><span class="comment">#undefined</span></span><br><span class="line">a</span><br><span class="line"><span class="comment">#1</span></span><br><span class="line">a++</span><br><span class="line"><span class="comment">#1</span></span><br><span class="line">a</span><br><span class="line"><span class="comment">#2</span></span><br><span class="line">console.log(<span class="string">&#x27;Hello, world!&#x27;</span>)</span><br><span class="line"><span class="comment">#Hello, world!</span></span><br></pre></td></tr></table></figure></li>
<li>查看可用的指令<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.<span class="built_in">help</span></span><br></pre></td></tr></table></figure></li>
<li>離開 node.js 環境（方法 1）<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.<span class="built_in">exit</span></span><br></pre></td></tr></table></figure></li>
<li>離開 node.js 環境（方法 2）<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 按兩次 Ctrl+C</span></span><br><span class="line">Ctrl+C</span><br><span class="line">Ctrl+C</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="執行-JS-檔案"><a href="#執行-JS-檔案" class="headerlink" title="執行 JS 檔案"></a>執行 JS 檔案</h3><p><code>以下操作 不 在 Node.js 環境內</code><br>方法１：先用指令移動到 JS 檔案存放的目錄位置，再輸入指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node 檔名</span><br></pre></td></tr></table></figure>
<p>方法２：直接輸入完整路徑和檔名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node 完整路徑/檔名</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="💎-NPM"><a href="#💎-NPM" class="headerlink" title="💎 NPM"></a>💎 NPM</h2><p>NPM（Node Package Manager）是 Node.js 內的套件管理工具，開發時為了節省時間都會使用非常多的外部套件，每個套件也會有各自的版本，就會需要有工具來管理這些套件。<br>NPM 是 Node.js 的工具，不需要另外下載安裝，完成 Node.js 的安裝後就可以在終端機輸入指令 <code>npm -v</code> 來檢查版本資訊。</p>
<h3 id="起手勢"><a href="#起手勢" class="headerlink" title="起手勢"></a>起手勢</h3><ol>
<li><p>新增一個專案資料夾</p>
</li>
<li><p>使用 VS Code 開啟專案資料夾</p>
</li>
<li><p>開啟終端機介面（組合熱鍵 <code>ctrl + 反引號</code>）</p>
</li>
<li><p>輸入初始化指令來建立專案檔</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure></li>
<li><p>輸入初始化指令後，會請你依序輸入以下資訊，如果不知道要打什麼就按 Enter 跳過，最後再輸入 yes 就完成了。</p>
<ul>
<li>專案名稱</li>
<li>版本</li>
<li>描述</li>
<li>進入點（Webpack文章會說明）</li>
<li>測試指令</li>
<li>Git 儲存庫位置</li>
<li>關鍵字</li>
<li>作者</li>
<li>開源授權方式</li>
</ul>
</li>
<li><p>初始化指令也可以加入參數，跳過環境設定，直接用預設值建立。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="安裝／移除套件"><a href="#安裝／移除套件" class="headerlink" title="安裝／移除套件"></a>安裝／移除套件</h3><ol>
<li>安裝套件：<code>npm install 套件名稱</code> 或 <code>npm i 套件名稱</code><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以安裝 Bootstrap 為例</span></span><br><span class="line">npm install bootstrap</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以安裝 FontAwesome 為例</span></span><br><span class="line">npm i fontawesome</span><br><span class="line"></span><br><span class="line"><span class="comment"># MacOS 如果出現權限不足錯誤，在指令前方加 sudo，並且提供本機使用者帳號密碼來執行：</span></span><br><span class="line">sudo npm install (套件名稱)</span><br></pre></td></tr></table></figure></li>
<li>移除套件：<code>npm uninstall 套件名稱</code><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm uninstall (套件名稱)</span><br></pre></td></tr></table></figure></li>
<li>檢視所有安裝的套件：<code>npm list</code></li>
</ol>
<h3 id="安裝模式"><a href="#安裝模式" class="headerlink" title="安裝模式"></a>安裝模式</h3><p>隨著專案變得龐大，使用的套件也會變多，這時候就需要針對套件的使用情境來區分『上線』、『開發』和『全域』使用，專案發佈時把不需要上線提供使用者使用的套件留在本地，才能減少資源與效能的浪費。</p>
<ul>
<li>上線使用<br>上線使用顧名思義是需要一起上線使用的（例如：Bootstrap）。<br>在較早的 NPM 教學文章會看到安裝時需要加上 <code>--save</code> 參數，在 v5 版本以後已經改為預設值，可以不用加上參數。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># npm v5 之前</span></span><br><span class="line">npm install --save (套件名稱)</span><br><span class="line"></span><br><span class="line"><span class="comment"># npm v5 以後</span></span><br><span class="line">npm i (套件名稱)</span><br></pre></td></tr></table></figure></li>
<li>開發使用<br>開發用的套件只需要存放在本地，部署到線上會造成空間浪費（例如：Webpack、Gulp）。<br>在 v5 版本以前需要在指令加上參數 <code>--save-dev</code>， v5 版本以後簡化成加上 <code>-D</code> 即可。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># npm v5 之前</span></span><br><span class="line">npm install --save-dev (套件名稱)</span><br><span class="line"></span><br><span class="line"><span class="comment"># npm v5 以後</span></span><br><span class="line">npm i -D (套件名稱)</span><br></pre></td></tr></table></figure>
開發版的套件會記錄在 package.json 中的 “devDependencies” 屬性，和上線版的 “dependencies” 不同，執行完指令後可以檢查是否成功裝對位置。</li>
</ul>
<p><img data-src="https://ithelp.ithome.com.tw/upload/images/20211005/20129729eJZJMY6b3s.png"></p>
<ul>
<li>全域使用<br>有些提供本地使用的工具在不同的專案都可以應用，不使用時也不會影響到其他專案（例如：Yarn、ESLint、TypeScript、各種 cli …），就可以安裝在全域，這樣每個專案不需要額外安裝也可以使用。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i -g (套件名稱)</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="💎-NPM-檔案結構"><a href="#💎-NPM-檔案結構" class="headerlink" title="💎 NPM 檔案結構"></a>💎 NPM 檔案結構</h2><p>完成起手勢後，專案資料夾會多了一些檔案，其中最重要的就是 <code>package.json</code>：</p>
<h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h3><ul>
<li>執行 <code>npm init</code> 指令後產生的檔案，是整個專案的縮影，裡面記錄專案名稱、指令、使用的套件種類和版本…等資訊。</li>
<li>安裝新的套件後，package.json 會在 <code>dependencies</code> 這個項目中記錄套件名稱、版本資訊，通常版本的數字前面會有一個 <code>^</code> 符號，表示會優先使用最新的版本。<br><img data-src="https://ithelp.ithome.com.tw/upload/images/20211005/20129729IobskSFiu9.png"></li>
<li>因為 package.json 記錄了專案所需要的所有套件資訊，在團隊合作或是下載別的專案時，分享者不需要將套件實體檔案上傳，只要提供 package.json ，讓使用者下載後執行指令 <code>npm install</code> 或 <code>npm i</code> 就會安裝需要的套件了。</li>
</ul>
<h3 id="package-lock-json"><a href="#package-lock-json" class="headerlink" title="package-lock.json"></a>package-lock.json</h3><ul>
<li>這是 NPM 5 版本之後才有的檔案，安裝任一套件後就會產生，這個檔案同樣也記錄了套件的版本資訊，但是內容更詳細，這個檔案可以明確的記錄安裝時的版本資訊。</li>
<li>團隊協作時，如果希望團隊的套件版本一致，就可以把這個 package-lock.json 也提供給其他成員，就會安裝指定的版本套件；反之，希望團隊成員都使用最新版本，就不需要提供這個檔案，讓 NPM 依據 package.json 安裝套件。</li>
</ul>
<h3 id="node-modules"><a href="#node-modules" class="headerlink" title="node_modules"></a>node_modules</h3><ul>
<li>node_modules 資聊夾裡面存放著下載回來的套件實體檔案，即使不小心刪除了，也可以透過 <code>npm i</code> 指令下載回來。</li>
<li>可以在這個資料夾內查看套件撰寫的內容，但不宜在此處編輯修改，會有被覆蓋、與其他團隊成員不同步的問題。</li>
</ul>
<hr>
<h2 id="💎-NVM"><a href="#💎-NVM" class="headerlink" title="💎 NVM"></a>💎 NVM</h2><p>套件隨著版本的更新需要管理工具來管理，同樣的，Node.js 也有各種版本，隨著時光流逝，一些專案也成了古董，不只套件版本是舊的、Node.js 版本也是舊的，想要切換到不同版本的 Node.js 的話就需要使用 NVM，使用起來非常簡單，下面就簡短介紹。</p>
<h3 id="安裝-1"><a href="#安裝-1" class="headerlink" title="安裝"></a>安裝</h3><p>NVM 的安裝有很棒的文章可以參考，可以參考下面的連結：</p>
<blockquote>
<p>中文：<a href="https://www.casper.tw/development/2022/01/10/install-nvm/">卡斯伯’s Blog - 安裝 nvm 環境，Node.js 開發者必學（Windows、Mac 均適用）</a><br>英文：<a href="https://github.com/nvm-sh/nvm#installing-and-updating">官方文件</a></p>
</blockquote>
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安裝特定版本 Node.js，例如 12 版</span></span><br><span class="line">nvm install 12</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切換到特定版本 Node.js，例如 12 版</span></span><br><span class="line">nvm use 12</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顯示有哪些 Node.js 版本可用</span></span><br><span class="line">nvm list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 設定預設版本，例如 16 版</span></span><br><span class="line">nvm <span class="built_in">alias</span> default 16</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="💎-NPX"><a href="#💎-NPX" class="headerlink" title="💎 NPX"></a>💎 NPX</h2><p>前面介紹的 npm 在使用上就只有<code>『要用』</code>（安裝）和<code>『不要用』</code>（移除）兩種選擇，沒有<code>『借我用一下就好』</code>這個選項，npx 補足了這個需求（npm v5.2.0 以後才有），可以在不實際安裝套件的情況下執行 CLI、GitHub gists 或 repo（實際上還有安裝的動作，但是放到一個暫存空間）。<br><code>以下指令轉自官方文件，可以安心使用</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># npx 套件名稱 (參數...)</span></span><br><span class="line">npx cowsay hello</span><br><span class="line"></span><br><span class="line"><span class="comment"># npx GitHub gist url</span></span><br><span class="line">npx https://gist.github.com/zkat/4bc19503fe9e9309e2bfaa2c58074d32</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定 Node.js 版本，用這個方式就不需要用 NVM 在本地裝多個版本</span></span><br><span class="line">npx node@12 -v</span><br></pre></td></tr></table></figure>

<blockquote>
<p>參考資料：<a href="https://nodejs.dev/learn/the-npx-nodejs-package-runner">官方文件</a>、<a href="https://www.freecodecamp.org/news/npm-vs-npx-whats-the-difference/">npm vs npx — What’s the Difference?</a></p>
</blockquote>
<hr>
<h2 id="💎-結語"><a href="#💎-結語" class="headerlink" title="💎 結語"></a>💎 結語</h2><p>試著用一句話形容這些工具<br>Node.js - 建置 JavaScript 的後端環境。<br>NVM - 可以切換不同版本的 Node.js 來使用。<br>NPM - 下載和管理各種套件。<br>NPX - 暫存的方式使用套件，用完就刪。</p>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>NPM</tag>
      </tags>
  </entry>
</search>
