<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>[API] 串接 Imgur API 圖床服務，上傳到指定相簿</title>
    <url>/2022/05/06/APIimgur/</url>
    <content><![CDATA[ <img data-src="https://i.imgur.com/T4vK1Yk.png" style="max-height: 200px" align=center />

<span id="more"></span>

<p>圖片是網頁不可或缺的元素，Github pages 不適合放入大量圖片，放到自己的雲端空間也不方便使用，免費的圖床服務就是很好的解決方案，imgur 非常多人使用（也是迷因圖的量產地），一開始參考了網路上的中文教學，發現有些操作已經變了，才有了這篇記錄目前的作法。</p>
<hr>
<h2 id="Imgur-API-Doc"><a href="#Imgur-API-Doc" class="headerlink" title="Imgur API Doc"></a>Imgur API Doc</h2><p>Imgur API 的文件很詳細，是一個便利的操作介面，面板大致分四個區塊：</p>
<ul>
<li>上方 header：可以內容排版是單欄或雙欄，最重要的是選擇範例程式碼的語言種類。</li>
<li>左側選單：選擇要查看的資訊類型，通常會用到的是 image。</li>
<li>中間區塊：顯示文件資訊。</li>
<li>右側區塊：顯示範例程式碼。</li>
</ul>
<p><img data-src="https://i.imgur.com/jz8OoNv.png" alt="Imgur"></p>
<hr>
<h2 id="註冊-Imgur-API-及取得授權"><a href="#註冊-Imgur-API-及取得授權" class="headerlink" title="註冊 Imgur API 及取得授權"></a>註冊 Imgur API 及取得授權</h2><p>以下步驟參考 <a href="https://apidocs.imgur.com/#intro">官方文件</a> 簡略翻譯（圖片使用官方文件的）：</p>
<ol>
<li><p>事前準備</p>
<ul>
<li>安裝 <a href="https://www.postman.com/">Postman</a></li>
<li>點擊官方文件最右上角的按鈕（Run in Postman）下載寫好的 postman 檔案，執行並 import 至 Postman 中。<br><img data-src="https://i.imgur.com/LdHoYo7.png"></li>
</ul>
</li>
<li><p>前往 <a href="https://api.imgur.com/oauth2/addclient">註冊 API 頁面</a> 申請（要先有 Imgur 的帳號）</p>
<ul>
<li>Application name：自己取名</li>
<li>Authorization type：選第一個</li>
<li>Authorization callback URL：填入官方文件提供的網址<br><code>https://www.getpostman.com/oauth2/callback</code></li>
<li>除了信箱，其他可以不填，點擊 submit 送出。</li>
<li>送出後取得 Client ID 和 Client secret，<code>請務必把它記下來</code>。<br><img data-src="https://i.imgur.com/Ied42En.png"></li>
</ul>
</li>
<li><p>開啟 Postman（<code>Postman 的介面隨著版本更新一直有變化，以下步驟都需要自行找到對應位置</code>）。</p>
</li>
<li><p>點擊步驟 1 匯入的 Imgur API，找到 Auth 頁面中的 Type 選單，選擇「OAuth 2.0」。</p>
</li>
<li><p>拉到最底下，點擊「Get New Access Token」。</p>
</li>
<li><p>接下來會進入登入畫面，登入之後很有可能拿到 429 錯誤，需要等一段時間再嘗試（這段很浪費時間）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;data&quot;</span>:&#123;<span class="string">&quot;error&quot;</span>:<span class="string">&quot;Too Many Requests&quot;</span>,<span class="string">&quot;request&quot;</span>:<span class="string">&quot;\/oauth2\/authorize&quot;</span>,<span class="string">&quot;method&quot;</span>:<span class="string">&quot;POST&quot;</span>&#125;,<span class="string">&quot;success&quot;</span>:<span class="literal">false</span>,<span class="string">&quot;status&quot;</span>:<span class="number">429</span>&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>上個步驟如果成功，就會取得一個 refresh token，<code>這個 token 一定要記下來</code>，攸關你的 API 能用多久。<br><img data-src="https://i.imgur.com/0dN8cyJ.png"></p>
</li>
<li><p>Postman 選單切換到 Environment，新增一個 ImgurAPI 的環境變數集合，並且在裡面加入前面取得的 <code>refreshToken</code>、<code>clientId</code>、<code>clientSecret</code>。<br><img data-src="https://i.imgur.com/DaFV5ux.png"></p>
</li>
<li><p> 回到 API Collections，選擇 Imgur API &gt; Account &gt; Generate Access Token，並且設定環境變數使用上個步驟設定的 ImgurAPI 環境（選項應該會在介面右上方）。</p>
</li>
<li><p>送出後就會取得 Access Token 了，這個 Token 的有效時間大約是一個月，當 Access Token 過期時，需要重新執行一次「Generate Access Token」來取得新的 Access Token，所以 <code>refreshToken</code>、<code>clientId</code>、<code>clientSecret</code> 這三個千萬別弄丟了。</p>
</li>
<li><p>補充：取得 Access Token 時會自動加入到設定好的環境變數中，可以直接使用 Postman 測試其他的功能，不需要再額外設定 headers authentication。</p>
</li>
</ol>
<hr>
<h2 id="Imgur-API-操作"><a href="#Imgur-API-操作" class="headerlink" title="Imgur API 操作"></a>Imgur API 操作</h2><h3 id="Headers-權限"><a href="#Headers-權限" class="headerlink" title="Headers 權限"></a>Headers 權限</h3><p>使用 Imgur API 時需要傳入 Authorization Headers，分別有兩種不同模式：</p>
<ul>
<li>匿名用戶： <code>&#123;&quot;Authorization&quot;, &quot;Client-ID &#123;&#123;clientId&#125;&#125;&quot;&#125;</code></li>
<li>登入用戶：<code>&#123;&quot;Authorization&quot;, &quot;Bearer &#123;&#123;Access Token&#125;&#125;&quot;&#125;</code></li>
</ul>
<p>使用匿名上傳的圖片不會出現在自己帳戶底下，一定得記住 response 給的網址，遺失了就找不到這張圖。</p>
<p>使用登入用戶來上傳圖片較可靠，也可以指定自己帳戶內的相簿來分類。</p>
<h3 id="上傳圖片"><a href="#上傳圖片" class="headerlink" title="上傳圖片"></a>上傳圖片</h3><p>上傳圖片的 API 可以參考 <a href="https://apidocs.imgur.com/#de179b6a-3eda-4406-a8d7-1fb06c17cb9c">官方文件的 Image</a>。</p>
<p>文件寫的路徑是 <code>https://api.imgur.com/3/upload</code><br>範例程式碼卻是 <code>https://api.imgur.com/3/image</code><br>實測目前兩個都可以用….</p>
<p>官方範例程式 headers 都是使用匿名，建議替換成 Access Token。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// axios 的範例（官網也有 fetch、jquery 和 XMLHttpRequest 版本）</span></span><br><span class="line"><span class="keyword">const</span> data = <span class="keyword">new</span> FormData();</span><br><span class="line">data.append(<span class="string">&#x27;image&#x27;</span>, <span class="string">&#x27;R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;https://api.imgur.com/3/upload&#x27;</span>,</span><br><span class="line">  <span class="attr">headers</span>: &#123; </span><br><span class="line">     <span class="comment">// 具名 (2選1)</span></span><br><span class="line">    <span class="string">&#x27;Authorization&#x27;</span>: <span class="string">&#x27;Bearer &#123;&#123;Access Token&#125;&#125;&#x27;</span>,</span><br><span class="line">     <span class="comment">// 匿名 (2選1)</span></span><br><span class="line">    <span class="string">&#x27;Authorization&#x27;</span>: <span class="string">&#x27;Client-ID &#123;&#123;clientId&#125;&#125;&#x27;</span>, </span><br><span class="line">    ...data.getHeaders()</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">data</span> : data</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">axios(config)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(response.data));</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="上傳圖片到指定相簿"><a href="#上傳圖片到指定相簿" class="headerlink" title="上傳圖片到指定相簿"></a>上傳圖片到指定相簿</h3><p>上傳圖片到指定相簿需要有相簿的 Hash，可以透過 API 建立相簿（官方網站抓的那包 Postman collection 有所有的 API），或是用網頁操作，流程如下：</p>
<ol>
<li>登入 imgur 網頁。</li>
<li>進入 images 頁面新增一個要上傳的相簿。</li>
<li>點選右上選單，選擇 posts (或是直接點頭像也會到 posts)<br><img data-src="https://i.imgur.com/7UiBxk4.png"></li>
<li>在 posts 列表中點選要上傳的相簿。</li>
<li>網址會變成 <code>https://imgur.com/a/xxxxxxx</code>，其中 xxxxxxx 就是相簿的專屬 Hash</li>
</ol>
<p>取得 Hash 後使用在 FormData 裡面加入即可。<br>（Authentication 需要傳 Access Token 才有權限）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data.append(<span class="string">&#x27;album&#x27;</span>, <span class="string">&#x27;xxxxxxx&#x27;</span>)</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>Imgur</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title>[心得] 六角學院 JS 工程師養成直播班 - 學習心得</title>
    <url>/2021/12/21/EXPhexschoolJSlive/</url>
    <content><![CDATA[<p><img data-src="/images/hexschool-livejs.png"></p>
<span id="more"></span> 

<p>過去參加過各種『ｏｏ電腦』的實體課程，也在各種平台買了很多線上課程，最近第一次參加了線上直播班課程，以下就來分享課程內容和學習心得。</p>
<h2 id="💎-課程內容"><a href="#💎-課程內容" class="headerlink" title="💎 課程內容"></a>💎 課程內容</h2><ul>
<li>課程名稱：JS 工程師養成直播班 - 2021秋季</li>
<li>授課時間：每週直播一次約 2 小時，共 9 週</li>
<li>授課內容：JavaScript 從零開始 -&gt; 串接 API 製作前、後台功能</li>
<li>其他服務：<ul>
<li>每日練習任務、每週主線任務，並有課程助教協助任務批改及建議</li>
<li>週二加開主線任務講解直播</li>
<li>週三、四不定期主題直播</li>
<li>社群平台提供線上諮詢、履歷檢查…等，想問什麼就問什麼</li>
</ul>
</li>
</ul>
<h2 id="💎-課程比較"><a href="#💎-課程比較" class="headerlink" title="💎 課程比較"></a>💎 課程比較</h2><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">實體課程</th>
<th align="center">線上課程</th>
<th align="center">直播班</th>
</tr>
</thead>
<tbody><tr>
<td align="center">價格</td>
<td align="center">高</td>
<td align="center">低</td>
<td align="center">中</td>
</tr>
<tr>
<td align="center">課程編排</td>
<td align="center">緊湊</td>
<td align="center">考驗自制力</td>
<td align="center">每週搭配練習循序漸進</td>
</tr>
<tr>
<td align="center">課後服務</td>
<td align="center">大概就完課證書？</td>
<td align="center">透過課程平台與開課導師互動</td>
<td align="center">有專屬社群和助教團可詢問</td>
</tr>
<tr>
<td align="center">學員交流</td>
<td align="center">很少</td>
<td align="center">趨近０</td>
<td align="center">校長、助教團 + 一堆同學互助</td>
</tr>
<tr>
<td align="center">學習效率</td>
<td align="center">需要天份，跟不上進度就GG</td>
<td align="center">考驗自制力與學習能力</td>
<td align="center">只要有網路就可以問到懂為止</td>
</tr>
</tbody></table>
<h2 id="💎-學習心得"><a href="#💎-學習心得" class="headerlink" title="💎 學習心得"></a>💎 學習心得</h2><h3 id="個人背景"><a href="#個人背景" class="headerlink" title="個人背景"></a>個人背景</h3><p>我是剛退伍的職業軍人，過去負責維護單位機房、伺服器和網站…等等，有開發 ASP.NET 內部網站也自學撰寫 HTML、CSS、JS 一段時間，會選擇上這門課是過去一直都使用較舊的技術開發網站（沒有API、框架…等），想透過這堂課強化基礎能力，並了解前端工程師在實務上的工作。</p>
<h3 id="課程心得"><a href="#課程心得" class="headerlink" title="課程心得"></a>課程心得</h3><p>六角學院的這堂直播課雖然課程規劃是從０開始，但是不得不佩服他們的專業，考量到上課的同學程度不同，安排了課後筆記、學員分組討論２個內容，雖然直播課的內容對我來說已經熟悉，但是這兩個內容讓我學到了不少。</p>
<ul>
<li><p>課後筆記：題目都是許多 JavaScript 需要釐清的基本觀念，撰寫筆記的過程需要閱讀大量相關文章，再歸納出自己的脈絡，嘗試寫成別人也能理解的文章，這個學習過程會比看一些 JS tricky 的影片更加有效。</p>
</li>
<li><p>學員分組討論：分組的同學中大家的程度不一樣，可以透過小組討論互相學習，也可以在檢視同學的問題時，充當偽助教試著去了解別人的程式碼並給予建議，如果有好的寫法也可以藉機學習新招式。</p>
</li>
</ul>
<p>過去上的一些實體課程，通常到上完後也不會和同學有任何互動，即使有熱心的同學開群組，也只是分享一些教材，完課後也成了廢群，更不用說線上課程就只是自己看看影片，哪來的同學？</p>
<p>六角學院有龐大的社群服務，雖然一開始真的有點摸不著頭緒（有舊的 udemy 課程、新的課程網站、Discord、Slack、Email信件、HackMD…），但是有把 Slack 當 FB、IG 在滑的校長、<del>被迫</del>輪班的助教群和大量的同學可以諮詢交流，這絕對是 CP 爆表的超值服務。</p>
<p>除此之外，每週主線任務的提交平台，可以看到其他同學的作品，不用再擔心卡住時找不到 Code 可以參考，相同的程式從每個人手中寫出來都是不同的樣貌，除了學習該怎麼寫出功能，還可以學習如何寫出讓人容易看懂的程式碼。</p>
<p>最後，要特別提的就是老師大力推廣的 Kata 挑戰，這是第一次遇到課程特別針對撰寫速度要求學生練習的，再結合社群分享，可以看到同學的各種騷操作，可以說速寫又是另一個世界了！</p>
<p>如果看這篇文章的你，正打算轉職前端工程師，或是學習前端技能中卻找不到方向，都非常推薦來參加直播班，這不僅僅是一套學習課程，而是給你一個完整的學習環境。</p>
<blockquote>
<p>課程網站：<br><a href="https://www.hexschool.com/">六角學院</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Course Experience</category>
      </categories>
      <tags>
        <tag>Experience</tag>
      </tags>
  </entry>
  <entry>
    <title>[JS] 參數傳遞方式 Call by what?</title>
    <url>/2021/11/17/JScallby/</url>
    <content><![CDATA[<p><img data-src="/images/js-callby.png"></p>
<span id="more"></span> 
<p>在探討參數傳遞的機制前，先了解一點基本的計算機觀念，電腦中的資料需要有個空間存放起來，才能被拿出來操作（運算），這存放的地方就是『記憶體』，平常會聽到電腦的記憶體有 4G、8G…等，資料不會一次佈滿整個記憶體空間，記憶體會切成許多小區塊（位置）來使用，一般在探討時會用類似 <code>0x01</code>、<code>0x02</code>… 這樣的方法來表示記憶體位置（並非實際記憶體使用位置）。</p>
<hr>
<h2 id="💎-資料型別"><a href="#💎-資料型別" class="headerlink" title="💎 資料型別"></a>💎 資料型別</h2><p>JavaScript 的資料型別分成<code>原始型別</code>和<code>物件型別</code>兩類，兩種型別的傳遞方式有所不同，下個段落繼續說明：</p>
<ul>
<li>原始型別（Primitives）：string, number, boolean, null, undefined, symbol</li>
<li>物件型別（Object）：object, array, function…等都屬於物件型別</li>
</ul>
<blockquote>
<p>詳細說明可以參考我的另一篇文章： <a href="https://stark920.github.io/2021/11/19/JScoercion">[JS] 深入了解型別與轉型</a></p>
</blockquote>
<hr>
<h2 id="💎-差異比較"><a href="#💎-差異比較" class="headerlink" title="💎 差異比較"></a>💎 差異比較</h2><h3 id="🔸-比較運算"><a href="#🔸-比較運算" class="headerlink" title="🔸 比較運算"></a>🔸 比較運算</h3><ul>
<li><p>先看一段簡單的程式碼，使用 <code>基本型別</code> 做相等的比較運算</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let a = 1;</span><br><span class="line">let b = 1;</span><br><span class="line">console.log(a === b); // true</span><br></pre></td></tr></table></figure>
<p>沒意外的結果是 true，記憶體的使用會像下圖：<br><img data-src="https://static.coderbridge.com/img/stark920/8f804e92af4d4299bb01a03c1c0db8fe.png"></p>
<center><small>在一個記憶體存放值，變數名稱 a 指向這個值的記憶體位置</small></center></li>
<li><p>接著改成 <code>物件型別</code> 進行比較</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let obj1 = &#123;a: 1&#125;;</span><br><span class="line">let obj2 = &#123;a: 1&#125;;</span><br><span class="line">console.log(a === b); // false</span><br></pre></td></tr></table></figure>
<p>結果卻變成 false 了，此時記憶體的使用情況變成下圖：<br><img data-src="https://static.coderbridge.com/img/stark920/cfd22c95b0984e4f8100cba3475126b5.png"></p>
<center><small>變數裡面存放了一個指向物件實體的記憶體位置，所以這兩個變數的內容實際是不同的記憶體位置，比較的結果是不相等</small></center></li>
</ul>
<hr>
<h3 id="🔸-拷貝變數"><a href="#🔸-拷貝變數" class="headerlink" title="🔸 拷貝變數"></a>🔸 拷貝變數</h3><ul>
<li><p><code>基本型別</code> 範例程式：將 c 的資料賦予到變數 d，再改變 c 的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let c = 1;</span><br><span class="line">let d = c;</span><br><span class="line">c = 2;</span><br><span class="line"></span><br><span class="line">console.log(c); // 2</span><br><span class="line">console.log(d); // 1</span><br></pre></td></tr></table></figure>
<p>c 的值修改之後， d 沒有同時變動，由此可知 c 的值被『複製』給 d 了，兩個變數指向不同的記憶體位置，這時候記憶體的變化如下圖：</p>
<p><img data-src="https://static.coderbridge.com/img/stark920/31c26d8272ee4121861f06dac62773c2.png"></p>
</li>
<li><p>使用 <code>物件型別</code> 來做相同的操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let obj1 = &#123;a: 1&#125;;</span><br><span class="line">let obj2 = obj1;</span><br><span class="line">obj1.a = 2;</span><br><span class="line"></span><br><span class="line">console.log(obj1); // &#123;a: 2&#125;</span><br><span class="line">console.log(obj2); // &#123;a: 2&#125;</span><br><span class="line">console.log(obj1 === obj2); // true</span><br></pre></td></tr></table></figure>
<p>修改第一個物件變數的內容，第二個物件變數也跟著變動了，表示兩個物件變數都指向同一個記憶體位置，用比較運算也得到相等的結果，如下圖：</p>
<p><img data-src="https://static.coderbridge.com/img/stark920/e290304dab504fc2918d0e2fac624498.png"></p>
</li>
</ul>
<hr>
<h2 id="💎-段落小結"><a href="#💎-段落小結" class="headerlink" title="💎 段落小結"></a>💎 段落小結</h2><ul>
<li><p><code>基本型別</code>是純粹的『值』，這個值是靜態的、不可變的（immutable），在傳遞時會以新的記憶體空間來存放新的（或複製來的）資料，這種參數傳遞模式通常被稱為<code>傳值（call by value）</code>。</p>
</li>
<li><p><code>物件型別</code>的資料是動態的、可變的（mutable），變數內會存放一個記憶體位置指向物件的本體，就像是這個物件的經紀人一樣；因此，做賦值運算時只會取得這個記憶體位置，而不是物件實體，這種複製方式又稱為淺拷貝，而參數傳遞模式通常被稱為<code>傳參考（call by reference）</code>。</p>
</li>
</ul>
<blockquote>
<p>延伸閱讀： <a href="https://medium.com/andy-blog/%E9%97%9C%E6%96%BCjs%E4%B8%AD%E7%9A%84%E6%B7%BA%E6%8B%B7%E8%B2%9D-shallow-copy-%E4%BB%A5%E5%8F%8A%E6%B7%B1%E6%8B%B7%E8%B2%9D-deep-copy-5f5bbe96c122">Andy - 關於JS中的淺拷貝(shallow copy)以及深拷貝(deep copy)</a></p>
</blockquote>
<hr>
<h2 id="💎-Call-by-sharing"><a href="#💎-Call-by-sharing" class="headerlink" title="💎 Call by sharing?"></a>💎 Call by sharing?</h2><ul>
<li><p>如果仔細看會發現上一個段落名稱是<code>段落小結</code>，沒錯，事情還沒結束！接著來看下面這段程式碼，並想想結果會印出什麼？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function share(obj) &#123;</span><br><span class="line">  obj.a = 2;</span><br><span class="line">  obj = &#123; b: 3 &#125;;</span><br><span class="line">  return obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let objA = &#123; a: 1 &#125;;</span><br><span class="line">let objB = share(objA);</span><br><span class="line"></span><br><span class="line">console.log(objA); // &#123; a: 2 &#125;</span><br><span class="line">console.log(objB); // &#123; b: 3 &#125;</span><br></pre></td></tr></table></figure>
<p>以物件傳參考的邏輯來看，objA 裡面存的記憶體位置會傳入函式，在 <code>obj.a = 2</code> 這段也確實透過傳入的位址成功修改 objA 物件內的值。</p>
<p>到了 <code>obj = &#123; b: 3 &#125;</code> 這段卻沒有改變原始的物件（objA)，而是以傳值的方式進行，新增了一個記憶體位置存放物件，再透過 return 回傳給 objB。</p>
<p><code>函式</code>會依傳入的參數型別有所不同（基本型別傳值、物件型別傳參考），但是對參數做<code>賦值運算時（=）</code>，就會<code>指向新的記憶體位置</code>，這種模式常被稱為 <code>call by sharing</code>。</p>
</li>
</ul>
<hr>
<h2 id="💎-總結"><a href="#💎-總結" class="headerlink" title="💎 總結"></a>💎 總結</h2><ul>
<li>JavaScript 並沒有正式文件去定義該怎麼稱呼這些資料傳遞方式，無論是 call by value、reference 或 sharing，亦或是要說 call by 還是 pass by 其實並沒有這麼重要，最重要的是了解 JavaScript 在處理資料時有什麼不同的機制，讓我們在撰寫時不要踩坑，才是實際又有幫助的。</li>
</ul>
<blockquote>
<p>參考資料： <a href="https://blog.techbridge.cc/2018/06/23/javascript-call-by-value-or-reference/">Huli - 深入探討 JavaScript 中的參數傳遞：call by value 還是 reference？</a></p>
</blockquote>
<hr>
<p>以上是我對這參數傳遞的一點認知，如有錯誤或是補充的知識點，也歡迎大家不吝指教，謝謝！</p>
]]></content>
      <categories>
        <category>JavaScript - Basic</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>[JS] 從 Event Loop 到 Callback function，一堆名詞講的是什麼？</title>
    <url>/2022/04/17/JScallback/</url>
    <content><![CDATA[<p><img data-src="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/EventLoop/the_javascript_runtime_environment_example.svg"></p>
<blockquote>
<p>圖片來源：<a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/EventLoop">MDN - 並行模型和事件循環</a></p>
</blockquote>
<span id="more"></span>

<hr>
<h2 id="事件循環（event-loop）"><a href="#事件循環（event-loop）" class="headerlink" title="事件循環（event loop）"></a>事件循環（event loop）</h2><p>JavaScript 是單執行緒的語言，一次只能做一件事，遇到需要花費大量時間的程式時，後面的程式就會全部卡住。</p>
<p>舉例來說，去超商提款機領錢，前面的人換了無數張卡片，一陣操作十幾分鐘過去，但是超商就只有一台提款機，只能在後面慢慢等他用完。</p>
<p>為了減少這種排隊窘境，瀏覽器執行時會讓順順跑的排一列、費時的移到另一列等待，順跑的一列出現空檔時，再把另一列排隊的項目抓回來執行。</p>
<p>我非常推薦先觀看下方影片來了解事件循環的運作，會比文字和圖片解釋更加容易理解：</p>
<div class="video-container"><iframe src="https://www.youtube.com/embed/8aGhZQkoFbQ" frameborder="0" loading="lazy" allowfullscreen></iframe></div>

<blockquote>
<p>影片講者的事件循環模擬器：<a href="http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4=">連結</a></p>
</blockquote>
<hr>
<h2 id="名詞解釋"><a href="#名詞解釋" class="headerlink" title="名詞解釋"></a>名詞解釋</h2><p>看完上面的影片，我們可以快速了解事件循環的流程，以下歸納幾個名詞代表的意思：</p>
<ul>
<li>同步的 JavaScript（Synchronous）：瀏覽器執行多數的程式碼都是同步的，收到就立刻執行。</li>
<li>非同步的 JavaScript（Asynchronous）：許多無法立即完成的程式會交由瀏覽器的 Web APIs 來處理，最常見的情況就是取得外部資料。</li>
<li>Web APIs：瀏覽器中提供的應用（例如：抓 api 資料、等待幾秒…等）。</li>
<li>Stack (Call Stack）：同步執行的程式片段，會以堆疊方式執行（先進後出）。</li>
<li>Queue（Callback Queue / Task Queue）：非同步執行的程式片段會交給 Web APIs 處理，完成後進入佇列中等待執行（先進先出）。</li>
</ul>
<hr>
<h2 id="Callback-Function"><a href="#Callback-Function" class="headerlink" title="Callback Function"></a>Callback Function</h2><p>經過 Web APIs 處理完的非同步程式會進入 Queue 等待，當 Stack 沒有執行中的程式時，就會抓取 Queue 中等待執行的程式回來執行，這個回頭做的動作就是 Callback (回呼)，所以非同步執行後回頭做的函式就是 Callback Function ? 意思大概到了，但不完全是。</p>
<p>在 MDN 中說明回呼函式（Callback Function）指的是<code>把函式作為參數，提供另一個函式使用</code>，用這種方式設計出來的函式可以是同步和非同步的，但通常都是用來處理非同步的程式。</p>
<p>非同步的完成時間通常是難以預測的，舉例來說，要取得一個外部資源，會因為網路速度、檔案大小讓完成時間都不相同，當有多個非同步程式執行，我們無法知道哪一個會先完成，回呼函式的設計就是要<code>確保函式執行的先後順序</code>。</p>
<hr>
<h2 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h2><p>學習 JavaScript 時進入非同步的章節通常第一個學的就是 setTimeout，可以指定一段時間後再執行別的程式碼，在 <a href="https://www.w3schools.com/jsref/met_win_settimeout.asp">W3schools</a> 可以看到 setTimeout 傳入參數的格式：</p>
<p><code>setTimeout(function, milliseconds, param1, param2, ...)</code></p>
<p><strong>第一個參數是函式</strong>、第二個是間隔的時間、第三個以後是可以選擇要額外傳入的參數。</p>
<p>第一個參數正好符合了「把函式作為參數，提供另一個函式使用」，也就是說這是一個 <code>Callback Function</code>，而 setTimeout 的功能正式讓傳入的回呼函式在指定的時間後再執行。</p>
<p>接下來的段落，會透過設計情境來說明如何設計和應用 Callback Function。</p>
<hr>
<h2 id="設計情境"><a href="#設計情境" class="headerlink" title="設計情境"></a>設計情境</h2><p>有點年紀的朋友們（？應該都聽過企鵝的笑話，每天的活動是「吃飯、睡覺、打東東」，以此為題設計一個每日工作的程式碼會像下面這樣：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 吃飯</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eat</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;吃飽了&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 睡覺</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;睡飽了&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打東東</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hitDongDong</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;打爽了&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每日工作：裡面執行每個活動的函式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dailyWorks</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;今日完成事項：&#x27;</span>);</span><br><span class="line">  eat();</span><br><span class="line">  sleep();</span><br><span class="line">  hitDongDong();</span><br><span class="line">&#125;</span><br><span class="line">dailyWorks();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*---輸出結果---*/</span></span><br><span class="line"><span class="comment">/*------------*/</span></span><br><span class="line"><span class="comment">// 今日完成事項：</span></span><br><span class="line"><span class="comment">// 吃飽了</span></span><br><span class="line"><span class="comment">// 睡飽了</span></span><br><span class="line"><span class="comment">// 打爽了</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="同步回呼函式"><a href="#同步回呼函式" class="headerlink" title="同步回呼函式"></a>同步回呼函式</h2><p>上面的函式設計上沒有彈性，不同的企鵝除了打東東之外也會做其他的事情，我們增加一個參數來接收要做的事情（函式），改寫後如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 除了「吃飯、睡覺、打東東」外可以自由設計各種活動函式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">moreActivity</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dailyWorks</span>(<span class="params">...activities</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;今日完成事項：&#x27;</span>);</span><br><span class="line">  activities.forEach(<span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 執行前先檢查是否為函式</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn === <span class="string">&#x27;function&#x27;</span>) fn();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">dailyWorks(eat, sleep, hitDongDong, moreActivity);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*---輸出結果---*/</span></span><br><span class="line"><span class="comment">/*------------*/</span></span><br><span class="line"><span class="comment">// 今日完成事項：</span></span><br><span class="line"><span class="comment">// 吃飽了</span></span><br><span class="line"><span class="comment">// 睡飽了</span></span><br><span class="line"><span class="comment">// 打爽了</span></span><br><span class="line"><span class="comment">// ( 自行加入的各種活動....)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>上面的程式碼中，在 dailyWorks 這個主要函式中增加 activities 參數（參數名稱可以自定），用來接收要執行的函式。</p>
</li>
<li><p>運用其餘運算符（…）來接收更多的函式，就可以在執行 dailyWorks 函式時自由的替換或傳入更多的函式。</p>
</li>
<li><p>因為傳入的函式都是同步執行，是「同步回呼函式」，哪個先傳入就先執行，沒有非同步的順序問題。</p>
</li>
</ul>
<hr>
<h2 id="非同步回呼函式"><a href="#非同步回呼函式" class="headerlink" title="非同步回呼函式"></a>非同步回呼函式</h2><p>問題又來了，企鵝哪有那麼神，可以一瞬間做那麼多事情？接著就讓每件工作加入一點執行時間。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eat</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;吃飽了&#x27;</span>), <span class="number">2000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;睡飽了&#x27;</span>), <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hitDongDong</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;打爽了&#x27;</span>), <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dailyWorks</span>(<span class="params">...activities</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;今日完成事項：&#x27;</span>);</span><br><span class="line">  activities.forEach(<span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn === <span class="string">&#x27;function&#x27;</span>) fn();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">dailyWorks(eat, sleep, hitDongDong);</span><br></pre></td></tr></table></figure>

<p>完成修改後，請問上面這段程式碼的執行結果？</p>
<ul>
<li>(A) 印出「今日完成事項：」、2 秒後印出「吃飽了」、第 3 秒印出「睡飽了」、第 4 秒印出「打爽了」</li>
<li>(B) 印出「今日完成事項：」、1 秒後同時印出「睡飽了」和「打爽了」、 第 2 秒印出「吃飽了」</li>
</ul>
<p>如果你的答案是 (A)，請試著把這段程式碼的執行流程用 stack、WebAPIs、queue 的方式畫出來。</p>
<p>雖然我們把傳入的函式修改成「非同步回呼函式」，但是傳入的函式都屬於主要函式（dailyWorks）的回呼函式，彼此間沒有 callback 的關係，整個程式的執行順序是：</p>
<ol>
<li>主要函式的 <code>console.log(&#39;今日完成事項：&#39;)</code></li>
<li>傳入的三個函式都進入 WebAPIs 執行，「睡飽了」和「打爽了」都在一秒後執行完，回到 queue，再被取回 stack 執行，而「吃飽了」在兩秒後才完成進入 queue，再被取回 stack 執行。</li>
</ol>
<p>如果要讓這些非同步函式能夠一個完成再執行下一個（one by one），可以再做以下修改：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eat</span>(<span class="params">activity</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;吃飽了&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> activity === <span class="string">&#x27;function&#x27;</span>) activity();</span><br><span class="line">  &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">activity</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;睡飽了&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> activity === <span class="string">&#x27;function&#x27;</span>) activity();</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hitDongDong</span>(<span class="params">activity</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;打爽了&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> activity === <span class="string">&#x27;function&#x27;</span>) activity();</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dailyWorks</span>(<span class="params">activity</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;今日完成事項：&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> activity === <span class="string">&#x27;function&#x27;</span>) activity();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dailyWorks(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  eat(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    sleep(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      hitDongDong(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 繼續延伸下去............</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>修改後的程式碼，讓每個活動函式都可以傳入 callback function，這樣就會依照順序，一個執行完再接下一個。</p>
<p>為了確保執行的順序，必須以巢狀的方式撰寫，當程式碼變得複雜時，傳說中的 Callback Hell（回呼地獄）就會誕生，雖然這不是電腦執行程式的問題，但是對於人類閱讀會有很大的障礙。</p>
<p><img data-src="https://miro.medium.com/max/1400/1*zxx4iQAG4HilOIQqDKpxJw.jpeg"></p>
<blockquote>
<p>圖片來源：<a href="https://medium.com/@quyetvv/async-flow-from-callback-hell-to-promise-to-async-await-2da3ecfff997">Async Flow: From callback hell to promise to Async-Await</a></p>
</blockquote>
<hr>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>Callback function 歷史悠久，這也表示 Callback hell 荼毒了很長一段時間，直到 ES6（2015）的 Promise 和 ES8（2017）的 async/await 才有較簡潔的撰寫方法，儘管學習新方法可以縮短許多時間，但是 Event loop 的流程和 Callback function 的撰寫方式都是重要的基本功，花點時間弄清楚對於撰寫非同步程式會非常有幫助。</p>
<blockquote>
<p>參考資料：<br><a href="https://developer.mozilla.org/zh-TW/docs/Glossary/Callback_function">MDN - 回呼函式</a> 、 <a href="https://ithelp.ithome.com.tw/articles/10192739">Kuro - 重新認識 JavaScript: Day 18 Callback Function 與 IIFE</a></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript - Basic</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>[JS] for、for...in、forEach、for...of 的差別</title>
    <url>/2022/04/23/JSforloop/</url>
    <content><![CDATA[<p>JavaScript 的 for 迴圈有好幾種用法，這次來研究其中的差異。</p>
<span id="more"></span>

<hr>
<h2 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h2><p>本篇文章的範例程式碼都會以下列的物件、陣列為範例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通陣列</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 帶有空值的陣列</span></span><br><span class="line"><span class="keyword">const</span> arrWithEmpty = [<span class="number">1</span>, , <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 帶有物件屬性的陣列（陣列本身還是物件，所以具有物件的特性）</span></span><br><span class="line"><span class="keyword">const</span> arrWithAttr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arrWithAttr.a = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 物件</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">c</span>: <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="普通陣列"><a href="#普通陣列" class="headerlink" title="普通陣列"></a>普通陣列</h2><ol>
<li><p>for</p>
<ul>
<li><p>for 是最基本的迴圈寫法，透過陣列的索引（index）取值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; ++i) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li>
<li><p>for 可以自行設定迴圈執行的區間，也可以用 break 來中斷。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; arr.length - <span class="number">1</span>; i += <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arr[i]);</span><br><span class="line">  <span class="keyword">if</span> (arr[i] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>for…in</p>
<ul>
<li><p>for…in 與 for 都是以索引值來造訪陣列。</p>
</li>
<li><p>for…in 可以用 break 來中斷，但是不能設定開始與結束的索引值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arr[i]);</span><br><span class="line">  <span class="keyword">if</span> (arr[i] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>forEach</p>
<ul>
<li><p>forEach 是陣列方法，預設的第一個參數會取得陣列的值。</p>
</li>
<li><p>forEach 不能被中斷、也不能設定開始與結束的索引值。</p>
</li>
<li><p>類陣列（Array-like）不一定有 forEach 的方法（NodeList 有、Arguments 沒有）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li>
<li><p>forEach 可以選擇性的加上第 2、3 個參數來取得索引值和原始陣列。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.forEach(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;item&#125;</span>, <span class="subst">$&#123;index&#125;</span>, <span class="subst">$&#123;array&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// 1, 0, 1,2,3</span></span><br><span class="line"><span class="comment">// 2, 1, 1,2,3</span></span><br><span class="line"><span class="comment">// 3, 2, 1,2,3</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>for…of</p>
<ul>
<li><p>for…of 直接取得陣列的值，沒有索引值。</p>
</li>
<li><p>for…of 可以用 break 來中斷，但是不能設定開始與結束的索引值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">  <span class="keyword">if</span> (item &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用 for…of 取得索引值需要先使用 entries 方法產生迭代器物件（iterator）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [index, item] <span class="keyword">of</span> arr.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;index&#125;</span>, <span class="subst">$&#123;item&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// 0, 1</span></span><br><span class="line"><span class="comment">// 1, 2</span></span><br><span class="line"><span class="comment">// 2, 3</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<h2 id="帶有空值的陣列"><a href="#帶有空值的陣列" class="headerlink" title="帶有空值的陣列"></a>帶有空值的陣列</h2><ul>
<li><p>for 遇到空值會回傳 undefined。</p>
</li>
<li><p>for…in 遇到空值會跳過。</p>
</li>
<li><p>forEach 遇到空值會跳過。</p>
</li>
<li><p>for…of 遇到空值會回傳 undefined。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arrWithEmpty.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arrWithEmpty[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> arrWithEmpty) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arrWithEmpty[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">arrWithEmpty.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> arrWithEmpty) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="帶有物件屬性的陣列"><a href="#帶有物件屬性的陣列" class="headerlink" title="帶有物件屬性的陣列"></a>帶有物件屬性的陣列</h2><ul>
<li><p>for 不會取得屬性的值</p>
</li>
<li><p><code>for...in 會取得屬性的值</code></p>
</li>
<li><p>forEach 不會取得屬性的值</p>
</li>
<li><p>for…of 不會取得屬性的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arrWithAttr.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arrWithAttr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> arrWithAttr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arrWithAttr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"></span><br><span class="line">arrWithAttr.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> arrWithAttr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="物件"><a href="#物件" class="headerlink" title="物件"></a>物件</h2><ul>
<li><p>for 無法直接操作物件，需要先產生迭代器物件（iterator）。</p>
</li>
<li><p><code>for...in 可以取得物件的 key</code>。</p>
</li>
<li><p>forEach 無法直接操作物件，需要先產生迭代器物件（iterator）。</p>
</li>
<li><p>for…of 無法直接操作物件，需要先產生迭代器物件（iterator）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> objKeys = <span class="built_in">Object</span>.keys(obj);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; objKeys.length; i += <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(obj[objKeys[i]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"><span class="comment">// c</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(obj).forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(obj[item]);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> <span class="built_in">Object</span>.values(obj)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="其他補充"><a href="#其他補充" class="headerlink" title="其他補充"></a>其他補充</h2><ol>
<li>使用 for、for…in、for…of 時，<code>請勿使用 var</code> 來宣告裡面的變數（早期的文章都會使用 var，因為那個時候只有 var），請使用 let 或 const 來避免污染全域環境。</li>
<li>Vue 的 v-for 撰寫範例通常都是 <code>v-for=&quot;item in items</code>，但 <a href="https://vuejs.org/guide/essentials/list.html#v-for">官方文件</a> 裡面有寫到可以使用 <code>v-for=&quot;item of items</code> 來撰寫，這會更貼近 JavaScript 迭代的語法。</li>
<li>forEach 方法會傳入一個 callback function，如果使用箭頭函式會有 this 指向的問題需要注意。</li>
<li>forEach 不適合搭配非同步使用，forEach 不會等待非同步完成才進入下一個循環，會以同步的方式執行所有內容，使用 for、for…in、for…of 搭配 async、await 較佳。</li>
</ol>
<hr>
<blockquote>
<p>參考文章：</p>
<ul>
<li><a href="https://thecodebarbarian.com/for-vs-for-each-vs-for-in-vs-for-of-in-javascript">For vs forEach() vs for/in vs for/of in JavaScript</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript - Basic</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>[JS] 提昇（Hoisting）機制</title>
    <url>/2021/11/23/JShoisting/</url>
    <content><![CDATA[<p><img data-src="/images/js-hoisting.png"></p>
<span id="more"></span> 
<p>如果今天想要使用電腦，該怎麼做？</p>
<p>你的答案很可能是，按下電腦開機鍵就好，但實際上得先有主機、滑鼠、鍵盤、螢幕、電源、作業系統…等軟、硬體環境，才有辦法使用電腦。</p>
<p>JavaScript 雖然是直譯式語言（不需透過編譯器轉譯成可執行檔），但是『執行』之前，還是需要先把原本字元組成的程式碼編譯成執行環境（就像是上面提到的準備滑鼠、鍵盤…等等），而其中一個步驟就是先將 <code>變數</code> 和 <code>函數</code> 的名稱放入記憶體，這種行為在 ECMA 的文件中沒有明確定義專有名詞，一般會用 <code>提昇（Hoisting）</code>來稱呼。</p>
<blockquote>
<p>參考文章：<br><a href="https://developer.mozilla.org/zh-TW/docs/Glossary/Hoisting">MDN - 提升（Hoisting）</a></p>
</blockquote>
<hr>
<p>提昇（Hoisting）的方式會因為變數類型有所不同：</p>
<h2 id="💎-var、function："><a href="#💎-var、function：" class="headerlink" title="💎 var、function："></a>💎 var、function：</h2><p>按照逐行執行的邏輯，下面前兩行程式碼會因為還沒有產生這個變數而出現錯誤，但實際上並不會出現任何錯誤。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(a); // undefined</span><br><span class="line">console.log(foo); // foo()&#123;return &#x27;Hello&#x27;;&#125;</span><br><span class="line"></span><br><span class="line">var a;</span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">  return &#x27;Hello&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>從結果回推實際執行的順序會像下面這樣：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a;</span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">  return &#x27;Hello&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(a);</span><br><span class="line">console.log(foo);</span><br></pre></td></tr></table></figure>

<p>這次做小調整，改成賦予 a 變數一個值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(a); // undefined</span><br><span class="line">var a = 1;</span><br><span class="line">console.log(a); // 1</span><br></pre></td></tr></table></figure>

<p>雖然沒有出現錯誤，但是 a 的值並沒有跟著被提昇，回推的執行順序會像下面這樣：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a</span><br><span class="line">console.log(a); // undefined</span><br><span class="line">a = 1;</span><br><span class="line">console.log(a); // 1</span><br></pre></td></tr></table></figure>

<p>再看下面這段程式碼，想想看結果是什麼：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var b = 1;</span><br><span class="line">var b;</span><br><span class="line">console.log(b);</span><br></pre></td></tr></table></figure>

<p>如果不清楚運作 JavaScript 的運作機制，可能會認為答案是 <code>undefined</code>，覺得後者蓋掉前者，但答案其實是 <code>1</code>，回推後的實際執行會像是下面這樣：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var b;</span><br><span class="line">var b;</span><br><span class="line">b = 1;</span><br><span class="line">console.log(b);</span><br></pre></td></tr></table></figure>

<p>『重複宣告』加上『提昇機制』是不是讓人覺得很坑呢？</p>
<h2 id="💎-let、const："><a href="#💎-let、const：" class="headerlink" title="💎 let、const："></a>💎 let、const：</h2><p>ES6 版本提供了 <code>let</code> 和 <code>const</code> 兩種變數宣告方式，這兩種新的方式解決了 <code>var</code> 的許多奇怪問題。</p>
<p>使用 <code>let</code> 和 <code>const</code> 宣告的變數名稱在 JavaScript 從『環境建立』一直執行到『變數實際存在的那一行程式碼』的這段期間，變數名稱都是無法被取用的，這段期間稱為 Temporal Dead Zone（TDZ），暫時性死區。</p>
<p>這個機制就像是我買了對號座的票（宣告），這個位置的票就不能被其他人購買（不能重複宣告），但是在我坐上車位前（實際執行的那段程式碼），都無法在這個位置找到我（TDZ鎖定）。</p>
<p>以下是使用 <code>let</code> 或 <code>const</code> 宣告的輸出結果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(x); // x is not defined</span><br><span class="line">let x = 1;</span><br><span class="line">console.log(x); // 前面已經因為執行階段出錯終止，不會執行到這裡</span><br></pre></td></tr></table></figure>

<blockquote>
<p>參考文章<br>1、<a href="https://blog.techbridge.cc/2018/11/10/javascript-hoisting/">我知道你懂 hoisting，可是你了解到多深？</a><br>2、<a href="https://eddychang.me/es6-tdz">理解ES6中的暫時死區(TDZ)</a></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript - Basic</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>[JS] 物件與 JSON 格式操作技巧</title>
    <url>/2021/11/22/JSobject/</url>
    <content><![CDATA[<p><img data-src="/images/js-json.png"></p>
<span id="more"></span> 
<p>物件操作和串接 API 是 JavaScript 在現代網頁開發中的精華，這篇就來介紹物件取值的基本方法和小技巧。</p>
<h2 id="💎-物件（Object）"><a href="#💎-物件（Object）" class="headerlink" title="💎 物件（Object）"></a>💎 物件（Object）</h2><h3 id="🔸-基本結構，使用-來存放資料："><a href="#🔸-基本結構，使用-來存放資料：" class="headerlink" title="🔸 基本結構，使用{}來存放資料："></a>🔸 基本結構，使用<code>&#123;&#125;</code>來存放資料：</h3><p>(本篇文章不討論使用 create、new 和 prototype 的操作)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const obj = &#123;&#125; // 空物件</span><br></pre></td></tr></table></figure>

<h3 id="🔸-內容結構是-key-value-pair-的格式："><a href="#🔸-內容結構是-key-value-pair-的格式：" class="headerlink" title="🔸 內容結構是 key/value pair 的格式："></a>🔸 內容結構是 key/value pair 的格式：</h3><ul>
<li>前方的 key 在 JavaScript 中為物件的屬性（property）。</li>
<li>後方的 value 可以是各種型別的值。<br>以下為一個物件範例，接下來的段落都使用這個物件來示範操作。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const obj = &#123;</span><br><span class="line">  a: function()&#123;return &#x27;a&#x27;&#125;,</span><br><span class="line">  b: null,</span><br><span class="line">  c: &#123;</span><br><span class="line">    d: [&#123;e: 2&#125;]</span><br><span class="line">  &#125;,</span><br><span class="line">  1: &#x27;bad&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="🔸-物件取值"><a href="#🔸-物件取值" class="headerlink" title="🔸 物件取值"></a>🔸 物件取值</h3></li>
<li>方法１：<code>objectName.propertyName</code>，使用<code>.</code>加上屬性名稱來取值，如果是多層級的物件，就繼續往下使用<code>.</code>加屬性名稱，使用<code>.</code>時需要遵守變數名稱規範，不然會報錯。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(obj.a); // f ()&#123;return &#x27;a&#x27;&#125;</span><br><span class="line">console.log(obj.a()); // &#x27;a&#x27;</span><br><span class="line">console.log(obj.c.d[0].e); // 2</span><br><span class="line">console.log(obj.1); // Uncaught SyntaxError: Unexpected number</span><br></pre></td></tr></table></figure></li>
<li>方法２：<code>objectName[propertyName or 變數]</code><br>這種方法不受物件屬性名稱限制，並且可以帶入變數，但使用時須注意<code>[]</code>內若不是帶入變數，需要加上<code>&#39;&#39;（引號）</code>，否則找不到變數會報錯。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(obj[&#x27;a&#x27;]]); // f ()&#123;return &#x27;a&#x27;&#125;</span><br><span class="line">console.log(obj[a]); // ReferenceError: a is not defined</span><br><span class="line">console.log(obj[&#x27;c&#x27;].d[0][&#x27;e&#x27;]); // 2  (方式１、2混用)</span><br><span class="line">console.log(obj[&#x27;1&#x27;]); // &#x27;bad&#x27;</span><br><span class="line">let num = 1;</span><br><span class="line">console.log(obj[num]); // &#x27;bad&#x27;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="🔸-物件賦值"><a href="#🔸-物件賦值" class="headerlink" title="🔸 物件賦值"></a>🔸 物件賦值</h3><p>方法同取值，只要加上 <code>=</code> 就能賦值，也可以用新的屬性名稱來新增物件屬性；同樣也能用 <code>.</code> 和 <code>[]</code> 兩種方式操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">obj.a = 1; // 變更原有屬性 a 的值</span><br><span class="line">obj[&#x27;a&#x27;] = 2; // 變更原有屬性 a 的值</span><br><span class="line">obj.f = 0; // 原本沒有屬性 f ，新增屬性 f 且值為 0</span><br></pre></td></tr></table></figure>

<h3 id="🔸-物件取所有屬性"><a href="#🔸-物件取所有屬性" class="headerlink" title="🔸 物件取所有屬性"></a>🔸 物件取所有屬性</h3><p><code>Object.keys()</code> 方法會回傳一個陣列，並列出該物件第一層（直屬於物件）的所有屬性名稱，且這個陣列會由小至大排序。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object.keys(obj); // [&#x27;1&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span><br></pre></td></tr></table></figure>

<h3 id="🔸-物件取所有屬性的值"><a href="#🔸-物件取所有屬性的值" class="headerlink" title="🔸 物件取所有屬性的值"></a>🔸 物件取所有屬性的值</h3><p><code>Object.values()</code> 方法會回傳一個陣列，並列出該物件第一層（直屬於物件）的所有屬性值，且這個陣列會依照屬性名稱由小至大排序。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object.values(obj); // [&#x27;bad&#x27;, ƒ, null, &#123;…&#125;]</span><br></pre></td></tr></table></figure>

<h3 id="🔸-物件轉陣列"><a href="#🔸-物件轉陣列" class="headerlink" title="🔸 物件轉陣列"></a>🔸 物件轉陣列</h3><p><code>Object.entries()</code> 方法會回傳一個陣列，並以二維陣列的方式列出該物件第一層（直屬於物件）的所有屬性和值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object.entries(obj); </span><br><span class="line">// [[&#x27;1&#x27;, &#x27;bad&#x27;],[&#x27;a&#x27;, ƒ], [&#x27;b&#x27;, null], [&#x27;c&#x27;, &#123;…&#125;]]</span><br></pre></td></tr></table></figure>

<h3 id="🔸-物件屬性檢查"><a href="#🔸-物件屬性檢查" class="headerlink" title="🔸 物件屬性檢查"></a>🔸 物件屬性檢查</h3><p>物件陣列的操作很常遇到，當物件資料不完整時，可能會造成執行中斷，這時候就需要先檢查物件的屬性是否存在：</p>
<ul>
<li><p>方法１：檢查該屬性是否為<code>undefined</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(obj.x === undefined); // true</span><br></pre></td></tr></table></figure></li>
<li><p>方法２：使用<code>hasOwnProperty()</code>方法檢查有沒有該屬性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(obj.hasOwnProperty(&#x27;x&#x27;)); // false</span><br></pre></td></tr></table></figure></li>
<li><p>方法３：<strong>推薦</strong>使用<code>Optional chaining operator</code>，只要一個<code>?</code>就能判斷，並且繼續往下取值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(obj?.x)); // undefined</span><br><span class="line">console.log(obj?.c?.d[0]?.e); // 2</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="💎-JSON（JavaScript-Object-Notation）"><a href="#💎-JSON（JavaScript-Object-Notation）" class="headerlink" title="💎 JSON（JavaScript Object Notation）"></a>💎 JSON（JavaScript Object Notation）</h2><p>JSON 是一種通用資料交換格式，許多程式語言都能夠解析並被廣泛使用，通常在串接 api 時都是以 JSON 格式為主，和 JavaScript 的 Object 同樣是 key/value pair 的格式，但是屬性名稱會用引號包起來，範例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;John&quot;,</span><br><span class="line">  &quot;sex&quot;: &quot;male&quot;,</span><br><span class="line">  &quot;age&quot;: 20</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="🔸-解析-JSON-格式資料"><a href="#🔸-解析-JSON-格式資料" class="headerlink" title="🔸 解析 JSON 格式資料"></a>🔸 解析 JSON 格式資料</h3><ul>
<li><code>JSON 的型別是字串</code>，所以需要轉換成物件才能使用，JavaScript 中提供了<code>JSON.parse()</code>的方法來轉換成可以操作的物件。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let data = ...json file...</span><br><span class="line">console.log(JSON.parse(data)); Object&#123;...&#125;</span><br></pre></td></tr></table></figure></li>
<li>過去實作 ajax 功能時使用的 XMLHttpRequest 取得的 json 資料都需要經過轉換才能使用，而現在常用的 <code>Fetch</code>、<code>Axios</code> 已經包裝成物件格式，<code>不需要再轉換</code>。</li>
<li>JavaScript 也提供了<code>JSON.stringify()</code>的方法，可以將物件轉成 JSON 字串格式。</li>
<li>localStorage、sessionStorage 存放資料為字串格式，如果要存放物件時需要先使用<code>JSON.stringify()</code>轉換存入，取出後再使用<code>JSON.parse()</code>轉回物件格式。</li>
</ul>
<blockquote>
<p>參考資料：<br><a href="https://zh.wikipedia.org/wiki/JSON">Wiki-JSON</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object">MDN-Object</a><br><a href="https://pjchender.blogspot.com/2016/01/javascriptobjectjson.html">JavaScript中物件(object)和JSON格式的轉換</a></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript - Basic</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>[JS] 深入了解型別與轉型</title>
    <url>/2021/11/19/JScoercion/</url>
    <content><![CDATA[<p><img data-src="/images/js-coercion.png"></p>
<span id="more"></span> 
<p>JavaScript 不論遇到什麼奇形怪狀的資料運算，都會盡可能讓程式執行下去，這麼貼心的設計也是兩面刃，可能在不知不覺中程式正常運作，也可能突然就報錯了卻毫無頭緒，馬上來認識 JavaScript 的型別系統與轉型吧！</p>
<hr>
<h2 id="💎-型別（type）"><a href="#💎-型別（type）" class="headerlink" title="💎 型別（type）"></a>💎 型別（type）</h2><ul>
<li><p>JavaScript 的型別可以分為『原始型別』和『物件型別』兩類，差異在於：</p>
<ul>
<li>原始型別<code>沒有</code>屬性和方法可以使用</li>
<li>物件型別<code>可以任意存取</code>屬性和方法</li>
</ul>
</li>
<li><p><strong>原始型別（Primitive types）</strong></p>
<ul>
<li>string</li>
<li>number</li>
<li>boolean</li>
<li>null</li>
<li>undefined</li>
<li>symbol (ES 6 新定義)</li>
</ul>
</li>
<li><p><strong>物件型別（Object types）</strong></p>
<ul>
<li>原生物件（Native）<ul>
<li>Object, Array, Function, Date, Math, RegExp</li>
<li>原始型別包裹物件（Primitive Wrapper）：Number, String, Boolean</li>
</ul>
</li>
<li>寄宿物件（Host）<ul>
<li>window</li>
<li>DOM</li>
</ul>
</li>
</ul>
</li>
<li><p>型別檢查（typeof)：<br>除了 null 有原生的 bug 會得到 object 的結果（此 bug 不會修正），其他型別都可以使用 <code>typeof</code> 來檢查。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(typeof &#x27;a&#x27;); // string</span><br><span class="line">console.log(typeof 1); // number</span><br><span class="line">console.log(typeof true); // boolean</span><br><span class="line">console.log(typeof null); // object &lt;== 這是語言本身的bug</span><br><span class="line">console.log(typeof undefined); // undefined</span><br><span class="line">console.log(typeof Symbol()) // symbol</span><br><span class="line">console.log(typeof &#123;&#125;); // object</span><br><span class="line">console.log(typeof []); // object</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="💎-裝箱（boxing）和-拆箱（unboxing）"><a href="#💎-裝箱（boxing）和-拆箱（unboxing）" class="headerlink" title="💎 裝箱（boxing）和 拆箱（unboxing）"></a>💎 裝箱（boxing）和 拆箱（unboxing）</h2><ul>
<li><p>前面提到原始型別是沒有屬性和方法可以使用的，但我們卻可以利用字串方法來修改原始型別的字串（如下方的程式碼），這是因為 JavaScript 有 裝箱（boxing）和 拆箱（unboxing）機制來處理這些操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(&#x27;123.45&#x27;.split(&#x27;.&#x27;));</span><br><span class="line">// [&#x27;123&#x27;, &#x27;45&#x27;]</span><br></pre></td></tr></table></figure></li>
<li><p>上個段落的物件型別中有一項 <code>原始型別包裹物件（Primitive Wrapper）</code>，使用這個方式來建立的字串（數字或布林值）會是物件的形式，並且有許多原生方法可以使用，JavaScript 便是利用這個物件型別來實作裝箱與拆箱。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let str = &#x27;123&#x27;;</span><br><span class="line">let strObj = new String(&#x27;123&#x27;);</span><br><span class="line"></span><br><span class="line">console.log(typeof str); // string</span><br><span class="line">console.log(typeof strObj); // object</span><br></pre></td></tr></table></figure></li>
<li><p>裝箱（boxing）：當 JS 執行方法發現資料是原始型別時，便會使用 <code>new</code> 把原始型別資料建立成物件型別的資料，就可以順利執行物件內的方法。</p>
</li>
<li><p>拆箱（unboxing）：當 JS 完成被裝箱的物件需要執行的方法後，就會把這個物件資料還原成原始型別的資料，這時會用到兩個重要的方法，這會在接下來介紹的『轉型』再次談到：</p>
<ul>
<li><code>valueOf()</code>：回傳 <code>Number</code> 原始型別。</li>
<li><code>toString()</code>：回傳 <code>String</code> 原始型別。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="💎-強制轉型（coercion）"><a href="#💎-強制轉型（coercion）" class="headerlink" title="💎 強制轉型（coercion）"></a>💎 強制轉型（coercion）</h2><ul>
<li>強制轉型分為兩種：<code>顯性轉型</code>（explicit coercion）、<code>隱性轉型</code>（implicit coercion）</li>
</ul>
<h3 id="🔸-顯性轉型（explicit-coercion）："><a href="#🔸-顯性轉型（explicit-coercion）：" class="headerlink" title="🔸 顯性轉型（explicit coercion）："></a>🔸 顯性轉型（explicit coercion）：</h3><ul>
<li><p>顯性轉型指的是在程式碼中<code>直接撰寫</code>的型別轉換。</p>
</li>
<li><p><strong>轉數字</strong></p>
<ul>
<li><p><code>parseInt()</code>：</p>
<ul>
<li>轉整數。</li>
<li>小數點以後無條件捨去。</li>
<li>轉換方式：由左至右，遇到無法轉成數字的時候停止，回傳前面的數字。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(parseInt(&#x27;1.23&#x27;)); // 1</span><br><span class="line">console.log(parseInt(&#x27;1.23a&#x27;)); // 1</span><br><span class="line">console.log(parseInt(&#x27;a1.23&#x27;)); // NaN</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>parseFloat()</code>：</p>
<ul>
<li>轉浮點數（包含小數點以後）。</li>
<li>轉換方式與 parseInt() 相同。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(parseFloat(&#x27;1.23&#x27;)); // 1.23</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>Number()</code>：</p>
<ul>
<li>可以轉整數和浮點數。</li>
<li>數字範圍在正負 2的53次方 -1 間。</li>
<li>轉換方式：整筆字串都可以轉成數字才轉換，否則得到 NaN。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(Number(&#x27;-1.23&#x27;)); // -1.23</span><br><span class="line">console.log(Number(&#x27;-1.23a&#x27;)); // NaN</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>BigInt()</code>：</p>
<ul>
<li>轉整數</li>
<li>範圍可以超過2的53次方（表示方式會在數字後面加上 <code>n</code>）</li>
<li>轉換方式：非整數時直接報錯，不會得到 NaN。</li>
<li>需注意瀏覽器支援度。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(BigInt(&quot;9007199254740991&quot;)); // 9007199254740991n</span><br><span class="line">console.log(typeof 1n); // bigint</span><br><span class="line">console.log(BigInt(&quot;900a&quot;)); // Cannot convert 900a to a BigInt</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>算數運算子</code>：</p>
<ul>
<li>前方加上<code>+</code>：可能會和 <code>++</code> 混淆。</li>
<li>前方加上<code>-</code>：內容若是負數，會被轉成正數。</li>
<li>後方加上<code>- 0</code>：較穩定寫法。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(+&#x27;-1&#x27;); // -1</span><br><span class="line">console.log(++&#x27;-1&#x27;); // Invalid left-hand side expression in prefix operation</span><br><span class="line">console.log(-&#x27;-1&#x27;); // 1</span><br><span class="line">console.log(&#x27;-1&#x27; - 0); // -1</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>轉字串</strong></p>
<ul>
<li><p><code>toString()</code>：不能轉換 null 和 undefined，可以設定進位制。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log((3).toString()); // 3</span><br><span class="line">console.log(undefined.toString()); // Cannot read properties of undefined</span><br><span class="line">console.log((3).toString(2)); // 11</span><br></pre></td></tr></table></figure></li>
<li><p><code>String()</code>：可以轉換 null 和 undefined，不能設定進位制。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(String(3)); // 3</span><br><span class="line">console.log(String(undefined)); // undefined</span><br></pre></td></tr></table></figure></li>
<li><p><code>算數運算子</code>：加上空字串 <code>+ &#39;&#39;</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(typeof (3 + &#x27;&#x27;)); // string</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>轉布林值</strong></p>
<ul>
<li><p>布林值只有兩種值（true 或 false），轉型後會得到 true 的值稱為 truthy，得到 false 的則是 falsy，除了下列項目是 <code>falsy</code>，其他的都是 <code>truthy</code>：</p>
<ul>
<li><code>false</code></li>
<li><code>0</code></li>
<li><code>-0</code></li>
<li><code>0n</code> (BigInt)</li>
<li><code>“”</code> (空字串，包含 ``, ‘’)</li>
<li><code>null</code></li>
<li><code>undefined</code></li>
<li><code>NaN</code></li>
<li><code>document.all</code> (正常情況下不會用到)</li>
</ul>
</li>
<li><p>轉換方式：</p>
<ul>
<li><p><code>Boolean()</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(Boolean([])); // true</span><br></pre></td></tr></table></figure></li>
<li><p><code>邏輯運算子</code>：前方加上雙驚嘆號 <code>!!</code>，單驚嘆號 <code>!</code> 會是相反結果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(!true); // false</span><br><span class="line">console.log(!!&#123;&#125;); // true</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="🔸-隱性轉型（implicit-coercion）"><a href="#🔸-隱性轉型（implicit-coercion）" class="headerlink" title="🔸 隱性轉型（implicit coercion）"></a>🔸 隱性轉型（implicit coercion）</h3><ul>
<li><p>隱性轉型出現在使用運算子時，這在其他程式語言通常是不允許的（需要相同型別才可以運算），JavaScript 則會自動轉型讓程式繼續執行，也因為規則繁雜，容易疏忽出錯。</p>
</li>
<li><p>核心方法 <code>ToPrimitive</code><br>JavaScript 在執行運算時會使用 <code>ToPrimitive</code> 方法將運算元轉換成原始型別後就能繼續運算，<code>ToPrimitive</code> 帶有一個 <code>hint</code>(提示)，用來決定要轉成什麼型別，如果要了解詳細的運作順序可以參考 <strong><a href="https://zhuanlan.zhihu.com/p/29730094">深入理解Javascript中Object类型的转换</a></strong> 這篇文章，裡面引用了 ECMA 的規範詳細解說，非常值得一讀！</p>
</li>
<li><p><strong>原始型別</strong>的隱性轉型</p>
<ul>
<li><p><code>+</code> 算數運算子：加法運算中只要有一個值屬於字串型別，就會全部轉為 string，最高優先。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 有字串</span><br><span class="line">console.log(&#x27;&#x27; + 1 + null + true); // 1nulltrue</span><br><span class="line">// 無字串</span><br><span class="line">console.log(1 + null + true); // 2</span><br></pre></td></tr></table></figure></li>
<li><p>其他算數運算子：<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code> 運算都會轉成 number。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(&#x27;6&#x27; - undefined); // NaN</span><br><span class="line">console.log(9 * [9]); // 81</span><br><span class="line">console.log(&#x27;3&#x27; / &#123;&#125;); // NaN</span><br><span class="line">console.log(6 % true); // 0</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>物件型別</strong>的隱性轉型</p>
<ul>
<li><p><code>ｔoPrimitive</code> 執行物件型別的轉換時會使用到物件內的 <code>valueOf</code> 或 <code>toString</code> 方法來取得原始型別的回傳值，因為這是物件內的方法，我們可以透過覆蓋方法來改變回傳值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 刻意改成 valueOf 回傳字串、toString 回傳數字</span><br><span class="line">let a = &#123;</span><br><span class="line">    valueOf: function() &#123;</span><br><span class="line">        return &#x27;1&#x27;;</span><br><span class="line">    &#125;,</span><br><span class="line">    toString: function() &#123;</span><br><span class="line">        return 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(a + 0); // &quot;10&quot;</span><br><span class="line">console.log(a.toString()); // 2</span><br></pre></td></tr></table></figure></li>
<li><p><code>陣列</code>也是物件，ToPrimitive 會回傳陣列本身內容執行 <code>toString()</code> 方法後的字串。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 空陣列轉字串 &quot;&quot;，空物件轉字串 &quot;[object Object]&quot;</span><br><span class="line">console.log([] + &#123;&#125;); // &quot;[object Object]&quot;</span><br><span class="line"></span><br><span class="line">// 陣列轉字串 &quot;1,2,3&quot;，後方數字配合轉字串</span><br><span class="line">console.log([1,2,3] + 2 + 1); // &quot;1,2,321&quot;</span><br></pre></td></tr></table></figure></li>
<li><p><code>&#123;&#125; + 任意值</code>：</p>
<ol>
<li><code>&#123;&#125;</code> 在運算元前方時會被視為<code>區塊語句</code>，而不是物件，所以實際執行的只有後面的 <code>+ x</code></li>
<li><code>+ 任意值</code>是前一段落提到的<code>顯性轉型</code>轉數字的方法，所以後方的運算元轉為 number 型別。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 強制轉型</span><br><span class="line">console.log(+&#123;&#125;); // NaN</span><br><span class="line"></span><br><span class="line">// 看起來是物件加陣列，實際上是後方的陣列強制轉型為數字</span><br><span class="line">console.log(&#123;&#125; + []); // 0 </span><br><span class="line"></span><br><span class="line">// 上方程式實際執行時等同下面兩行：</span><br><span class="line">&#123;&#125;</span><br><span class="line">+[];</span><br><span class="line"></span><br><span class="line">// 宣告一個物件變數 x 來存放空物件，才能被當成物件來計算</span><br><span class="line">let x = &#123;&#125;;</span><br><span class="line">console.log(x + []); // &quot;[object Object]&quot;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p><code>&#123;&#125; + &#123;&#125;</code>：這是一個特別狀況所以額外說明，不同的瀏覽器會有不同的執行結果：</p>
<ol>
<li>NaN - 第一個 {} 被視為區塊，</li>
<li>“[object Object][object Object]” - 第一個 {} 被視為物件</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>邏輯運算</strong><br>邏輯運算中的運算元都會被轉為 boolean，差別在於其運算後回傳的結果。</p>
<ul>
<li><p>|| (or) 會回傳第一個結果為 true 的運算元，若無，則是最後一個。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(0 || false || null || undefined); // undefined</span><br><span class="line">console.log(0 || false || null || &#123;&#125; || undefined); // &#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>&amp;&amp; (and) 若運算結果為 true，會回傳最後一個運算元，若運算結果為 false，回傳第一個結果為 false 的運算元。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(true &amp;&amp; &#123;&#125; &amp;&amp; -2 &amp;&amp; [&#x27;a&#x27;]); // [&#x27;a&#x27;]</span><br><span class="line">console.log(1 &amp;&amp; 0 &amp;&amp; true &amp; false); // 0</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="💎-結語"><a href="#💎-結語" class="headerlink" title="💎 結語"></a>💎 結語</h2><p>關於轉型的細節實在太多，族繁不及備載，一些極端的範例在實際撰寫時並不會用到，不求成為行走的 MDN，但求踩坑的時候能順利 debug 就好！</p>
<blockquote>
<p>參考文章<br><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/BigInt">MDN-BigInt</a><br><a href="https://medium.com/@sunnyhuang.sc/%E6%8A%80%E8%A1%93%E7%AD%86%E8%A8%98-javascript-%E4%BD%95%E8%AC%82%E5%BC%B7%E5%88%B6%E8%BD%89%E5%9E%8B-coercion-%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E4%BD%9C%E5%88%B0%E8%BD%89%E6%8F%9B%E5%9E%8B%E5%88%A5-d7e39e30083">sunnyhuang-何謂強制轉型（coercion）以及如何作到轉換型別</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toString">MDN-Number.prototype.toString()</a><br><a href="https://codertw.com/%E5%89%8D%E7%AB%AF%E9%96%8B%E7%99%BC/254123/">淺談JS中String()與.toString()的區別 - 程式前沿</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toPrimitive">MDN-Symbol.toPrimitive</a>。<br><a href="https://eddychang.me/js-object-plus-object">Eddy 思考與學習-JS中的 {} + {} 與 {} + [] 的結果是什麼？</a><br><a href="https://eddychang.me/js-object-plus-object"></a></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript - Basic</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>[JS] 陳述式（Statement）與表達式（Expression）</title>
    <url>/2021/11/21/JSstatement/</url>
    <content><![CDATA[<p><img data-src="/images/js-statement.png"></p>
<span id="more"></span> 

<p>陳述式(Statement)與表達式(Expression)不是特定的使用方法或技巧，而是語法觀念，所有的程式碼都可以分成這兩類型的語句。</p>
<h2 id="💎-各種譯名："><a href="#💎-各種譯名：" class="headerlink" title="💎 各種譯名："></a>💎 各種譯名：</h2><ul>
<li>Statement：陳述式。</li>
<li>Expression：表示式、運算式、表達式。</li>
</ul>
<h2 id="💎-兩者的差別："><a href="#💎-兩者的差別：" class="headerlink" title="💎 兩者的差別："></a>💎 兩者的差別：</h2><ul>
<li><code>陳述式：不會回傳結果</code>。</li>
<li><code>表達式：會回傳結果</code>。</li>
</ul>
<h2 id="💎-陳述式的種類"><a href="#💎-陳述式的種類" class="headerlink" title="💎 陳述式的種類"></a>💎 陳述式的種類</h2><ul>
<li>流程控制<ul>
<li>{  } 區塊</li>
<li>if..else</li>
<li>switch</li>
<li>try..catch</li>
</ul>
</li>
<li>宣告<ul>
<li>var</li>
<li>let</li>
<li>const</li>
</ul>
</li>
<li>函式<ul>
<li>function</li>
<li>return</li>
</ul>
</li>
<li>疊代<ul>
<li>for</li>
<li>while</li>
</ul>
</li>
<li>其他<ul>
<li>export</li>
<li>import</li>
</ul>
</li>
</ul>
<blockquote>
<p>詳細可以參考 MDN：<br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements">Statements and declarations</a></p>
</blockquote>
<h2 id="💎-表達式的種類"><a href="#💎-表達式的種類" class="headerlink" title="💎 表達式的種類"></a>💎 表達式的種類</h2><ul>
<li>值：單純一個數字、字串、布林、物件…等等。</li>
<li>變數</li>
<li>賦值（=）</li>
<li>運算子（+, -, /, ==, ===, != ……）</li>
<li>會回傳結果都是</li>
</ul>
<h2 id="💎-陳述式與表達式的混用"><a href="#💎-陳述式與表達式的混用" class="headerlink" title="💎 陳述式與表達式的混用"></a>💎 陳述式與表達式的混用</h2><p>一段程式碼通常不會只使用其中一種方式撰寫，接著用以下範例來解說：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let example = function () &#123;</span><br><span class="line">    if (1 == 1) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>這段程式碼中的<code>陳述式</code>：</p>
<ul>
<li>let</li>
<li>function</li>
<li>if..else</li>
<li>return</li>
</ul>
</li>
<li><p>這段程式碼中的<code>表達式</code>：</p>
<ul>
<li>1</li>
<li>=</li>
<li>==</li>
</ul>
</li>
<li><p>這整段程式碼雖然結合了各種陳述式和表達式，最終是將函式賦予一個變數名稱，所以是一個<code>表達式</code>(賦值是表達式)，又稱為<code>函式表達式</code>，而一般宣告名稱的函式則稱為<code>函式陳述式</code>。</p>
</li>
</ol>
<blockquote>
<p>參考文章：<br><a href="https://wcc723.github.io/development/2020/09/17/js-expression/">卡斯柏 - JavaScript 表達式觀念及運用 - JS Expression</a></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript - Basic</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>[JS] 非同步系列：Promise 簡介</title>
    <url>/2022/04/17/JSpromise/</url>
    <content><![CDATA[<p>Promise 是 ES6 眾多好用方法之一，能用簡潔的撰寫方式處理非同步事件，大幅優化 callback hell 造成閱讀困難的問題。</p>
<span id="more"></span>

<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>Promise 是一個建構函式，帶有兩個參數：resolve、reject，分別是用來處理執行成功和失敗時的回傳資訊，格式如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> doSomething = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 使用 random 隨機產生 true 或 false 來回傳不同的結果</span></span><br><span class="line">  <span class="keyword">let</span> result = <span class="built_in">Boolean</span>(<span class="built_in">Math</span>.round(<span class="built_in">Math</span>.random()));</span><br><span class="line">  <span class="keyword">if</span> (result) &#123;</span><br><span class="line">    <span class="comment">// 使用 resolve 回傳成功時的資料</span></span><br><span class="line">    resolve(<span class="string">`Success`</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 reject 回傳失敗時的資料</span></span><br><span class="line">    reject(<span class="string">`Failed`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Promise-then-catch"><a href="#Promise-then-catch" class="headerlink" title="Promise (.then .catch)"></a>Promise (.then .catch)</h2><p><code>new Promise()</code> 建立的 Promise 物件提供 .then 和 .catch 兩個方法來分別接收 resolve 和 reject 回傳的資料，撰寫格式如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">doSomething</span><br><span class="line">  .then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// .then 接收 成功(resolve) 的回傳值</span></span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// .catch 接收 失敗(reject) 的回傳值</span></span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Promise-自訂參數"><a href="#Promise-自訂參數" class="headerlink" title="Promise + 自訂參數"></a>Promise + 自訂參數</h2><p>Promise 不能直接傳入參數，但是可以使用函式建立參數的接口，再回傳 Promise 物件，就能加入其他的參數了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> doSomething = <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// return 一個 Promise 物件</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="built_in">Boolean</span>(<span class="built_in">Math</span>.round(<span class="built_in">Math</span>.random()));</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">      resolve(<span class="string">`<span class="subst">$&#123;name&#125;</span>, success!`</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      reject(<span class="string">`<span class="subst">$&#123;name&#125;</span>, failed!`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">doSomething(<span class="string">&#x27;Peter&#x27;</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">data</span>) =&gt;</span> <span class="built_in">console</span>.log(data))</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> <span class="built_in">console</span>.log(error));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成功(resolve)時輸出：Peter, success!</span></span><br><span class="line"><span class="comment">// 失敗(reject)時輸出：Peter, failed!</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="串接多個-Promise"><a href="#串接多個-Promise" class="headerlink" title="串接多個 Promise"></a>串接多個 Promise</h2><p>Promise 的 then 方法用串接的方式連接下個行為，不像 callback function 需要槽狀層層包覆。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加入第二個會隨機決定成功或失敗的函式</span></span><br><span class="line"><span class="keyword">const</span> doSomethingElse = <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="built_in">Boolean</span>(<span class="built_in">Math</span>.round(<span class="built_in">Math</span>.random()));</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">      resolve(<span class="string">`Good job, <span class="subst">$&#123;str&#125;</span>`</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      reject(<span class="string">`Bad job, <span class="subst">$&#123;str&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 呼叫第一個函式</span></span><br><span class="line">doSomething(<span class="string">&#x27;Peter&#x27;</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 將第一個函式的執行結果傳入第二個函式</span></span><br><span class="line">    doSomethingElse(result);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 顯示第二個函式的執行結果</span></span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 不管是第幾個函式，出錯就會在這邊被捕捉</span></span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// doSomething 成功、doSomethingElse 成功時輸出：Good job, Peter, success!</span></span><br><span class="line"><span class="comment">// doSomething 失敗時輸出：Peter, failed!</span></span><br><span class="line"><span class="comment">// doSomething 成功、doSomethingElse 失敗時輸出：Bad job, Peter, failed!</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h2><p>當有不同的資料需要合併處理時使用，只要其中一項失敗就會立刻回傳失敗，不會等其他的非同步跑完，成功時則是以陣列方式回傳資料。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> doSomething = <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="built_in">Boolean</span>(<span class="built_in">Math</span>.round(<span class="built_in">Math</span>.random()));</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">      resolve(name);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      reject(<span class="string">`<span class="subst">$&#123;name&#125;</span>, failed`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([</span><br><span class="line">  doSomething(<span class="string">&#x27;Peter&#x27;</span>),</span><br><span class="line">  doSomething(<span class="string">&#x27;Parker&#x27;</span>),</span><br><span class="line">  doSomething(<span class="string">&#x27;Porker&#x27;</span>),</span><br><span class="line">])</span><br><span class="line">  .then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`恭喜 <span class="subst">$&#123;data.join(<span class="string">&#x27;、&#x27;</span>)&#125;</span> 全部成功！`</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全部成功時顯示：恭喜 Peter、Parker、Porker 全部成功！</span></span><br><span class="line"><span class="comment">// 任一個失敗時顯示： 傳入的名稱, failed</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript - Basic</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>[JS] 作用域（Scope）與範圍鏈（Scope Chain）</title>
    <url>/2022/01/04/JSscope/</url>
    <content><![CDATA[<p><img data-src="/images/js-scope.png"></p>
<span id="more"></span> 

<p><code>作用域(Scope)</code>是<code>變數可以被使用的區域</code>，區分作用域可以避免變數的衝突。</p>
<p>舉例來說，甲、乙班各有一位同學叫小明，分別在兩個班上點名，點到小明都不會有問題，但若是全校廣播找小明，就會出現衝突，不知道要找哪一個小明。</p>
<p>作用域也有上下（內外）層級關係，當自己的作用域不存在特定變數時，可以向上（外）層尋找。</p>
<p>換個例子，雖然自己的班上找不到校長，但可以從自己的學校找到校長。</p>
<p>接著就來看 JavaScript 如何去實現這些功能。</p>
<hr>
<h2 id="💎-作用域（Scope）"><a href="#💎-作用域（Scope）" class="headerlink" title="💎 作用域（Scope）"></a>💎 作用域（Scope）</h2><h3 id="🔸-1、全域作用域（Global-Scope）"><a href="#🔸-1、全域作用域（Global-Scope）" class="headerlink" title="🔸 1、全域作用域（Global Scope）"></a>🔸 1、全域作用域（Global Scope）</h3><p>  全域顧名思義就是全部的區域，網頁中的全域物件就是 <code>window</code>。<br>  在初學 JS 時，會先練習開啟一個空白檔案，並且撰寫變數宣告，這時的變數就屬於全域變數。</p>
<p>  不同的宣告方式產生的全域變數也有差異：</p>
<ul>
<li>var：宣告後會成為 window 物件底下的一個屬性。</li>
<li>let、const：宣告後不會放到 window 底下，而是一個區塊作用域。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">let b = 2;</span><br><span class="line">const c = 3;</span><br><span class="line"></span><br><span class="line">console.log(a); // 1</span><br><span class="line">console.log(window.a); // 1</span><br><span class="line"></span><br><span class="line">console.log(b); // 2</span><br><span class="line">console.log(window.b); // undefined</span><br><span class="line"></span><br><span class="line">console.log(c); // 3</span><br><span class="line">console.log(window.c); // undefined</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="🔸-2、函式作用域-Function-Scope"><a href="#🔸-2、函式作用域-Function-Scope" class="headerlink" title="🔸 2、函式作用域(Function Scope)"></a>🔸 2、函式作用域(Function Scope)</h3><p>  用 <code>var</code> 宣告的變數會在<code>函式 (function)</code> 內區隔，先來看看下面的範例碼：<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function f1() &#123;</span><br><span class="line">  var a = 1;</span><br><span class="line">  f2();</span><br><span class="line">&#125;</span><br><span class="line">function f2() &#123;</span><br><span class="line">  console.log(a)</span><br><span class="line">&#125;</span><br><span class="line">f1();</span><br><span class="line"></span><br><span class="line">// 執行結果：</span><br><span class="line">// Uncaught ReferenceError: a is not defined</span><br></pre></td></tr></table></figure></p>
<p>  上面的範例可以知道 f2 函式無法取得 f1 函式內宣告的變數。</p>
<p>  再來看看另一個經典題目，當 var 遇到 call stack 時出現的詭異狀況。<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (var i = 1; i &lt; 5; i++) &#123;</span><br><span class="line">  setTimeout(() =&gt; console.log(i), 500);</span><br><span class="line">&#125;</span><br><span class="line">console.log(i);</span><br><span class="line"></span><br><span class="line">// 5  </span><br><span class="line">// 5</span><br><span class="line">// 5</span><br><span class="line">// 5</span><br><span class="line">// 5</span><br></pre></td></tr></table></figure><br>  如果你覺得這個輸出結果非常奇怪，不要忘了 var 的作用域是在函式中，上面這段 for 迴圈並不是函式，所以 <code>var i</code> 是<code>宣告在全域</code>，迴圈總共執行了四次，但是每次都是覆蓋掉全域中的 i ，<code>最後只有一個全域變數 i </code>存放數值 <code>5</code>，接著 setTimeout 裡面的函式執行時因為作用域裡面沒有變數 i，向外找到全域的 i (此時迴圈已經執行完，值是5)，才會都印出一樣的結果；除此之外，印出的第一個 5 是來自程式碼最後一行全域的呼叫，也證實了這個變數存在全域。</p>
<p>  函式的範圍較大，撰寫時常使用的邏輯判斷都沒辦法區隔作用域，為了區隔作用域，衍生出閉包、立即函式等各種應用技巧，這個問題在 ES6 的版本後才獲得改善。</p>
<blockquote>
<p>延伸閱讀<br>1、<a href="https://hsiangfeng.github.io/javascript/20201118/707576253/">JavaScript 核心觀念(36)-函式以及 This 的運作-立即函式</a><br>2、<a href="https://eyesofkids.gitbooks.io/javascript-start-from-es6/content/part4/closure.html">閉包</a></p>
</blockquote>
<h3 id="🔸-3、區塊作用域-Block-Scope"><a href="#🔸-3、區塊作用域-Block-Scope" class="headerlink" title="🔸 3、區塊作用域(Block Scope)"></a>🔸 3、區塊作用域(Block Scope)</h3><p>  ES6 版本加入的 <code>let</code> 和 <code>const</code> 兩種變數宣告方式，作用域會在大括號 <code>&#123;&#125;</code> 內區隔：<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  const a = 1;</span><br><span class="line">  &#123;</span><br><span class="line">    let b = 2;</span><br><span class="line">    var c = 3;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(a); // 1</span><br><span class="line">  console.log(b); // b is not defined</span><br><span class="line">  console.log(c); // 3   </span><br><span class="line">&#125;</span><br><span class="line">console.log(a); // a is not defined</span><br><span class="line">console.log(b); // b is not defined</span><br><span class="line">console.log(c); // 3</span><br></pre></td></tr></table></figure></p>
<p>  上面的範例可以看到 <code>var</code> 無論在哪個大括號內都可以取用，但 <code>let</code> 和 <code>const</code> 無法在自己存在的大括號外被取用。</p>
<p>  常用的 <code>if-else</code>、<code>for</code>等方法都會使用大括號，相對於 <code>function</code>，可以把作用域區分的更細。</p>
<p>  前個段落 <code>setTimeout</code> 範例內的 <code>var</code> 改成 <code>let</code>：<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (let i = 1; i &lt; 5; i++) &#123;</span><br><span class="line">  setTimeout(() =&gt; console.log(i), 500);</span><br><span class="line">&#125;</span><br><span class="line">console.log(i);</span><br><span class="line">// Uncaught ReferenceError: i is not defined</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br><span class="line">// 3</span><br><span class="line">// 4</span><br></pre></td></tr></table></figure></p>
<p>  從結果可以發現，每次的 <code>let i</code> 都是獨立的作用域，所以 setTimeout 實際執行時能夠找到該次迴圈區塊內產生的變數 i，除此之外，全域環境中也不會找到在區塊作用域中的變數 i （出現未定義的錯誤）。</p>
<blockquote>
<p>參考資料<br><a href="https://ithelp.ithome.com.tw/articles/10217481">JS 原力覺醒 Day04 - Function Scope / Block Scope</a></p>
</blockquote>
<ul>
<li>直接宣告(不加前綴詞)，無論放在 <code>區塊&#123;&#125;</code> 或 <code>函式</code> 內都會成為 window 物件底下的一個屬性。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dirtyA = 11;</span><br><span class="line">console.log(window.dirtyA); // 11</span><br><span class="line"></span><br><span class="line">function dirtyVariable() &#123;</span><br><span class="line">  dirtyB = 12;</span><br><span class="line">&#125;</span><br><span class="line">dirtyVariable();</span><br><span class="line">console.log(window.dirtyB); // 12</span><br></pre></td></tr></table></figure></li>
<li>直接宣告在 <code>window</code> 底下的變數可以使用 <code>delete</code> 物件方法刪除；而使用 <code>var</code> 宣告的全域變數無法使用 <code>delete</code> 刪除(<del>介於屬性與非屬性之間</del>)。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = 1;</span><br><span class="line">delete window.x; // true</span><br><span class="line">console.log(x); // x is not defined</span><br><span class="line"></span><br><span class="line">var y = 2;</span><br><span class="line">delete window.y; // false</span><br><span class="line">console.log(y); // 2</span><br></pre></td></tr></table></figure></li>
<li>在 ES5 時可以透過<code>&#39;use strict&#39;</code>（嚴格模式）來避免這些不好的操作，ES6 以後一律使用 <code>let</code> 和 <code>const</code>。</li>
</ul>
<blockquote>
<p>延伸閱讀：<br>1、<a href="https://iter01.com/56454.html">深入JavaScript系列（一）：詞法環境</a><br>2、<a href="https://medium.com/itsems-frontend/javascript-strict-mode-d0a3aa74458b">Javascript 的嚴格模式 (Strict Mode)</a></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript - Basic</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>[JS] if 和 switch 的使用時機</title>
    <url>/2021/11/18/JSswitch/</url>
    <content><![CDATA[<p><img data-src="/images/js-if.png"></p>
<span id="more"></span> 
<p>if 和 switch 時常會被拿來比較，無論是可讀性、嚴謹性、效能…等，在比較前先了解基本的撰寫結構。</p>
<hr>
<h2 id="💎-if…else-的寫法"><a href="#💎-if…else-的寫法" class="headerlink" title="💎 if…else 的寫法"></a>💎 if…else 的寫法</h2><ul>
<li><p>基本結構，至少要有一個條件判斷：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (true) &#123;</span><br><span class="line">    console.log(&quot;Hello, if!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>非 A 及 B（二選一）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let agreement = true;</span><br><span class="line">if (agreement) &#123;</span><br><span class="line">    console.log(&quot;同意&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    console.log(&quot;不同意&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>多個判斷：</p>
<ul>
<li>JavaScript 中的 else if 需要空白隔開（其他程式語言有些是連在一起的elseif）。</li>
<li>else 不是必要項目，會在不符合所有的 if 或 else if 時執行。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let x = 100;</span><br><span class="line">if (x &gt;= 10000) &#123;</span><br><span class="line">    /* do something */</span><br><span class="line">&#125; else if (money &gt;= 1000) &#123;</span><br><span class="line">    /* do something */</span><br><span class="line">&#125; else if (money &gt;= 100) &#123;</span><br><span class="line">    /* do something */</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    /* do something */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>巢狀判斷</p>
<ul>
<li>可以在 if-else 內再加入 if-else 逐步判斷。</li>
<li>層級過多時不易閱讀。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (temperature &gt; 28) &#123;</span><br><span class="line">    console.log(&quot;stay home&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    if (humidity &gt; 50) &#123;</span><br><span class="line">        console.log(&quot;stay home&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (traffic === &#x27;nice&#x27;) &#123;</span><br><span class="line">            console.log(&quot;stay home&quot;);</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h2 id="💎-switch-的寫法"><a href="#💎-switch-的寫法" class="headerlink" title="💎 switch 的寫法"></a>💎 switch 的寫法</h2><ul>
<li><p>基本結構：</p>
<ul>
<li>條件數量可以自行增減。</li>
<li>每個條件結束後需加上 break 終止執行。</li>
<li>default 不一定要放在最後，可以插在中間或最前面，不影響程式執行。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">switch (要判斷的資料) &#123;</span><br><span class="line">  case 條件1:</span><br><span class="line">    /* do something */</span><br><span class="line">    break;</span><br><span class="line">  case 條件2:</span><br><span class="line">    /* do something */</span><br><span class="line">    break;</span><br><span class="line">  ...</span><br><span class="line">  case 條件n:</span><br><span class="line">    /* do something */</span><br><span class="line">    break;</span><br><span class="line">  default:</span><br><span class="line">    /* 上述條件都不符合時執行 */</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>switch 中的 break 不能遺漏</code><br>如果忘記在 case 結束時撰寫 break 來中斷，無論接下來的條件是否符合，都會一直執行到出現 break 或 switch 結尾為止，這會是相當嚴重的錯誤。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var x = 0;</span><br><span class="line">switch (x) &#123;</span><br><span class="line">  case 0:</span><br><span class="line">    console.log(0); // 此處漏掉 break</span><br><span class="line">  case 1: </span><br><span class="line">    console.log(1); // 繼續執行，此處也漏掉 break</span><br><span class="line">  case 2:</span><br><span class="line">    console.log(2); // 繼續執行</span><br><span class="line">    break; // 終止執行</span><br><span class="line">  case 3:</span><br><span class="line">    console.log(3); </span><br><span class="line">    break;</span><br><span class="line">  default:</span><br><span class="line">    console.log(&#x27;default&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---執行結果---</span><br><span class="line">console:</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="💎-if-和-switch-簡單比較"><a href="#💎-if-和-switch-簡單比較" class="headerlink" title="💎 if 和 switch 簡單比較"></a>💎 if 和 switch 簡單比較</h2><ul>
<li>爬了各種文章後，大致歸納出以下幾點比較：<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">if</th>
<th align="center">switch</th>
</tr>
</thead>
<tbody><tr>
<td align="center">易讀性</td>
<td align="center">判斷條件少時較佳</td>
<td align="center">判斷條件多時佳</td>
</tr>
<tr>
<td align="center">效能</td>
<td align="center">專案複雜時較差</td>
<td align="center">專案複雜時較佳</td>
</tr>
<tr>
<td align="center">判斷方式</td>
<td align="center">撰寫者決定嚴謹度</td>
<td align="center">嚴格比較（===）</td>
</tr>
<tr>
<td align="center">使用時機</td>
<td align="center">適合在少量決策、連續區間</td>
<td align="center">適合大量決策、獨立區間</td>
</tr>
</tbody></table>
</li>
</ul>
<hr>
<h2 id="💎-延伸技巧"><a href="#💎-延伸技巧" class="headerlink" title="💎 延伸技巧"></a>💎 延伸技巧</h2><h3 id="🔸-條件（三元）運算子"><a href="#🔸-條件（三元）運算子" class="headerlink" title="🔸 條件（三元）運算子"></a>🔸 條件（三元）運算子</h3><ul>
<li>條件運算子像是 if…else 的簡化版，寫法如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 條件 ? 結果為truthy時執行 : 結果為falsy時執行 */</span><br><span class="line"></span><br><span class="line">let a = 1;</span><br><span class="line">a &gt; 1 ? console.log(&#x27;yes&#x27;) : console.log(&#x27;no&#x27;);</span><br></pre></td></tr></table></figure></li>
<li>條件運算子也可以做到 else if，但是可讀性不太好，寫起來也容易漏掉符號：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let a = 1;</span><br><span class="line">a &gt; 3 ? console.log(`$&#123;a&#125; &gt; 3`)</span><br><span class="line">: a &gt; 2 ? console.log(`$&#123;a&#125; &gt; 2`)</span><br><span class="line">: a &gt; 1 ? console.log(`$&#123;a&#125; &gt; 1`)</span><br><span class="line">: console.log(`$&#123;a&#125; &lt;= 1`);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="🔸-Early-Return"><a href="#🔸-Early-Return" class="headerlink" title="🔸 Early Return"></a>🔸 Early Return</h3><ul>
<li><p>當條件判斷多的時候，很容易寫出好幾層的巢狀判斷，不但不好閱讀，也降低執行效能。<br>這時可以挑出一些必要的條件，不符合就直接終止（return），可以減少巢狀、提高可讀性，也能提昇程式執行效率。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function doSomething(a, b)&#123;</span><br><span class="line">  // 不是數字就結束</span><br><span class="line">  if(isNaN(parseFloat(num1))||isNaN(parseFloat(num2))) return;</span><br><span class="line">  // 主要判斷邏輯</span><br><span class="line">  if(...)&#123;</span><br><span class="line">    if(...)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>參考資料：<br><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Statements/if...else">MDN-if…else</a><br><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Statements/switch">MDN-switch</a><br><a href="https://hsiangfeng.github.io/javascript/20200117/3217748743/">Ray-JavaScript 的 if 跟 switch 效能</a><br><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Operators/Conditional_Operator">MDN-條件運算子</a><br><a href="https://askie.today/javascript-good-condition-statement/">askie-五個小技巧讓你寫出更好的 JavaScript 條件語句</a></p>
</blockquote>
</li>
</ul>
<hr>
<p>以上是我對 if 和 switch 的一點認知，如有錯誤或是需要補充的知識點，也歡迎大家不吝指教，謝謝！</p>
]]></content>
      <categories>
        <category>JavaScript - Basic</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>[JS] 變數宣告方式：let、const、var</title>
    <url>/2021/11/16/JSvariable/</url>
    <content><![CDATA[<p><img data-src="/images/js-variables.png"></p>
<span id="more"></span> 

<p>JavaScript 過去只有 <code>var</code> 一種變數宣告方式，直到 2015 年發表的 ECMAScript 2015（ES2015），第 6 版，又被稱為 ECMAScript 6（通常簡稱為 ES6 ），才有 <code>let</code> 和 <code>const</code> 兩種新的變數宣告方式，這個版本有相當多的革新，現在常用的箭頭函式、樣板字串…等都包含在其中。</p>
<blockquote>
<p>參考資料： <a href="https://zh.wikipedia.org/wiki/ECMAScript">Wiki - ECMAScript</a></p>
</blockquote>
<hr>
<h2 id="💎-Can-I-Use"><a href="#💎-Can-I-Use" class="headerlink" title="💎 Can I Use?"></a>💎 Can I Use?</h2><p>雖然 2015 年距今已經超過 6 年了，但是仍有些企業或公司在使用 IE 這類過時的瀏覽器，<code>let</code> 和 <code>const</code> 在 IE 11 只有部分支援、 IE 10 以下版本則是完全不支援，如有支援需求就需要搭配 Babel 來轉換成兼容的程式碼。</p>
<blockquote>
<p>參考資料： <a href="https://caniuse.com/">Can I Use</a></p>
</blockquote>
<hr>
<h2 id="💎-變數宣告方式的差異"><a href="#💎-變數宣告方式的差異" class="headerlink" title="💎 變數宣告方式的差異"></a>💎 變數宣告方式的差異</h2><p><code>var</code> 規範較鬆，有許多小陷阱需要小心使用，<code>let</code> 和 <code>const</code> 有了進一步的規範，可以針對不同需求運用，使用上較安全，兩者間有５個主要的差異在下個段落逐一說明。：</p>
<ul>
<li>可否重複宣告</li>
<li>可否重新賦值</li>
<li>是否需要初始值</li>
<li>作用域的範圍</li>
<li>提昇（Hoisting）機制的差異</li>
</ul>
<hr>
<h3 id="🔸-1、重複宣告"><a href="#🔸-1、重複宣告" class="headerlink" title="🔸 1、重複宣告"></a>🔸 1、重複宣告</h3><ul>
<li><p><code>var</code> 可以重複宣告同一個變數名稱，後者會覆蓋前者，而且程式不會報錯，使用起來較危險，萬一不小心使用了相同的名稱，可能造成其他段落程式碼出錯。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">var a = 2;</span><br><span class="line">console.log(a); // 2</span><br></pre></td></tr></table></figure></li>
<li><p><code>let</code> 和 <code>const</code> 不允許重複宣告，使用起來較安全。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let b = 1;</span><br><span class="line">let b = 2;</span><br><span class="line">// Uncaught SyntaxError: Identifier &#x27;b&#x27; has already been declared</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="🔸-2、重新賦值"><a href="#🔸-2、重新賦值" class="headerlink" title="🔸 2、重新賦值"></a>🔸 2、重新賦值</h3><ul>
<li><p>如果不知道『常數』是什麼，可以先看一下維基百科的說明。</p>
<blockquote>
<p>摘錄自維基百科：<br>常數，又稱定數（Constant），是指一個數值固定不變的常量，例如圓周率，與之相反的是變數。</p>
<p>參考資料： <a href="https://zh.wikipedia.org/wiki/%E5%B8%B8%E6%95%B0">Wiki - 常數</a>   </p>
</blockquote>
</li>
<li><p>過去只有 <code>var</code> 時，如果想要宣告一個不能被變更的常數，通常會用全部大寫，加上 <code>_</code> 連接單字來標示，但是名稱只能幫助辨識，實際操作並不具有常數的限制。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var DO_NOT_TOUCH_ME = &#x27;X&#x27;;</span><br><span class="line">DO_NOT_TOUCH_ME = &#x27;我偏要改&#x27;;</span><br><span class="line">console.log(DO_NOT_TOUCH_ME); // 我偏要改</span><br></pre></td></tr></table></figure></li>
<li><p>ES6 提供的 <code>const</code> 宣告方式可以實際的宣告一個常數，有了 <code>const</code> 之後不需要使用大寫格式命名來區別是不是常數，看宣告方式即可（視團隊開發時的規範而定）；而 <code>let</code> 則是和 <code>var</code> 一樣可以重新賦值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const doNotTouchMe = &#x27;X&#x27;;</span><br><span class="line">doNotTouchMe = &#x27;我偏要碰&#x27;;</span><br><span class="line">// Uncaught TypeError: Assignment to constant variable.</span><br></pre></td></tr></table></figure></li>
<li><p><code>const</code> 的使用時機：對 JS 新手來說，大概只會想到圓周率、太陽數量…等，在撰寫時遇到下列的情形都建議使用 <code>const</code> 宣告。</p>
<ul>
<li><code>DOM</code>：使用 <code>querySelector</code> 這類方法取得的 DOM 如果被改變，容易造成邏輯混亂，維護困難。</li>
<li><code>陣列</code>：使用陣列方法來操作，避免被 <code>=</code> 賦值給覆蓋掉。</li>
<li><code>物件</code>：使用物件方法來操作，避免被 <code>=</code> 賦值給覆蓋掉。</li>
<li><code>函式表示式</code>：避免被 <code>=</code> 賦值給覆蓋掉。</li>
</ul>
<blockquote>
<p><strong>延伸問題：</strong><br>使用 const 宣告的變數應該不能被變更才對，為什麼『陣列』和『物件』要使用 const 來宣告？<br><strong>Ans：</strong><br>變數裡面存放的陣列和物件並不是實體，而是指向實體的記憶體位置，就像是變數名稱存放了帝寶的地址，透過這個變數名稱的值能到達帝寶的實體位置，對大樓做變更操作。<br>詳細可以參考我的另一篇文章 <a href="https://stark920.github.io/2021/11/17/JScallby/">參數傳遞方式 Call by what?</a></p>
</blockquote>
</li>
</ul>
<hr>
<h3 id="🔸-3、初始值"><a href="#🔸-3、初始值" class="headerlink" title="🔸 3、初始值"></a>🔸 3、初始值</h3><ul>
<li>常數是不能更動的值，在一開始設定好值也是相當合理，因此 <code>const</code> 在宣告的時候一定要賦予值，<code>var</code> 和 <code>let</code> 則無此限制。  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const a;</span><br><span class="line">// Uncaught SyntaxError: Missing initializer in const declaration</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="🔸-4、作用域"><a href="#🔸-4、作用域" class="headerlink" title="🔸 4、作用域"></a>🔸 4、作用域</h3><ul>
<li>作用域（Scope）是變數可以被使用的區域，也代表著在相同的作用域才會有重複命名的衝突問題，只要作用域不同就可以宣告相同名稱的變數。<ul>
<li><code>var</code>：函式作用域，只在 function 間區隔作用域，範圍大，不好區分。</li>
<li><code>let、const</code>：區塊作用域，在 {…}（大括弧）間區隔作用域，範圍小，容易區分。</li>
</ul>
</li>
</ul>
<blockquote>
<p>詳細說明可以參考我的另一篇文章： <a href="https://stark920.github.io/2022/01/04/JSscope">[JS] 作用域（Scope）與範圍鏈（Scope Chain）</a></p>
</blockquote>
<hr>
<h3 id="🔸-5、提昇（Hoisting）"><a href="#🔸-5、提昇（Hoisting）" class="headerlink" title="🔸 5、提昇（Hoisting）"></a>🔸 5、提昇（Hoisting）</h3><ul>
<li>JavaScript 在進入執行階段前會將文件中所有宣告的變數、函式（函式陳述式）提前到最上方，差異如下：<ul>
<li><code>var</code>：變數提到最上方後<code>會實體化</code>（寫入記憶體，但尚未賦值），在實際執行到該行變數宣告的程式碼前<code>可以被取用</code>（取值結果為 undefined）。</li>
<li><code>let、const</code>：變數提前到最上方後<code>不會實體化</code>，在實際執行到該行變數宣告的程式碼前<code>不可以取用</code>（取值結果為 執行階段錯誤），這段不能取用的期間又稱為<code>暫時性死區（TDZ）</code>。</li>
</ul>
</li>
</ul>
<blockquote>
<p>詳細說明可以參考我的另一篇文章： <a href="https://stark920.github.io/2021/11/23/JShoisting">[JS] 提昇（Hoisting）機制</a></p>
</blockquote>
<hr>
<h2 id="💎-總結"><a href="#💎-總結" class="headerlink" title="💎 總結"></a>💎 總結</h2><p>整理後的變數宣告方式差異列表如下：</p>
<table>
<thead>
<tr>
<th align="center"><img width=100/></th>
<th align="center">var<img width=100/></th>
<th align="center">let<img width=100/></th>
<th align="center">const<img width=100/></th>
</tr>
</thead>
<tbody><tr>
<td align="center">重複宣告</td>
<td align="center">✅</td>
<td align="center">❌</td>
<td align="center">❌</td>
</tr>
<tr>
<td align="center">重新賦值</td>
<td align="center">✅</td>
<td align="center">✅</td>
<td align="center">❌</td>
</tr>
<tr>
<td align="center">強制賦予初始值</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">✅</td>
</tr>
<tr>
<td align="center">作用域</td>
<td align="center">function</td>
<td align="center">{ }</td>
<td align="center">{ }</td>
</tr>
<tr>
<td align="center">提升機制</td>
<td align="center">可被取用</td>
<td align="center">TDZ</td>
<td align="center">TDZ</td>
</tr>
</tbody></table>
<p>以上是我對變數型別的一點認知，如有錯誤或是補充的知識點，也歡迎大家不吝指教，謝謝！</p>
<blockquote>
<p>參考資料： <a href="https://www.youtube.com/watch?v=FGdKdn_CnWo&ab_channel=%E5%85%AD%E8%A7%92%E5%AD%B8%E9%99%A2">六角學院－JavaScript 那個 let, const, var 到底差在哪？</a></p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript - Basic</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>[JS] undefined 和 null 的差異</title>
    <url>/2021/11/18/JSundefined/</url>
    <content><![CDATA[<p><img data-src="/images/js-null.png"></p>
<span id="more"></span> 
<p>undefined 是 JavaScript 的特有物之一，新手入門時，常會對 undefined 和 null 這兩個型別產生疑問，以下逐步解說。</p>
<hr>
<h2 id="💎-null"><a href="#💎-null" class="headerlink" title="💎 null"></a>💎 null</h2><ul>
<li><p><code>null</code> 表示一個空值（沒有值），是各種程式語言中常見的型別，如果有後端資料庫的相關經驗，在設計 SQL 資料表時，可以在非必要欄位設定『允許 null』，當資料建立起來的時候，這些沒填的欄位就會塞入 null 來表示空值。</p>
</li>
<li><p>JS 中的 <code>null</code> 是一種<code>原始型別</code>，可以賦予變數的值為 null 來表示他是<code>空值</code>，當看到 null 時，我們可以知道這是人為賦予的空值，不是系統自動產生的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let a = null; // 不要包引號，會變成字串</span><br><span class="line">console.log(a); // null</span><br></pre></td></tr></table></figure></li>
<li><p>JS 裡的 null 還有一些特色：</p>
<ul>
<li>檢查型別（typeof）的設計失誤（因影響久遠，此錯誤不會修正），正確是 null。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(typeof null); // object</span><br></pre></td></tr></table></figure></li>
<li>null 雖然代表著空值，轉型成字串時會照字面上的英文轉。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(null + &#x27;&#x27;); // &#x27;null&#x27;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>參考資料： <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/null">MDN-null</a>、<a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Operators/typeof">MDN-typeof</a></p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="💎-undefined"><a href="#💎-undefined" class="headerlink" title="💎 undefined"></a>💎 undefined</h2><ul>
<li>undefined 從字面上可以理解成『未定義』，表示這個變數並沒有被賦予任何的值，跟已經被賦予空值（null）代表著不一樣的資料狀態，比起 null，undefined 更容易跟 not defined 搞混：<ul>
<li><code>undefined</code> 是變數<code>已被宣告</code>且<code>未賦值</code>，屬於<code>原始型別</code>之一。</li>
<li><code>not defined</code> 是變數<code>未被宣告</code>，不屬於原始型別，是程式<code>執行時的錯誤訊息（runtime error）</code>。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let a;</span><br><span class="line"></span><br><span class="line">console.log(a); // undefined</span><br><span class="line">console.log(typeof a); // undefined</span><br><span class="line">console.log(b); // ReferenceError: b is not defined</span><br><span class="line">console.log(typeof b); // undefined</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h2 id="💎-null-undefined"><a href="#💎-null-undefined" class="headerlink" title="💎 null == undefined ?"></a>💎 null == undefined ?</h2><ul>
<li>看完前面的段落，可以知道 undefined 和 null 意義上是完全不同，接著來比較看看：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(undefined == null); // true</span><br></pre></td></tr></table></figure>
不是說好不一樣的嗎？<br>可能是轉型在作亂，改用嚴格比較（===）看看。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(undefined === null); // false</span><br></pre></td></tr></table></figure>
果然是轉型搞的鬼，但是為什麼 undefined 和 null 轉型後會相等？下個段落繼續說明。</li>
</ul>
<hr>
<h2 id="💎-truthy-amp-falsy"><a href="#💎-truthy-amp-falsy" class="headerlink" title="💎 truthy &amp; falsy"></a>💎 truthy &amp; falsy</h2><ul>
<li><p>JavaScript 中的各種值都可以被轉換成布林值（Boolean），轉換後為 true 的值稱為 <code>truthy</code>，反之則稱為 <code>falsy</code>，除了以下所列的值屬於 falsy 值，其他都是 truthy 值。<br>（完整的圖表可以參考 <a href="https://dorey.github.io/JavaScript-Equality-Table/">JS Comparison Table</a>）</p>
<ul>
<li>false</li>
<li>0</li>
<li>-0</li>
<li>0n (BigInt)</li>
<li>“” (空字串，包含 <code>單引號</code>、<code>反引號</code>)</li>
<li>null</li>
<li>undefined</li>
<li>NaN</li>
<li>document.all (正常不會用到)</li>
</ul>
</li>
<li><p>由上可知，<code>null</code>和<code>undefined</code>都是<code>falsy</code>值，在做一般相等的比較時，都會被轉成 false，所以得到的結果是 true。</p>
</li>
<li><p>truthy 和 falsy 的運用：檢查資料是否存在時可以運用轉成布林值的方法減少程式碼撰寫長度。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 原始寫法：</span><br><span class="line">if (arr[0] === undefined) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 轉型為布林值</span><br><span class="line">if (!arr[0]) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>參考資料： <a href="https://developer.mozilla.org/en-US/docs/Glossary/Falsy">MDN-Falsy</a>、<a href="https://dorey.github.io/JavaScript-Equality-Table/">dorey-JS Comparison Table</a></p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="💎-null-和-undefined-出現時機"><a href="#💎-null-和-undefined-出現時機" class="headerlink" title="💎 null 和 undefined 出現時機"></a>💎 null 和 undefined 出現時機</h2><p>除了未賦值的 undefined 和自己定義的 null 外，還有什麼時候會出現呢？</p>
<ul>
<li><code>null</code>：會出現在 BOM(Browser Object Model)中不存在的資料，例如：document.querySelector、localStorage、 sessionStorage…等，不存在時會得到 null。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">localStorage.getItem(&#x27;a&#x27;); // null</span><br><span class="line">sessionStorage.getItem(&#x27;a&#x27;); // null</span><br></pre></td></tr></table></figure></li>
<li><code>undefined</code>：取用不存在 JS 程式碼中或是未賦值的資料會得到 undefined。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let arr = [];</span><br><span class="line">let obj = &#123;&#125;;</span><br><span class="line">console.log(arr[1]); // undefined</span><br><span class="line">console.log(obj.a); // undefined</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<p>以上是我對這兩個型別的一點認知，如有錯誤或是補充的知識點，也歡迎大家不吝指教，謝謝觀看！</p>
]]></content>
      <categories>
        <category>JavaScript - Basic</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>[後端] 如何讓 Heroku 上的專案使用固定 IP 連接 MongoDB Atlas 服務？</title>
    <url>/2022/04/23/heroku-ip/</url>
    <content><![CDATA[<p><img data-src="https://i.imgur.com/h2c7vhC.png"></p>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在閱讀以下內容前，請先確認你有一張<code>信用卡</code>可以註冊到 Heroku 的帳戶內，如果沒有，請嘗試使用其他免費網路空間服務。</p>
<hr>
<h2 id="基礎概念"><a href="#基礎概念" class="headerlink" title="基礎概念"></a>基礎概念</h2><p>隨著硬體技術越來越強，儲存空間的單位成本越來越低，於是有各種雲端空間服務可以使用，但是網路 IP 是有限的共享資源，由各地區的 ISP 業者分配使用（以台灣來說，需要申請中華電信線路，再申請固定 IP），雲端空間業者不會持有大量的 IP 讓用戶使用，通常是以內部固定 IP 加上動態分配外部 IP 來連線。</p>
<p>資料庫用來儲存網站的各種資料，通常也會包含大量的客戶資訊（姓名、手機、信箱…等），這些個資或商業機密一旦外洩就會造成公司和客戶的嚴重損失，最基礎的第一道防線就是網路防火牆，只能允許網頁（App）伺服器對資料庫（DB）伺服器連線（設置白名單規則）。</p>
<hr>
<h2 id="設置-Heroku-連線-IP-的三種方法"><a href="#設置-Heroku-連線-IP-的三種方法" class="headerlink" title="設置 Heroku 連線 IP 的三種方法"></a>設置 Heroku 連線 IP 的三種方法</h2><p>MongoDB 的文件 <a href="https://www.mongodb.com/developer/how-to/use-atlas-on-heroku/#configuring-heroku-ip-addresses-in-mongodb-atlas">Configuring Heroku IP Addresses in MongoDB Atlas</a> 有介紹幾個方法讓 Heroku 使用固定 IP 連線：</p>
<ol>
<li>使用插件（add-on）來提供固定的對外 IP，也就是這篇文章要介紹的方法。</li>
<li>使用 Heroku Private Spaces 來設置固定 IP，雖然不需要安裝插件（add-on），但是需要<code>$$$</code>，無課仔表示：下面一位！</li>
<li>直接把所有 Heroku 會使用的動態 IP 加到白名單中，文章中沒有提供到底是哪些 IP，表示要自己找，而且這個方法非常不保險，萬一動態 IP 清單變了，服務突然就掛了。</li>
</ol>
<hr>
<h2 id="Heroku-Addons-說明"><a href="#Heroku-Addons-說明" class="headerlink" title="Heroku Addons 說明"></a>Heroku Addons 說明</h2><p>我們可以到 Heroku 的 <a href="https://elements.heroku.com/addons/categories/network">Network Services Addons</a> 中看到有許多網路服務的插件可以選擇，這些插件並不是直接提供固定 IP，而是以代理的方式來達到固定 IP 的效果。</p>
<p>了解 Addons 的運作方式，事情並沒有因此豁然開朗，這麼多的 Addons 根本不知道要選哪個！先講結論：我使用的是<code>QuotaGuard Static IP&#39;s</code><br><img data-src="https://i.imgur.com/gBa3Uie.png"></p>
<p>每個 Addons 提供的應用不太一樣，有些使用他的函式庫來取代 Axios（或 fetch），透過 Addons 函式庫的方法設置好代理參數後發出 GET 請求，但這種方式提供的是 HTTP 代理，僅適用 HTTP/HTTPS 的連線，MongoDB 的連線就無法使用了（網路層級不同）。</p>
<p>QuotaGuard Static IP’s 提供了 SOCKS 代理，他可以監聽 Heroku App 的連線請求，並且把對 MongoDB 的連線導向自己，再由 Addons 把請求送給 MongoDB，所以對 MongoDB 來說，收到的請求來源都會是 QuotaGuard Static IP’s 提供的固定 IP。</p>
<p><code>原始連線模式</code><br><code>Heroku(IP: ??.??.??.??) -&gt; MongoDB Atlas(無法限制來源)</code></p>
<p><code>代理連線模式</code><br><code>Heroku(IP: ??.??.??.??) -&gt; Proxy(某個固定 IP) -&gt; MongoDB Atlas(只接受 Proxy 的固定 IP)</code></p>
<hr>
<h2 id="實作開始"><a href="#實作開始" class="headerlink" title="實作開始"></a>實作開始</h2><p>整個實作過程，都是參考 QuotaGuard 的 <a href="https://quotaguard.github.io/qg-docs/mongo-start">How to Connect to MongoDB using QuotaGuard</a> 文件進行，雖然他寫的蠻詳細的，但是要弄清楚還是得費一番功夫。</p>
<p>馬上進入實作步驟：</p>
<ol>
<li><p>請到 Heroku 的 <a href="https://elements.heroku.com/addons/categories/network">Network Services Addons</a> 選擇 QuotaGuard Static IP’s。<br><img data-src="https://i.imgur.com/WmOE7qr.png"></p>
</li>
<li><p>選擇 Addons 之後建議還是先往下拉看一下價錢，確認有免費的，才能為荷包把關。<br><img data-src="https://i.imgur.com/Jd6dqcr.png"></p>
</li>
<li><p>價錢確認後，可以回到最上方的右邊點選 install 按鈕安裝。<br><img data-src="https://i.imgur.com/uxqdLN1.png"></p>
</li>
<li><p>進入提交頁面後，請先確認收費方式，接著在下方輸入要設置代理的專案名稱（專案名稱可以到自己的 Heroku 頁面查看），選取好專案後就可以點擊按鈕進入下一步。<br><img data-src="https://i.imgur.com/5TE71dH.png"></p>
</li>
<li><p>如果帳號沒有綁定信用卡，就會跳出警告，不讓你安裝，請完成綁定才能進行下一步。<br><img data-src="https://i.imgur.com/r3sC9sX.png"></p>
</li>
<li><p>裝完後會進入 資源列表（Resources）畫面，點擊「QuotaGuard Static IP’s」進入，首次進入會出現一些條款需要拉到最底下點擊同意（後續再點擊就會導向操作面板了）。<br><img data-src="https://i.imgur.com/s2oPz4e.png"></p>
</li>
<li><p>接下來請回到 VScode，開啟佈署到這個 Heroku 專案的資料夾，接著在終端機輸入以下指令來安裝 QuotaGuard 的相關檔案，執行完成後會多出一個 vender 資料夾和一些檔案。</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl https://s3.amazonaws.com/quotaguard/qgtunnel-latest.tar.gz | tar xz</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>接著再開啟瀏覽器進入操作面板網址 <a href="https://www.quotaguard.com/dashboard">https://www.quotaguard.com/dashboard</a>，或是在終端機輸入以下指令，會開啟瀏覽器進入相同頁面。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">heroku addons:open quotaguardstatic</span><br></pre></td></tr></table></figure>

<ol start="9">
<li><p>點選操作面板右上方的「齒輪」圖案，再點選「QGTunnel Configuration」<br><img data-src="https://i.imgur.com/FGmOhRK.png"><br><img data-src="https://i.imgur.com/O96KcjE.png"></p>
</li>
<li><p>點擊右上方的綠色「＋」按鈕來新增 Tunnel。<br><img data-src="https://i.imgur.com/cHn7PPJ.png"></p>
</li>
<li><p>請開啟一個網頁分頁，並登入 MongoDB Atlas，點選你的 cluster 名稱進入詳細資訊頁面。<br><img data-src="https://i.imgur.com/XmGmsS6.png"></p>
</li>
<li><p>REGION 區塊有好幾個 cluster，請每個都點進去，然後把完整的名稱複製下來。<br><img data-src="https://i.imgur.com/D7Z3UbA.png"></p>
</li>
<li><p>回到步驟 10 的 新增 Tunnel 頁面，把剛才 mongoDB 複製下來的字串建立起來，有幾個就建幾筆（通常會有三筆，有關 cluster 的連線字串在 <a href="https://quotaguard.github.io/qg-docs/mongo-expanding">QuotaGuard 的文件</a>也有說明），設定資訊如下：</p>
</li>
</ol>
<ul>
<li>Remote Destination：MongoDB Atlas 內 cluster region 的完整名稱，建立完成後系統會在前面自動加上 “tcp://“，這是正常的。<br>（名稱範例：xxxxxx-xxxx-00-00.xxxxx.mongodb.net:27017）</li>
<li>Local Port：27017（MongoDB 的 Port）</li>
<li>Transparent：透通模式請開啟</li>
<li>Encrypted：加密模式可以不用開</li>
<li>Optional Name：可以為這個 Tunnel 設定名稱，也可以空著。<br><img data-src="https://i.imgur.com/qovLACV.png"></li>
</ul>
<ol start="14">
<li>回到 VScode，在專案的根目錄新增一個檔案，檔案名稱是 Procfile (請不要加入任何副檔名，txt 也不行)，這個檔名是 Heroku 的設定檔，在裡面撰寫導入 addons 的啟動指令，撰寫格式如下：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">web: bin/qgtunnel 啟動程式名稱 啟動指令和參數</span><br></pre></td></tr></table></figure>

<p>以 node.js 為例，啟動指令是 <code>npm start</code>，Procfile 內撰寫的就是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">web: bin/qgtunnel npm start</span><br></pre></td></tr></table></figure>

<p><img data-src="https://i.imgur.com/MQ0zwPR.png" alt="範例圖片"></p>
<ol start="15">
<li><p>接下來就可以執行 git add &amp; commit 把修改好的專案 push 到 Heroku 上，在 commit 前請用 git status 確認 vender 資料夾內的檔案和 Procfile 都有加入，一個都不能少！</p>
</li>
<li><p>推送完後先確認一下 app 會不會 crash，如果正常運行就可以回到 QuotaGuard 的操作面板 <a href="https://www.quotaguard.com/dashboard">https://www.quotaguard.com/dashboard</a>，把左上方的兩個 IP 設定到 MongoDB Atlas 裡面的 Network Access，<code>IP 後面請加上 /32</code>，這個遮罩表示單一 IP，如果後面是 /0，不管前面打什麼 IP，任何人都可以連的到！</p>
</li>
<li><p>設定完之後就可以測試，在本地用 Compass 連和從 Heroku 主機連線是否一個不能連、一個能連，測試沒問題就大功告成啦！</p>
</li>
</ol>
<h2 id="補充"><a href="#補充" class="headerlink" title="補充"></a>補充</h2><ul>
<li>官方文件有建議把 Tunnel 的設定備份下來，可以自行考量需不需要。</li>
<li>Heroku 安裝 QuotaGuard Static IP’s 時會自動為該專案建立一條名稱為 <code>QUOTAGUARDSTATIC_URL</code> 的環境變數，如果連線失敗可以查看一下這個環境變數有沒有建立起來。</li>
<li>正常狀況下加入 QuotaGuard Static IP’s 不會影響原始 App 的運作，因為他只是個封包傳輸的代理程式。</li>
</ul>
]]></content>
      <tags>
        <tag>Node.js</tag>
        <tag>MongoDB</tag>
        <tag>Atlas</tag>
        <tag>Heroku</tag>
      </tags>
  </entry>
  <entry>
    <title>[Node.JS] 打造 todolist api 2 - 撰寫程式基本架構</title>
    <url>/2022/03/02/nodejs3/</url>
    <content><![CDATA[<p><img data-src="/images/nodejs-logo.png"></p>
<span id="more"></span>
<p>前一篇整理的資訊中共有 5 種請求方法和延伸的處理結果需要撰寫，在這篇文章中就要建立這些功能的結構。</p>
<hr>
<h2 id="💎-基礎-route-撰寫"><a href="#💎-基礎-route-撰寫" class="headerlink" title="💎 基礎 route 撰寫"></a>💎 基礎 route 撰寫</h2><p>前面練習的網址都是使用根目錄（/），在網址加上一個路徑名稱才能方便辨識這個 api 的用途，方法很簡單，加入一個 if…else 來判斷 <code>req.url</code> 即可。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 比對請求的網址後名的路徑是不是設定好的字串</span></span><br><span class="line">   <span class="keyword">if</span> (req.url == <span class="string">&#x27;/todo&#x27;</span>) &#123;</span><br><span class="line">      res.writeHead(<span class="number">200</span>, headers);</span><br><span class="line">      <span class="comment">// 調整回傳的內容</span></span><br><span class="line">      res.write(<span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">         <span class="string">&quot;status&quot;</span>: <span class="string">&quot;true&quot;</span></span><br><span class="line">      &#125;));</span><br><span class="line">      res.end();</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 不符合路徑就傳 404 錯誤</span></span><br><span class="line">      res.writeHead(<span class="number">404</span>, headers);</span><br><span class="line">      <span class="comment">// 調整回傳的內容</span></span><br><span class="line">      res.write(<span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">         <span class="string">&quot;status&quot;</span>: <span class="string">&quot;false&quot;</span></span><br><span class="line">      &#125;));</span><br><span class="line">      res.end();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>段落測試</strong>：使用瀏覽器連 <code>http://127.0.0.1:3000</code> 和 <code>http://127.0.0.1:3000/todo</code> 查看是否有不同結果。</p>
</blockquote>
<hr>
<h2 id="💎-建立回應函式"><a href="#💎-建立回應函式" class="headerlink" title="💎 建立回應函式"></a>💎 建立回應函式</h2><p>前一個步驟中加入了第一個判斷，就可以發現 <code>res</code> 有許多程式碼重複，後續還有各種方法的判斷，可以先把它抽出來寫成函式避免後續產生大量重複程式碼。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sendResponse = <span class="function">(<span class="params">res, statusCode, data</span>) =&gt;</span> &#123;</span><br><span class="line">   res.writeHead(statusCode, headers);</span><br><span class="line">   res.write(<span class="built_in">JSON</span>.stringify(data));</span><br><span class="line">   res.end();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (req.url == <span class="string">&#x27;/todo&#x27;</span>) &#123;</span><br><span class="line">      sendResponse(res, <span class="number">200</span>, &#123;</span><br><span class="line">         <span class="string">&quot;status&quot;</span>: <span class="string">&quot;true&quot;</span></span><br><span class="line">      &#125;);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      sendResponse(res, <span class="number">404</span>, &#123;</span><br><span class="line">         <span class="string">&quot;status&quot;</span>: <span class="string">&quot;false&quot;</span></span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>段落測試</strong>：使用瀏覽器連 <code>http://127.0.0.1:3000</code> 和 <code>http://127.0.0.1:3000/todo</code> 查看是否運作正常。</p>
</blockquote>
<hr>
<h2 id="💎-判斷各種連線方法"><a href="#💎-判斷各種連線方法" class="headerlink" title="💎 判斷各種連線方法"></a>💎 判斷各種連線方法</h2><p>用來判別各種狀況的基本寫法是 <code>if...else</code> 和 <code>switch...case</code>，這部份的判斷方式因人而異，可以自行思考設計，以下個人的寫法僅供參考，也歡迎大家提出改善建議。</p>
<h3 id="🚩-OPTIONS"><a href="#🚩-OPTIONS" class="headerlink" title="🚩 OPTIONS"></a>🚩 OPTIONS</h3><p>本次練習中提供了 5 種連線方法，其中 <code>OPTIONS</code> 較為特別，這個方法像是打招呼一樣，只需要回傳 <code>狀態碼</code> 和 <code>headers</code> 即可（就像互相問候，不用說具體的內容），可以放在判斷條件的第一條處理。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sendResponse = <span class="function">(<span class="params">statusCode, data</span>) =&gt;</span> &#123;</span><br><span class="line">   res.writeHead(statusCode, headers);</span><br><span class="line">   <span class="comment">// 增加判斷，有資料時才回傳</span></span><br><span class="line">   <span class="keyword">if</span> (data) &#123;</span><br><span class="line">      res.write(<span class="built_in">JSON</span>.stringify(data));</span><br><span class="line">   &#125;</span><br><span class="line">   res.end();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 修改成使用變數</span></span><br><span class="line">   <span class="keyword">if</span> (req.method == <span class="string">&#x27;OPTIONS&#x27;</span>) &#123;</span><br><span class="line">      sendResponse(res, <span class="number">200</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.url == <span class="string">&#x27;/todo&#x27;</span>) &#123;</span><br><span class="line">      sendResponse(res, <span class="number">200</span>, &#123;</span><br><span class="line">         <span class="string">&quot;status&quot;</span>: <span class="string">&quot;true&quot;</span></span><br><span class="line">      &#125;);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      sendResponse(res, <span class="number">404</span>, &#123;</span><br><span class="line">         <span class="string">&quot;status&quot;</span>: <span class="string">&quot;false&quot;</span></span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>💡💡 重要 💡💡</code><br><strong>段落測試</strong>：此處開始（包含後續的步驟）需要使用 POSTMAN 軟體來模擬各種連線方法測試。<br><strong>測試內容</strong>：方法 <code>OPTIONS</code>、網址 <code>http://127.0.0.1:3000(後方可加任意字串來測試不同的回應)</code><br><strong>參考資料</strong>：<a href="https://israynotarray.com/other/20211207/427026/">是 Ray 不是 Array - POSTMAN 教學</a></p>
</blockquote>
<h3 id="🚩-其他方法"><a href="#🚩-其他方法" class="headerlink" title="🚩 其他方法"></a>🚩 其他方法</h3><p>先把其他會用到的方法加到程式碼中，再針對每個項目補完功能，此處我使用的是 switch…case，也可以 elseif 到底。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (req.method == <span class="string">&#x27;OPTIONS&#x27;</span>) &#123;</span><br><span class="line">      sendResponse(res, <span class="number">200</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.url == <span class="string">&#x27;/todo&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// 新增各種方法的判斷，並稍微調整回傳內容來測試</span></span><br><span class="line">      <span class="keyword">switch</span> (req.method) &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">&#x27;GET&#x27;</span>:</span><br><span class="line">            sendResponse(res, <span class="number">200</span>, &#123;</span><br><span class="line">               <span class="string">&quot;status&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">               <span class="string">&quot;method&quot;</span>: <span class="string">&quot;GET&quot;</span></span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">            sendResponse(res, <span class="number">200</span>, &#123;</span><br><span class="line">               <span class="string">&quot;status&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">               <span class="string">&quot;method&quot;</span>: <span class="string">&quot;POST&quot;</span></span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">&#x27;PATCH&#x27;</span>:</span><br><span class="line">            sendResponse(res, <span class="number">200</span>, &#123;</span><br><span class="line">               <span class="string">&quot;status&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">               <span class="string">&quot;method&quot;</span>: <span class="string">&quot;PATCH&quot;</span></span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">&#x27;DELETE&#x27;</span>:</span><br><span class="line">            sendResponse(res, <span class="number">200</span>, &#123;</span><br><span class="line">               <span class="string">&quot;status&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">               <span class="string">&quot;method&quot;</span>: <span class="string">&quot;DELETE&quot;</span></span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="comment">// 不符合這些請求方式就回傳錯誤碼</span></span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">            sendResponse(res, <span class="number">405</span>, &#123;</span><br><span class="line">               <span class="string">&quot;status&quot;</span>: <span class="string">&quot;false&quot;</span></span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      sendResponse(res, <span class="number">404</span>, &#123;</span><br><span class="line">         <span class="string">&quot;status&quot;</span>: <span class="string">&quot;false&quot;</span></span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>段落測試</strong><br><strong>測試網址</strong>：<code>http://127.0.0.1:3000/todo</code><br><strong>測試方法</strong>：GET、POST、PATCH、DELETE（使用 POSTMAN）</p>
</blockquote>
<h3 id="🚩-修改、刪除指定資料"><a href="#🚩-修改、刪除指定資料" class="headerlink" title="🚩 修改、刪除指定資料"></a>🚩 修改、刪除指定資料</h3><p>指定資料的修改（PATCH）、刪除（DELETE）在設計上會使用 <code>http://網域/路徑/參數 (例如：http://127.0.0.1:3000/todo/abcd12345)</code> 這個格式的網址，在參數內帶入指定資料的 ID，這時候就無法使用 <code>req.url == &#39;/todo&#39;</code> 來比對（結果會是 false），需要分開判斷。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (req.method == <span class="string">&#x27;OPTIONS&#x27;</span>) &#123;</span><br><span class="line">      sendResponse(res, <span class="number">200</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.url == <span class="string">&#x27;/todo&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (req.method) &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">&#x27;GET&#x27;</span>:</span><br><span class="line">            sendResponse(res, <span class="number">200</span>, &#123;</span><br><span class="line">               <span class="string">&quot;status&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">               <span class="string">&quot;method&quot;</span>: <span class="string">&quot;GET&quot;</span></span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">            sendResponse(res, <span class="number">200</span>, &#123;</span><br><span class="line">               <span class="string">&quot;status&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">               <span class="string">&quot;method&quot;</span>: <span class="string">&quot;POST&quot;</span></span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="comment">/* PATCH 方法調整到下一個判斷 */</span></span><br><span class="line">         <span class="comment">// case &#x27;PATCH&#x27;:</span></span><br><span class="line">         <span class="comment">//    sendResponse(res, 200, &#123;</span></span><br><span class="line">         <span class="comment">//       &quot;status&quot;: &quot;true&quot;,</span></span><br><span class="line">         <span class="comment">//       &quot;method&quot;: &quot;PATCH&quot;</span></span><br><span class="line">         <span class="comment">//    &#125;);</span></span><br><span class="line">         <span class="comment">//    break;</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">// DELETE 方法有兩種操作（單筆或全部），這邊保留的用來刪除全部（不需要ID）</span></span><br><span class="line">         <span class="keyword">case</span> <span class="string">&#x27;DELETE&#x27;</span>:</span><br><span class="line">            sendResponse(res, <span class="number">200</span>, &#123;</span><br><span class="line">               <span class="string">&quot;status&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">               <span class="string">&quot;method&quot;</span>: <span class="string">&quot;DELETE&quot;</span></span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="comment">// 不符合這些請求方式就回傳錯誤碼</span></span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">            sendResponse(res, <span class="number">405</span>, &#123;</span><br><span class="line">               <span class="string">&quot;status&quot;</span>: <span class="string">&quot;false&quot;</span></span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="comment">// 使用 startsWith 方法來比對路徑開頭</span></span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.url.startsWith(<span class="string">&#x27;/todo/&#x27;</span>)) &#123;</span><br><span class="line">      <span class="comment">// 修改單筆資料</span></span><br><span class="line">      <span class="keyword">if</span> (req.method == <span class="string">&#x27;PATCH&#x27;</span>) &#123;</span><br><span class="line">         sendResponse(res, <span class="number">200</span>, &#123;</span><br><span class="line">            <span class="string">&quot;status&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">            <span class="string">&quot;method&quot;</span>: <span class="string">&quot;PATCH + id&quot;</span></span><br><span class="line">         &#125;);</span><br><span class="line">      <span class="comment">// 刪除單筆資料</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.method == <span class="string">&#x27;DELETE&#x27;</span>) &#123;</span><br><span class="line">         sendResponse(res, <span class="number">200</span>, &#123;</span><br><span class="line">            <span class="string">&quot;status&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">            <span class="string">&quot;method&quot;</span>: <span class="string">&quot;DELETE + id&quot;</span></span><br><span class="line">         &#125;);</span><br><span class="line">      <span class="comment">// 不符合上述兩種方法時回應錯誤</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         sendResponse(res, <span class="number">405</span>, &#123;</span><br><span class="line">            <span class="string">&quot;status&quot;</span>: <span class="string">&quot;false&quot;</span></span><br><span class="line">         &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      sendResponse(res, <span class="number">404</span>, &#123;</span><br><span class="line">         <span class="string">&quot;status&quot;</span>: <span class="string">&quot;false&quot;</span></span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>段落測試</strong><br><strong>測試網址</strong>：<code>http://127.0.0.1:3000/todo/(任一字串)</code><br><strong>測試方法</strong>：PATCH、DELETE（使用 POSTMAN）</p>
</blockquote>
<hr>
<h2 id="💎-結語"><a href="#💎-結語" class="headerlink" title="💎 結語"></a>💎 結語</h2><p>本篇的筆記已經完成所有方法的架構，下一篇完結篇就會補上所有的功能。</p>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>[Node.JS] 打造 todolist api 1 - 行前準備</title>
    <url>/2022/02/24/nodejs2/</url>
    <content><![CDATA[<p><img data-src="/images/nodejs-logo.png"></p>
<span id="more"></span>
<p>上一篇文章完成了網頁伺服器服務的建置，這一次就更進一步的製作一個簡單的 todolist API，讓他有新增、修改、刪除的功能。</p>
<hr>
<h2 id="💎-流程、架構規劃"><a href="#💎-流程、架構規劃" class="headerlink" title="💎 流程、架構規劃"></a>💎 流程、架構規劃</h2><p>六角學院的課程中都會以流程圖的方式，這對於循序漸進完成程式功能會非常有幫助，在完成第一個版本後就可以嘗試重構和模組化，下面是我整理出的結構，每個人在撰寫程式碼時的構思不盡相同，可以自行規劃。</p>
<ul>
<li><code>工具</code><ul>
<li>NPM/Yarn：套件管理工具</li>
<li>UUID 套件：用來建立待辦事項的 id</li>
<li>nodemon 套件：建立可即時更新的本地伺服器</li>
<li>POSTMAN 軟體：模擬 http 請求，做功能測試</li>
<li>Git/GitHub：版本控制</li>
<li>代管平台（heroku）：api 服務上線</li>
</ul>
</li>
<li><code>server</code>：啟用 api 的主要程式碼<ul>
<li>http：使用 node.js 原生的模組</li>
<li>headers：回傳 json 格式，開放跨域（CORS），提供 route 的五種請求方法</li>
<li>port：要加入環境變數（process.env.PORT）</li>
</ul>
</li>
<li><code>route</code>：依請求決定要執行的動作<ul>
<li>OPTIONS：回應表頭就好</li>
<li>GET：回應全部待辦</li>
<li>POST：新增一筆待辦、回應全部待辦，需要檢查 body 內容</li>
<li>DELETE<ul>
<li>單筆：刪除一筆待辦、回應全部待辦，需要檢查 url 的 id</li>
<li>全部：刪除全部待辦、回應全部待辦</li>
</ul>
</li>
<li>PATCH：修改一筆待辦、回應全部待辦，需要檢查 url 的 id、body 內容</li>
</ul>
</li>
<li><code>response</code>：回傳資料優化<ul>
<li>success：回傳（無內容或待辦資料）</li>
<li>false：回傳錯誤代碼及錯誤訊息</li>
</ul>
</li>
<li><code>constants</code>：常用的常數<ul>
<li>（視實際撰寫的重複使用狀況獨立出來）</li>
</ul>
</li>
</ul>
<hr>
<h2 id="💎-建立專案環境"><a href="#💎-建立專案環境" class="headerlink" title="💎 建立專案環境"></a>💎 建立專案環境</h2><ol>
<li>建立一個新專案資料夾。</li>
<li>執行 <code>npm init</code> 指令來製作 package.json 檔案。</li>
<li>執行 <code>npm i uuid</code> 來安裝 UUID 套件（後續待辦事項的編號使用）。<blockquote>
<p><a href="https://zh.wikipedia.org/zh-tw/%E9%80%9A%E7%94%A8%E5%94%AF%E4%B8%80%E8%AF%86%E5%88%AB%E7%A0%81">Wiki - UUID</a><br><a href="https://www.npmjs.com/package/uuid">npm - uuid</a></p>
</blockquote>
</li>
<li>在專案資料夾中建立一個 server.js 檔案。</li>
<li>先參考官方範例在 server.js 內撰寫啟用伺服器的程式碼：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;<span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;text/plain&quot;</span>&#125;);</span><br><span class="line">    res.write(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    res.end();</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="number">8000</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>段落測試：</p>
<ol>
<li>執行 <code>nodemon server.js</code> 測試是否有錯誤資訊（如果環境沒有 nodemon，請執行 <code>npm i -g nodemon</code> 全域安裝）</li>
<li>開啟任一瀏覽器，連線本地網址 <code>http://127.0.0.1:8000</code>，確認是否正常顯示回傳的資料。</li>
</ol>
</blockquote>
<hr>
<h2 id="💎-伺服器設定調整"><a href="#💎-伺服器設定調整" class="headerlink" title="💎 伺服器設定調整"></a>💎 伺服器設定調整</h2><ol>
<li><strong>修改預設 header</strong></li>
</ol>
<ul>
<li>todolist api 設計成回傳 json 檔，所以要把 <code>Content-Type</code> 改成 <code>application/json</code>。</li>
<li>加入開放哪些 <code>Headers</code> 和 <code>Methods</code> 的設定。</li>
<li>加入允許所有來源的跨域連線請求（<code>CORS</code>）。<blockquote>
<p>跨域請求可以參考 <a href="https://developer.mozilla.org/zh-TW/docs/Web/HTTP/CORS">MDN - CORS</a></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// header 獨立成一個常數</span></span><br><span class="line"><span class="keyword">const</span> headers = &#123;</span><br><span class="line">    <span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>: <span class="string">&#x27;Content-Type, Authorization, Content-Length, X-Requested-With&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>: <span class="string">&#x27;*&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span>: <span class="string">&#x27;PATCH, POST, GET, OPTIONS, DELETE&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 修改成使用變數</span></span><br><span class="line">    res.writeHead(<span class="number">200</span>, headers);</span><br><span class="line">    <span class="comment">// 修改成回傳 json 格式的內容</span></span><br><span class="line">    <span class="comment">// 此處需要注意，網路封包傳送的資料只有純字串，需要先轉換</span></span><br><span class="line">    res.write(<span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">       <span class="string">&quot;test&quot;</span>: <span class="string">&quot;Hello&quot;</span></span><br><span class="line">    &#125;));</span><br><span class="line">    res.end();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li><strong>修改預設 port</strong></li>
</ol>
<ul>
<li>加入環境變數，佈署到代管服務才能正常運行。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; PORT = <span class="number">3000</span> &#125; = process.env;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">server.listen(PORT);</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>段落測試：<br>開啟任一瀏覽器，連線本地網址 <code>http://127.0.0.1:3000</code>，確認是否正常顯示回傳的資料。</p>
</blockquote>
<hr>
<h2 id="💎-結語"><a href="#💎-結語" class="headerlink" title="💎 結語"></a>💎 結語</h2><p>本篇文章已經完成基本的環境建立，並且整理出程式需要撰寫的內容，下一篇文章就可以依照這個結構逐步完成所有的功能。</p>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>[Node.JS] 建立伺服器、掌握基本知識</title>
    <url>/2022/02/22/nodejs1/</url>
    <content><![CDATA[<p><img data-src="/images/nodejs-logo.png"></p>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本系列文章記錄了如何用最基礎的方式建立 Node.js API 服務，目的在了解基本運作原理，實務上會運用其他框架、插件和中介軟體（Middleware）來快速完成環境建置。</p>
<hr>
<h2 id="💎-基本技能-－-模組引用"><a href="#💎-基本技能-－-模組引用" class="headerlink" title="💎 基本技能 － 模組引用"></a>💎 基本技能 － 模組引用</h2><p>在 Node.js 中會使用 JavaScript 的模組方法來載入各種功能，這個段落會先介紹如何操作，如果已經熟悉可以跳過，進入下個段落。</p>
<p>範例情境：</p>
<ul>
<li>主要檔案：a.js</li>
<li>模組－寫法１：b.js</li>
<li>模組－寫法２：c.js</li>
</ul>
<h3 id="a-js"><a href="#a-js" class="headerlink" title="a.js"></a>a.js</h3><ul>
<li>使用 require 來引入其他資源</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自己的變數</span></span><br><span class="line"><span class="keyword">let</span> contentA = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 引用 b.js，如果被引用的檔案在相同目錄，路徑前方加上 ./</span></span><br><span class="line"><span class="keyword">const</span> contentB = <span class="built_in">require</span>(<span class="string">&#x27;./b&#x27;</span>);</span><br><span class="line"><span class="comment">// 引用 c.js</span></span><br><span class="line"><span class="keyword">const</span> contentC = <span class="built_in">require</span>(<span class="string">&#x27;./c&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(contentA); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 變數存放了回傳的整個物件</span></span><br><span class="line"><span class="built_in">console</span>.log(contentB); <span class="comment">// &#123;...&#125;</span></span><br><span class="line"><span class="comment">// 可以使用物件方法取得裡面的值</span></span><br><span class="line"><span class="built_in">console</span>.log(contentB.title); <span class="comment">// B</span></span><br><span class="line"><span class="built_in">console</span>.log(contentB.getNum()); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(contentC); <span class="comment">// &#123;...&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(contentC.title); <span class="comment">// C</span></span><br><span class="line"><span class="built_in">console</span>.log(contentC.getNum()); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h3 id="b-js"><a href="#b-js" class="headerlink" title="b.js"></a>b.js</h3><ul>
<li>使用 module.exports 設定被引用時提供的資料</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法１－ 直接設定要輸出的資料，多個資料時通常用物件格式來存放</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;B&#x27;</span>,</span><br><span class="line">  <span class="attr">getNum</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="c-js"><a href="#c-js" class="headerlink" title="c.js"></a>c.js</h3><ul>
<li>使用 exports.屬性名稱 設定被引用時提供的資料</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法２－ 新增屬性的方式逐一增加輸出的資料</span></span><br><span class="line"><span class="built_in">exports</span>.title = <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line"><span class="built_in">exports</span>.getNum = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="💎-創建本地伺服器-－-createServer"><a href="#💎-創建本地伺服器-－-createServer" class="headerlink" title="💎 創建本地伺服器 － createServer"></a>💎 創建本地伺服器 － createServer</h2><p>學會模組引用的操作後，就可以試著撰寫第一個 js 檔案，讓 Node.js 建立一個伺服器服務：<br><code>以下開發環境都使用 VS Code</code></p>
<ol>
<li><strong>建立伺服器 js 檔 （檔名自定)</strong><br>下面這段程式碼是 node.js 官方範例</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引用 http 模組</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="comment">// 建立一個本地伺服器，設定接收到請求後的回傳資料</span></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123; <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/plain&#x27;</span> &#125;);</span><br><span class="line">  res.write(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line">  res.end();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 使用 8000 port</span></span><br><span class="line">server.listen(<span class="number">8000</span>);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>啟動伺服器</strong><br>開啟終端機（熱鍵為 Ctrl + <code>`</code>），使用 Node.js 執行撰寫好的檔案，如果沒有跳出錯誤訊息就表示本地伺服器成功運行了。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">** 請先將路徑切換到 js 存放的位置，檔案名稱修改為自己設定的名稱 **</span><br><span class="line">node 檔案名稱.js</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p><strong>關閉伺服器</strong><br>伺服器執行的狀態下，在終端機視窗內按下 <code>Ctrl+C</code> 就可以終止。</p>
</li>
<li><p><strong>連線測試</strong><br>伺服器正常運作後可以開啟瀏覽器，輸入網址 <code>http://127.0.0.1:8000</code>，沒有問題的話就會顯示 <code>Hello</code>，這段網址中的 127.0.0.1 表示這部電腦的本地位置，冒號加上數字 8000 就可以指定使用前面步驟設定的 port 來連線。</p>
</li>
<li><p><strong>修改測試</strong><br>試著修改 Content-Type 或 res.write 的內容，讓網頁顯示不一樣的資訊。<br>每次修改儲存後都需要重起 node，可以透過 npm 安裝 <code>nodemon</code> 這個套件，就能在編輯檔案後自動重新載入伺服器。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">** 安裝指令（建議全域安裝）**</span><br><span class="line">npm i -g nodemon</span><br><span class="line"></span><br><span class="line">** 使用 nodemon 來執行 js 檔案 **</span><br><span class="line">nodemon app.js</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a href="https://www.npmjs.com/package/nodemon">npm - nodemon</a></p>
</blockquote>
<h2 id="💎-程式碼說明"><a href="#💎-程式碼說明" class="headerlink" title="💎 程式碼說明"></a>💎 程式碼說明</h2><h3 id="http"><a href="#http" class="headerlink" title="http"></a>http</h3><p>程式一開始引用了 node.js 中的 <code>http</code> 模組，並使用 createServer 方法來建立伺服器，模組的其他功能可以參考官方文件。</p>
<blockquote>
<p><a href="https://nodejs.org/dist/latest-v16.x/docs/api/http.html#httpcreateserveroptions-requestlistener">官方說明文件 - http</a></p>
</blockquote>
<h3 id="監聽連線請求"><a href="#監聽連線請求" class="headerlink" title="監聽連線請求"></a>監聽連線請求</h3><p>createServer 方法裡面傳入的函式像是 addEventListener 事件偵測，但監聽的<code>行為</code>是有沒有<code>連線請求</code>傳送到這台伺服器主機，這個監聽函式也可以使用變數獨立出來，增加一點可讀性，改寫後如下方程式碼：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="comment">// 監聽連線請求的函式</span></span><br><span class="line"><span class="keyword">const</span> requestListener = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123; <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/plain&#x27;</span> &#125;);</span><br><span class="line">  res.write(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line">  res.end();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 建立伺服器的參數帶入儲存函式的變數</span></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(requestListener);</span><br><span class="line">server.listen(<span class="number">8000</span>);</span><br></pre></td></tr></table></figure>

<h3 id="request"><a href="#request" class="headerlink" title="request"></a>request</h3><p>監聽函式帶有兩個參數，<code>req</code> 是 request（請求）的簡寫，當我們在瀏覽器網址列輸入網址送出連線，就會對該網址對應的伺服器主機發出請求，請求資訊會包含瀏覽器版本、需要的資源、請求的方式…等資訊，在 node.js 中可以透過 req 變數來查看詳細資訊。</p>
<ul>
<li>觀察 req 的內容：<br>修改監聽函式 &gt; 儲存檔案 &gt; 重啟伺服器 &gt; 瀏覽本地網址 &gt; 在終端機查看 req 資訊</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> requestListener = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 新增下面這段程式碼，來顯示請求的內容</span></span><br><span class="line">  <span class="built_in">console</span>.log(req);</span><br><span class="line"></span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123; <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/plain&#x27;</span> &#125;);</span><br><span class="line">  res.write(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line">  res.end();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>req 的常用屬性：<ul>
<li><code>req.url</code>：取得請求的資源路徑。一個網站會有好幾個檔案，透過這個屬性就可以取得請求的路徑，如果請求的網址後面沒有任何路徑，就會得到根目錄（/)，通常會設置回應首頁頁面。</li>
<li><code>req.method</code>：取得請求的方法。一般連線請求會使用 GET 方法，但是若有夾帶其他資訊時就會使用其他方法，各種方法可以參考 MDN 的說明。<blockquote>
<p><a href="https://developer.mozilla.org/zh-TW/docs/Web/HTTP/Methods">MDN - HTTP 請求方法</a></p>
</blockquote>
</li>
<li><code>req.on(&quot;data&quot;, ...)</code>：取得請求夾帶的資料。當連線使用 POST、PATCH…等方法時通常回夾帶資料給伺服器處理，就會需要使用這個方法來接收。</li>
<li><code>req.on(&quot;end&quot;, ...)</code>：資料接收完成後執行動作。網路封包傳遞會把資料切成片段，不會每次都一次傳完，所以在 on(data) 的階段無法確認收到的資料已經完成，要用這個方法才能確保資料接收完，再執行對應的程式碼。</li>
</ul>
</li>
</ul>
<h3 id="response"><a href="#response" class="headerlink" title="response"></a>response</h3><ul>
<li><code>res</code> 是 response（回應）的簡寫，伺服器收到請求後，就會把設定好的資訊傳回用戶端，在簡易的範例中只會回應 Hello 的文字，可以撰寫程式碼結合 req.url 和 req.method 判斷來回應不同的內容。</li>
<li><code>res.writeHead(status, header)</code>：回傳的表頭資訊。就像 req 一樣，res 不會只傳送單純的資料，需要包含各種資訊，status code 是狀態碼，200 就是成功，而 header 會告訴對方提供了哪些連線方法，這也是開發實務上容易採坑的地方，詳細的資訊都可以在 MDN 的 HTTP 主題中查看。<blockquote>
<p><a href="https://developer.mozilla.org/zh-TW/docs/Web/HTTP">MDN - HTTP</a></p>
</blockquote>
</li>
<li><code>Content-Type</code>：檔案格式。瀏覽器會依據這個屬性來決定怎麼讀取接收到的資料，常見的有 JSON(application/json)、HTML(text/html)、純文字(text/plain)…等。</li>
<li><code>res.end()</code>：程式運作不像人類會自主開始或停止，所以需要執行一段程式碼明確的告知『我傳完了』，否則用瀏覽器連網頁後頁籤上方會一直出現轉圈圈的圖示（表示持續等待回應中）。</li>
</ul>
<h3 id="listen-port"><a href="#listen-port" class="headerlink" title="listen(port)"></a>listen(port)</h3><ul>
<li><code>listen(8000)</code>：使用的通訊埠。HTTP 協定預設使用 80 port，1-1023 是系統保留，所以在自訂 port 的時候通常都是 X000 起跳。<blockquote>
<p><a href="https://zh.wikipedia.org/wiki/%E9%80%9A%E8%A8%8A%E5%9F%A0">Wiki - Port</a></p>
</blockquote>
</li>
<li><code>較安全的寫法</code>：寫好的網頁服務通常會放在各種雲端代管主機上，這些服務會由系統自動分配 port，如果程式碼寫死特定的 port，就無法跟雲端環境匹配，理所當然的就連不到，這時候可以利用環境變數 process.env.PORT 來取得執行環境的 port 號，就能動態調整讓服務正常運行，改寫如下：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PORT = process.env.PORT || XXXX;</span><br><span class="line"><span class="comment">// ES6 寫法</span></span><br><span class="line"><span class="keyword">const</span> &#123; PORT = XXXX &#125; = process.env;</span><br><span class="line"></span><br><span class="line">server.listen(PORT);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="💎-探索-Req-與-Res-－-Postman"><a href="#💎-探索-Req-與-Res-－-Postman" class="headerlink" title="💎 探索 Req 與 Res － Postman"></a>💎 探索 Req 與 Res － Postman</h2><p>Postman 是一套網頁請求模擬工具，相較於用瀏覽器的 Dev 工具，Postman 專注於檢查 Request &amp; Response，也能模擬各種請求行為（GET、POST、PATCH…等），有助於 API 的測試和 debug。</p>
<h3 id="安裝-Postman"><a href="#安裝-Postman" class="headerlink" title="安裝 Postman"></a>安裝 Postman</h3><p>前往 <a href="https://www.postman.com/downloads/">Postman 官方下載</a>，完成後執行安裝會跳轉至註冊會員網站，完成註冊後就可以使用了。</p>
<h3 id="使用-Postman"><a href="#使用-Postman" class="headerlink" title="使用 Postman"></a>使用 Postman</h3><p>進入操作介面後，一些設定或導覽可以都先略過，接著照以下步驟操作：</p>
<ol>
<li>先點擊上方選單 <code>HOME</code></li>
<li>點擊左側選單 <code>Workspaces</code></li>
<li>選擇 <code>My Workspace</code></li>
<li>點擊內容區塊上方分頁的 <code>+</code></li>
<li>在網址列裡面輸入任一網址或是本地的網址（例如本篇文章練習的 <code>http://127.0.0.1:8000</code>）</li>
<li>送出後就能查看詳細資訊了</li>
</ol>
<blockquote>
<p>詳細教學也可以參考：<br><a href="https://ithelp.ithome.com.tw/articles/10201503">六角學院 － Postman 教學文章</a></p>
</blockquote>
<hr>
<h2 id="💎-補充知識"><a href="#💎-補充知識" class="headerlink" title="💎 補充知識"></a>💎 補充知識</h2><h3 id="Global-全域物件"><a href="#Global-全域物件" class="headerlink" title="Global 全域物件"></a>Global 全域物件</h3><p>每個執行中的軟體或是瀏覽器頁面就像是一個星球，每個星球就像是一個全域物件，囊括了星球上的所有東西，在網頁環境中的全域物件是 <code>window</code>，而 Node.js 中是 <code>global</code>。</p>
<p>雖然都是全域，除了名稱外也有些差異，假如在全域中引入兩個檔案（a.js 和 b.js），裡面都撰寫了 <code>var a = 1</code>，這時網頁的 <code>window.a</code> 會得到 <code>1</code> 的結果，Node.js 的 <code>global.a</code> 則是 <code>undefined</code>。</p>
<p>Node.js 中的每個模組都會是獨立的，不會互相干擾也不會變成全域變數（除非直接操作 global 物件），網頁中的 window 則可能被 var 變數影響（ES6 後建議全部改用 let 才不會污染全域）。</p>
<h3 id="檔案路徑"><a href="#檔案路徑" class="headerlink" title="檔案路徑"></a>檔案路徑</h3><p>一個專案中會有許多資料夾和檔案，要存取這些資源就需要知道檔案的路徑位置，才能順利找到檔案，Node.js 提供 <code>path</code> 模組，可以快速的分解、組合路徑。</p>
<ul>
<li>全域變數：<code>__dirname</code>、<code>__filename</code> 可以取得當前的目錄和檔案名稱。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 目錄名稱</span></span><br><span class="line"><span class="built_in">console</span>.log(__dirname);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 檔案名稱</span></span><br><span class="line"><span class="built_in">console</span>.log(__filename);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Path</code>：Node.js 的 path 模組提供許多方法來處理路徑。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 範例路徑</span></span><br><span class="line"><span class="keyword">const</span> url = <span class="string">&#x27;/aa/bb/cc.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用 path 模組</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取得目錄</span></span><br><span class="line">path.dirname(url); <span class="comment">// /aa/bb</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取得檔名</span></span><br><span class="line">path.basename(url); <span class="comment">// cc.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取得副檔名</span></span><br><span class="line">path.extname(url); <span class="comment">// js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 拆解路徑（回傳物件格式）</span></span><br><span class="line">path.parse(url); <span class="comment">// &#123; root: &#x27;/&#x27;, dir: &#x27;/aa/bb&#x27;, base: &#x27;cc.js&#x27;, ext: &#x27;.js&#x27;, name: &#x27;cc&#x27; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 組合路徑</span></span><br><span class="line">path.join(<span class="string">&#x27;/ii&#x27;</span>, <span class="string">&#x27;jj&#x27;</span>, <span class="string">&#x27;kk.js&#x27;</span>); <span class="comment">// /ii/jj/kk.js</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><a href="https://nodejs.org/api/path.html">Node.js - path</a></p>
</blockquote>
<hr>
<h2 id="💎-結語"><a href="#💎-結語" class="headerlink" title="💎 結語"></a>💎 結語</h2><p>本篇的筆記記錄了如何使用 Node.js 本地建立伺服器、透過 Postman 檢查 Request &amp; Response，接下來會記錄如何製作一個簡單的 todolist api。</p>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>[Node.JS] 打造 todolist api 5 - 加入資料庫（MongoDB）</title>
    <url>/2022/03/06/nodejs6/</url>
    <content><![CDATA[<p><img data-src="/images/nodejs-logo.png"></p>
<span id="more"></span>
<p>todolist api 在前一篇文章雖然已經上線運行，但是待辦事項沒有存放到資料庫，只要閒置久了資料就會消失，這篇文章會介紹 MongoDB 的操作，並應用資料庫讓每筆待辦都能被儲存下來。<br>如果已經熟悉 MongoDB 的操作，可以直接跳到最後一個段落。</p>
<hr>
<h2 id="💎-安裝-MongoDB"><a href="#💎-安裝-MongoDB" class="headerlink" title="💎 安裝 MongoDB"></a>💎 安裝 MongoDB</h2><h3 id="安裝"><a href="#安裝" class="headerlink" title="安裝"></a>安裝</h3><ul>
<li><p>MacOS</p>
<ul>
<li>方法１：下載壓縮檔，解壓縮後的 bin 資料夾內有４個檔案（mongo、mongod…），透過終端機指令（<code>sudo cp 完整路徑/mongodb-directory/bin/* /usr/local/bin/</code>）或是 Finder 把這４個檔案移動到 <code>/usr/local/bin/</code> 路徑裡面。<blockquote>
<p><a href="https://www.mongodb.com/try/download/community">MongoDB官方下載頁</a>、<a href="https://docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x-tarball/">操作文件</a></p>
</blockquote>
</li>
<li>方法２：使用 Homebrew 安裝，指令為 <code>brew install mongodb-community</code>，安裝的內容較多、較佔空間，但是安裝好後可以直接開始使用。<blockquote>
<p><a href="https://github.com/mongodb/homebrew-brew">操作文件 (GitHub)</a></p>
</blockquote>
</li>
</ul>
</li>
<li><p>Windows：下載安裝檔執行安裝即可。</p>
<blockquote>
<p><a href="https://www.mongodb.com/try/download/community">MongoDB官方下載頁</a></p>
</blockquote>
</li>
</ul>
<h3 id="環境測試與操作指令"><a href="#環境測試與操作指令" class="headerlink" title="環境測試與操作指令"></a>環境測試與操作指令</h3><ol>
<li><p>使用終端機執行 mongo 和 mongod 指令，成功執行時會顯示很多訊息（可先略過內容），失敗時則顯示找不到該指令。<br><code>使用 MacOS 解壓縮方式安裝，在首兩次執行時會跳出安全性提示，需要開啟相關設定才能執行指令（跳出的提示會有選項可以導向設定頁面）</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mongo</span><br><span class="line">mongod</span><br></pre></td></tr></table></figure></li>
<li><p>建立本地資料庫所需的資料夾和檔案，結構如下：</p>
</li>
</ol>
<ul>
<li>MongoDB (目錄)<ul>
<li>data (目錄)</li>
<li>logs (目錄)<ul>
<li>mongo.log (檔案)</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="3">
<li><p>開啟終端機，輸入指令啟用資料庫，成功啟用後會發現指定為資料庫路徑的目錄裡面多了好幾個檔案。<br>（可以先 cd 到 MongoDB 目錄，指令內的路徑就能少打一些）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mongod --dbpath 完整路徑/MongoDB/data --logpath 完整路徑/MongoDB/logs/mongo.log</span><br></pre></td></tr></table></figure>
<p>指令說明：</p>
<ul>
<li>mongod：啟動資料庫</li>
<li>–dbpath：參數，設定資料庫的路徑</li>
<li>–logpath：參數，設定 log檔 的路徑</li>
<li>Ctrl+C：關閉資料庫</li>
</ul>
</li>
<li><p>開啟另一個終端機，輸入 mongo 指令連線資料庫，成功連線時會出現許多訊息，其中可以看到資料庫使用本機的 27017 port（127.0.0.1:27017），進入資料庫後可以執行一些指令來測試。<br><code>MongoDB 的結構是 db(資料庫) -&gt; Collection(集合) -&gt; document(文件/資料)，透過以下指令就會依這個順序看到每個層級的資訊</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mongo <span class="comment"># 連線資料庫</span></span><br><span class="line">show dbs  <span class="comment"># 顯示所有資料庫</span></span><br><span class="line">use <span class="built_in">local</span> <span class="comment"># 切換到 local 資料庫</span></span><br><span class="line">show collections <span class="comment"># 顯示所有集合</span></span><br><span class="line">db.startup_log.find() <span class="comment"># 顯示 startup_log 裡面的所有資料</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="💎-註冊-MongoDB-雲端服務"><a href="#💎-註冊-MongoDB-雲端服務" class="headerlink" title="💎 註冊 MongoDB 雲端服務"></a>💎 註冊 MongoDB 雲端服務</h2><ul>
<li>前往 <a href="https://www.mongodb.com/">MongoDB 首頁</a> 右上方區塊點擊註冊或登入，註冊帳號的過程也很簡單，選項大致選完就完成了。</li>
<li>登入後會跳轉到 Create Cluster 頁面，只是練習的話就選擇免費的就好，雲端主機的種類也使用預設的，過程請<code>注意頁面底下顯示的收費金額</code>。</li>
<li>接著會跳轉到『建立使用者名稱和密碼』、『網路存取』的設定，使用者名稱和密碼是連接資料庫時需要使用，網路存取因為是本地練習，可以選擇取得我的 ip 後加入。<br><code>如果自己連網的 ip 會浮動就需要再次來這邊更改</code><br><code>API 經常會設計開放給眾人戳，但是資料庫通常都是白名單開放，全開非常危險</code></li>
<li>完成後就可以從左側選單的 Database 查看建立好的資料庫。<br><img data-src="/images/mongo1.png"></li>
</ul>
<hr>
<h2 id="💎-安裝-Compass"><a href="#💎-安裝-Compass" class="headerlink" title="💎 安裝 Compass"></a>💎 安裝 Compass</h2><ul>
<li>Compass 是 MongoDB 的 GUI 工具，使用 Windows 系統不需額外安裝（已經包含在 MongoDB 安裝裡），MacOS 需要到 <a href="https://www.mongodb.com/try/download/compass">MongoDB 官方網站</a> 下載，安裝方式很簡單，不需要另行設定。</li>
<li>連接本地資料庫：<br>Compass 主要操作介面有輸入資料庫連結的地方（如圖），只要空著直接點連線就會連接本地資料庫（請先確認有用 mongod 指令開啟本地資料庫）<br><img data-src="/images/compass.png"></li>
<li>連接遠端資料庫：<ol>
<li>回到上個步驟完成的 Mongo 雲端資料庫網頁</li>
<li>點選『Connect』<img data-src="/images/mongo2.png"></li>
<li>建立 IP，如果已經建立了就不會出現這個步驟)</li>
<li>點選『Connect using MongoDB Compass』</li>
<li>點選『I have MongoDB Compass』</li>
<li>出現一串連結複製下來，長得像這樣：<br><code>mongodb+srv://xxxxx:&lt;password&gt;@cluster0.uklck.mongodb.net/xxxxx</code></li>
<li>回到 Compass 介面輸入資料庫連結的地方貼上，把<code>&lt;password&gt;</code>的部份修改成先前建立的使用者密碼。</li>
<li>連線成功就完成了！</li>
</ol>
</li>
</ul>
<hr>
<h2 id="💎-資料庫操作指令"><a href="#💎-資料庫操作指令" class="headerlink" title="💎 資料庫操作指令"></a>💎 資料庫操作指令</h2><p>MongoDB Shell 可以用來直接操作資料庫，在學習 Node.js、PHP、C#… 等後端語言操作方式之前，可以先熟悉 MongoDB Shell，因為除了不同的後端語言會有自己的起手勢、撰寫格式外，資料庫操作的方法名稱都是大同小異的，接下來就介紹 MongoDB 的 CRUD 使用哪些指令（只有記錄部分指令，完整可以參考 <a href="https://docs.mongodb.com/manual/">官方文件</a>）。<br><code>以下都是在本地資料庫做練習</code></p>
<h3 id="C-Create-："><a href="#C-Create-：" class="headerlink" title="C (Create)："></a>C (Create)：</h3><ul>
<li><p><code>use &lt;dbName&gt;</code>：切換到指定資料庫。<br>初始環境中只有 admin、config、local 3個資料庫，可以透過 use 指令來切換到不同資料庫，CRUD 操作前也需要先用這個指令來切換到指定資料庫中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">use 資料庫名稱</span><br></pre></td></tr></table></figure></li>
<li><p><code>db.&lt;collectionName&gt;.insertOne()</code>：在指定集合內新增一筆資料。<br><code>&lt;collectionName&gt;</code> 要換成集合的名稱，<code>()括弧</code>裡面帶入要新增的資料。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.集合名稱.insertOne(&#123;<span class="string">&quot;greeting&quot;</span>: <span class="string">&quot;Hello&quot;</span>&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>新增資料庫：<br>使用資料庫時不會在初始的資料庫裡操作，而是針對專案新增專用的資料庫，MongoDB 沒有新增資料庫的專用指令，需要兩個指令來完成：</p>
<ol>
<li><code>use 新資料庫名稱</code>：送出這個指令後就會切換到新的資料庫名稱中，此時只是暫時的狀態，尚未真正建立資料庫。</li>
<li><code>db.&lt;collectionName&gt;.insertOne(...)</code>：利用新增資料的指令，設定了集合的名稱，並加入新的資料，資料庫也會同時建立起來。</li>
</ol>
<p>以 todolist 為例，環境設計和對應指令如下：</p>
<ul>
<li>資料庫名稱：todolist</li>
<li>集合名稱：todos</li>
<li>新增一筆資料：{“title”: “eat”}<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">use todolist</span><br><span class="line">db.todos.insertOne(&#123;<span class="string">&quot;title&quot;</span>: <span class="string">&quot;eat&quot;</span>&#125;)</span><br><span class="line"><span class="comment"># 執行上面兩個指令後，資料庫、集合、資料都建立好了</span></span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>官方文件：<a href="https://www.mongodb.com/basics/create-database">How to Create a Database in MongoDB</a></p>
</blockquote>
</li>
</ul>
<ul>
<li><code>db./&lt;collectionName&gt;.insertMany()</code>：在指定集合內新增多筆資料。<br>和單筆新增差不多，括弧內改成陣列格式來存放多筆資料。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 新增兩筆</span></span><br><span class="line">db.todos.insertMany([</span><br><span class="line">   &#123;<span class="string">&quot;title&quot;</span>: <span class="string">&quot;sleep&quot;</span>&#125;,</span><br><span class="line">   &#123;<span class="string">&quot;title&quot;</span>: <span class="string">&quot;walk&quot;</span>&#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<blockquote>
<p>官方文件：<a href="https://docs.mongodb.com/manual/tutorial/insert-documents/">Insert</a></p>
</blockquote>
</li>
</ul>
<h3 id="R-Read"><a href="#R-Read" class="headerlink" title="R (Read)"></a>R (Read)</h3><ul>
<li><code>db.&lt;collectionName&gt;.find()</code>：取得指定集合內符合條件的所有資料。</li>
</ul>
<ol>
<li>取得全部資料：不加任何參數，在練習新增、刪除、修改操作時，都可以使用這個指令檢查成果。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 找出 todos 集合內的所有資料</span></span><br><span class="line">db.todos.find()</span><br></pre></td></tr></table></figure></li>
<li>條件查詢：括弧() 內加入篩選條件，取得所有符合的資料。<br>篩選條件有非常多種，以下大致列出一些用法。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 單一條件</span></span><br><span class="line">db.todos.find(&#123;</span><br><span class="line">  <span class="string">&quot;title&quot;</span>: <span class="string">&quot;sleep&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多種條件</span></span><br><span class="line">db.todos.find(&#123;</span><br><span class="line">  <span class="string">&quot;title&quot;</span>: <span class="string">&quot;sleep&quot;</span>,</span><br><span class="line">  <span class="string">&quot;content&quot;</span>: <span class="string">&quot;...&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 數值區間</span></span><br><span class="line">db.todos.find(&#123;</span><br><span class="line">  <span class="string">&quot;price&quot;</span>: &#123;<span class="variable">$gt</span>:500&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 關鍵字</span></span><br><span class="line">db.todos.find(&#123;</span><br><span class="line">  <span class="string">&quot;title&quot;</span>: /a/</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保護欄位：第二個參數指定的屬性不會被取出</span></span><br><span class="line">db.todos.find(</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;title&quot;</span>: /a/</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;_id&quot;</span>: 0</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜尋陣列裡面的值</span></span><br><span class="line">db.todos.find(</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;tools&quot;</span>: &#123;<span class="variable">$in</span>:[<span class="string">&quot;vscode&quot;</span>]&#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="查詢參數"><a href="#查詢參數" class="headerlink" title="查詢參數"></a>查詢參數</h4><table>
<thead>
<tr>
<th align="center">參數</th>
<th align="center">功用</th>
<th align="center">參數</th>
<th align="center">功用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$eq</td>
<td align="center">等於</td>
<td align="center">$ne</td>
<td align="center">不等於</td>
</tr>
<tr>
<td align="center">$gt</td>
<td align="center">大於</td>
<td align="center">$lt</td>
<td align="center">小於</td>
</tr>
<tr>
<td align="center">$gte</td>
<td align="center">大於等於</td>
<td align="center">$lte</td>
<td align="center">小於等於</td>
</tr>
<tr>
<td align="center">$in</td>
<td align="center">存在某個值</td>
<td align="center">$nin</td>
<td align="center">不存在某個值</td>
</tr>
</tbody></table>
<ul>
<li><p><code>db.&lt;collectionName&gt;.findOne()</code>：取得指定集合內符合條件的一筆資料。<br>篩選條件通常用 id（建立時會自動產生），不會有重複的問題。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.todos.findOne(&#123;<span class="string">&quot;_id&quot;</span>: PbjectId(<span class="string">&quot;xxxxxxxx實際的IDxxxxxxxx&quot;</span>)&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>官方文件：<a href="https://docs.mongodb.com/manual/reference/method/db.collection.find/">Find</a>、<a href="https://docs.mongodb.com/manual/reference/method/db.collection.findOne/">FindeOne</a></p>
</blockquote>
</li>
</ul>
<h3 id="U-Update"><a href="#U-Update" class="headerlink" title="U (Update)"></a>U (Update)</h3><ul>
<li><p><code>db.&lt;collectionName&gt;.updateOne()</code>：修改指定集合內的一筆資料。<br>需要知道要改哪筆資料，所以放入兩個參數，<code>篩選條件</code> 和 <code>新的資料內容</code>。</p>
<ul>
<li>篩選條件通常用 id（建立時會自動產生），不會有重複的問題。</li>
<li>新的資料<code>需要</code>放到 $set 屬性裡面。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.todos.updateOne(</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;_id&quot;</span>: PbjectId(<span class="string">&quot;xxxxxxxx實際的IDxxxxxxxx&quot;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;<span class="variable">$set</span>&quot;</span>: &#123;</span><br><span class="line">      &#123;<span class="string">&quot;title&quot;</span>: <span class="string">&quot;run&quot;</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>db.&lt;collectionName&gt;.updateMany()</code>：修改指定集合內的多筆資料。</p>
<ul>
<li>多筆資料不會使用 id（只能找到一筆），改用其他條件來篩選。</li>
<li>新的資料<code>需要</code>放到 $set 屬性裡面，所有符合的結果都會被修改。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.todos.updateMany(</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;title&quot;</span>: <span class="string">&quot;walk&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;<span class="variable">$set</span>&quot;</span>: &#123;</span><br><span class="line">      &#123;<span class="string">&quot;title&quot;</span>: <span class="string">&quot;run&quot;</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>官方文件：<a href="https://docs.mongodb.com/manual/tutorial/update-documents/">Update</a></p>
</blockquote>
</li>
</ul>
</li>
<li><p><code>db.&lt;collectionName&gt;.replaceOne()</code>：取代指定集合內的一筆資料。</p>
<ul>
<li>replace 和 update 的差異在於，update 只會更新對應屬性，replace 則是覆蓋全部。</li>
<li>新的資料<code>不需要</code>放到 $set 屬性裡面。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 假設原始資料長這樣</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;title&quot;</span>: <span class="string">&quot;run&quot;</span>,</span><br><span class="line">  <span class="string">&quot;distance&quot;</span>: <span class="string">&quot;2000m&quot;</span>,</span><br><span class="line">  <span class="string">&quot;time&quot;</span>: <span class="string">&quot;1700&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
使用 updateOne()<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.todos.updateOne(</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;title&quot;</span>: <span class="string">&quot;run&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;<span class="variable">$set</span>&quot;</span>: &#123;</span><br><span class="line">      &#123;<span class="string">&quot;title&quot;</span>: <span class="string">&quot;walk&quot;</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 執行結果：</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;title&quot;</span>: <span class="string">&quot;walk&quot;</span>,</span><br><span class="line">  <span class="string">&quot;distance&quot;</span>: <span class="string">&quot;2000m&quot;</span>,</span><br><span class="line">  <span class="string">&quot;time&quot;</span>: <span class="string">&quot;1700&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
使用 replaceOne()<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.todos.replaceOne(</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;title&quot;</span>: <span class="string">&quot;run&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;title&quot;</span>: <span class="string">&quot;walk&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 執行結果：</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;title&quot;</span>: <span class="string">&quot;walk&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>官方文件：<a href="https://docs.mongodb.com/manual/reference/method/db.collection.replaceOne/">ReplaceOne</a></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="D-Delete"><a href="#D-Delete" class="headerlink" title="D (Delete)"></a>D (Delete)</h3><ul>
<li><p><code>db.&lt;collectionName&gt;.deleteOne()</code>：刪除指定集合內的一筆資料。<br>只需要傳入篩選條件就可以，刪除的對象會是整筆資料，不是單一屬性。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.todos.deleteOne(</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;title&quot;</span>: <span class="string">&quot;walk&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li><p><code>db.&lt;collectionName&gt;.deleteMany()</code>：刪除指定集合內的多筆資料。<br>符合條件的都會被刪除。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.todos.deleteMany(</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;title&quot;</span>: <span class="string">&quot;walk&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li><p><code>db.dropDatabase()</code>：刪除指定資料庫。<br>需要兩個步驟，use 資料庫，再執行刪除指令，高風險操作請謹慎使用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">use DBname</span><br><span class="line">db.dropDatabase()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>官方文件：<a href="https://docs.mongodb.com/manual/tutorial/remove-documents/">Delete</a>、<a href="https://docs.mongodb.com/manual/reference/method/db.dropDatabase/">db.dropDatabase()</a></p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="💎-Todolist-API-結合-MongoDB"><a href="#💎-Todolist-API-結合-MongoDB" class="headerlink" title="💎 Todolist API 結合 MongoDB"></a>💎 Todolist API 結合 MongoDB</h2><p>學會 MongoDB 後就可以迎來 todolist 的第二次進化！以下就是改造的步驟。</p>
<h3 id="安裝-mongodb-driver-套件"><a href="#安裝-mongodb-driver-套件" class="headerlink" title="安裝 mongodb driver 套件"></a>安裝 mongodb driver 套件</h3><p>有了 driver 就可讓 node.js 和 MongoDB 交流了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i mongodb</span><br><span class="line"><span class="comment"># 也可以全域安裝</span></span><br><span class="line">npm i -g mongodb</span><br></pre></td></tr></table></figure>

<h3 id="認識基本程式碼"><a href="#認識基本程式碼" class="headerlink" title="認識基本程式碼"></a>認識基本程式碼</h3><p>以下參考官方文件 <a href="https://docs.mongodb.com/drivers/node/current/quick-start/">Quick Start</a> ，可以先試著放到專案測試，沒問題後再來改寫。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; MongoClient &#125; = <span class="built_in">require</span>(<span class="string">&quot;mongodb&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 這串改成自己的 mongodb 雲端服務連結</span></span><br><span class="line"><span class="keyword">const</span> uri =</span><br><span class="line">  <span class="string">&quot;mongodb+srv://&lt;user&gt;:&lt;password&gt;@&lt;cluster-url&gt;?retryWrites=true&amp;writeConcern=majority&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> client = <span class="keyword">new</span> MongoClient(uri);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> client.connect();</span><br><span class="line">    <span class="comment">// 改成自己的資料庫名稱</span></span><br><span class="line">    <span class="keyword">const</span> database = client.db(<span class="string">&#x27;sample_mflix&#x27;</span>);</span><br><span class="line">    <span class="comment">// 改成自己的集合名稱，變數名稱也順便調整</span></span><br><span class="line">    <span class="keyword">const</span> movies = database.collection(<span class="string">&#x27;movies&#x27;</span>);</span><br><span class="line">    <span class="comment">// 這是查詢字串</span></span><br><span class="line">    <span class="keyword">const</span> query = &#123; <span class="attr">title</span>: <span class="string">&#x27;Hello&#x27;</span> &#125;;</span><br><span class="line">    <span class="comment">// movie 和 movies 變數名稱請自行修改</span></span><br><span class="line">    <span class="comment">// query 可以拿掉，變成查詢所有資料</span></span><br><span class="line">    <span class="keyword">const</span> movie = <span class="keyword">await</span> movies.findOne(query);</span><br><span class="line">    <span class="comment">// 變數名稱自行修改，成功顯示資料就沒問題了</span></span><br><span class="line">    <span class="built_in">console</span>.log(movie);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 每次連線完成都要記得關閉，佔用滿了資料庫就掛了</span></span><br><span class="line">    <span class="keyword">await</span> client.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">run().catch(<span class="built_in">console</span>.dir);</span><br></pre></td></tr></table></figure>

<h3 id="改寫程式碼"><a href="#改寫程式碼" class="headerlink" title="改寫程式碼"></a>改寫程式碼</h3><p>可以依照官方的程式碼自由改寫，以下寫法僅供參考：</p>
<ol>
<li><p>串連資料庫的目的是取代原本使用陣列存放 todolist，第一步就可以把原本寫的 <code>let todos = []</code> 拿掉。</p>
</li>
<li><p>把官方範例中的常數宣告放到 todolist 程式最上方，或是模組化寫到另一個檔案來引入。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; MongoClient &#125; = <span class="built_in">require</span>(<span class="string">&quot;mongodb&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> uri = <span class="string">&quot;mongodb+srv://自己的 mongodb 雲端服務連結&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> client = <span class="keyword">new</span> MongoClient(uri);</span><br></pre></td></tr></table></figure></li>
<li><p>剩下的部份可以把「連接資料庫 -&gt; 關閉資料庫」抽出來寫成函式，此處我設計成可以傳入參數，讓 switch…case 判斷要執行哪個對應的 CRUD。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">connectDB</span>(<span class="params">res, method, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> client.connect();</span><br><span class="line">    <span class="keyword">const</span> database = client.db(<span class="string">&#x27;todolist&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> todos = database.collection(<span class="string">&#x27;todos&#x27;</span>);</span><br><span class="line">    <span class="comment">// 判斷傳入的參數</span></span><br><span class="line">    <span class="keyword">switch</span>(action) &#123;</span><br><span class="line">      <span class="attr">case</span> :</span><br><span class="line">        <span class="comment">//...先空著...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> client.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>函式的架構完成後，原本 todolist 的 5 隻 api 對應的陣列操作程式碼可以修改成呼叫連接資料庫的函式，傳入參數來執行對應行為，改寫的內容依序如下：</p>
<h4 id="修改回傳函式："><a href="#修改回傳函式：" class="headerlink" title="修改回傳函式："></a>修改回傳函式：</h4><p>前面的文章原本只設計用一個函式來處理 response，為了方便，我拆成 sendRes 和 sendErr 兩個方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> headers = &#123;</span><br><span class="line">    <span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>: <span class="string">&#x27;Content-Type, Authorization, Content-Length, X-Requested-With&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>: <span class="string">&#x27;*&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span>: <span class="string">&#x27;PATCH, POST, GET, OPTIONS, DELETE&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> statusMsg = &#123;</span><br><span class="line">    <span class="string">&#x27;400&#x27;</span>: <span class="string">&#x27;Bad Request&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;401&#x27;</span>: <span class="string">&#x27;Unauthorized&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;403&#x27;</span>: <span class="string">&#x27;Forbidden&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;404&#x27;</span>: <span class="string">&#x27;Not Found&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;405&#x27;</span>: <span class="string">&#x27;Method Not Allowed&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> sendRes = <span class="function">(<span class="params">res, data</span>) =&gt;</span> &#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, headers);</span><br><span class="line">    <span class="keyword">if</span> (data) &#123;</span><br><span class="line">        res.write(<span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">            <span class="string">&#x27;status&#x27;</span>: <span class="string">&#x27;true&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;data&#x27;</span>: data</span><br><span class="line">        &#125;))</span><br><span class="line">    &#125;</span><br><span class="line">    res.end();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> sendErr = <span class="function">(<span class="params">res, statusCode</span>) =&gt;</span> &#123;</span><br><span class="line">    res.writeHead(statusCode, headers);</span><br><span class="line">    res.write(<span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">        <span class="string">&#x27;status&#x27;</span>: <span class="string">&#x27;false&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;msg&#x27;</span>: statusMsg[statusCode]</span><br><span class="line">    &#125;))</span><br><span class="line">    res.end();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    sendRes,</span><br><span class="line">    sendErr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="功能：取得全部"><a href="#功能：取得全部" class="headerlink" title="功能：取得全部"></a>功能：取得全部</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原本的內容</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;GET&#x27;</span>:</span><br><span class="line">    sendResponse(res, <span class="number">200</span>, &#123;</span><br><span class="line">        <span class="string">&quot;status&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">        <span class="comment">// 改成回傳待辦事項的變數</span></span><br><span class="line">        <span class="string">&quot;data&quot;</span>: todos</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改寫成呼叫資料庫連結函式</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;GET&#x27;</span>:</span><br><span class="line">    run(res, <span class="string">&#x27;getAll&#x27;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函式功能修改</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">res, method, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 新增一個變數來存放資料庫回傳的訊息</span></span><br><span class="line">        <span class="keyword">let</span> result;</span><br><span class="line">        <span class="keyword">switch</span>(method) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;getAll&#x27;</span>:</span><br><span class="line">                <span class="comment">// find()查詢結果需要用 toArray() 方法轉換格式才能讀取</span></span><br><span class="line">                result = <span class="keyword">await</span> todos.find().toArray();</span><br><span class="line">                <span class="keyword">await</span> sendRes(res, result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="功能：新增一筆"><a href="#功能：新增一筆" class="headerlink" title="功能：新增一筆"></a>功能：新增一筆</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原本的內容</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改寫成呼叫資料庫連結函式</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">    req.on(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> title = <span class="built_in">JSON</span>.parse(body)?.title;</span><br><span class="line">        title ? run(res, <span class="string">&#x27;insertOne&#x27;</span>, &#123;title&#125;) : sendErr(res, <span class="number">400</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函式功能修改</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">res, method, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">let</span> result;</span><br><span class="line">        <span class="keyword">switch</span>(method) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;insertOne&#x27;</span>:</span><br><span class="line">                result = <span class="keyword">await</span> todos.insertOne(data);</span><br><span class="line">                <span class="keyword">await</span> sendRes(res, result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="功能：刪除一筆"><a href="#功能：刪除一筆" class="headerlink" title="功能：刪除一筆"></a>功能：刪除一筆</h4><p>原本的 ID 檢查是透過陣列方法，連結資料庫後如果要這樣做會變成先送出查詢指令，確認有資料再送出一次刪除指令，所以這邊我改成檢查 ID 格式是否正確，確認正確後直接送出，讓資料庫回應刪除是否成功。<br>檢查 MongoDB 的 ID 可以安裝 <a href="https://mongoosejs.com/docs/index.html">mongoose</a> 這個套件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i mongoose</span><br></pre></td></tr></table></figure>
<p>除此之外，檢查通過後還需要生成帶有 ObjectId 的物件，可以從 mongodb 引用，套件都沒問題後在程式碼的最上方引入這些功能。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多引用了 ObjectId</span></span><br><span class="line"><span class="keyword">const</span> &#123; MongoClient, ObjectId &#125; = <span class="built_in">require</span>(<span class="string">&#x27;mongodb&#x27;</span>);</span><br><span class="line"><span class="comment">// 引用 mongoose 來驗證ID</span></span><br><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">&#x27;mongoose&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>程式碼修改</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原本的內容</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.url.startsWith(<span class="string">&#x27;/todo/&#x27;</span>)) &#123;</span><br><span class="line">      <span class="keyword">let</span> id = req.url.split(<span class="string">&#x27;/&#x27;</span>).pop();</span><br><span class="line">      <span class="keyword">let</span> index = todos.findIndex(<span class="function"><span class="params">el</span> =&gt;</span> el.id == id);</span><br><span class="line">      <span class="keyword">if</span> (index &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (req.method == <span class="string">&#x27;PATCH&#x27;</span>) &#123;</span><br><span class="line">              ...</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.method == <span class="string">&#x27;DELETE&#x27;</span>) &#123;</span><br><span class="line">              todos.splice(index, <span class="number">1</span>);</span><br><span class="line">              sendResponse(res, <span class="number">200</span>, &#123;</span><br><span class="line">                  <span class="string">&quot;status&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">                  <span class="string">&quot;data&quot;</span>: todos</span><br><span class="line">              &#125;);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          ...</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改寫成呼叫資料庫連結函式</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.url.startsWith(<span class="string">&#x27;/todo/&#x27;</span>)) &#123;</span><br><span class="line">    <span class="keyword">let</span> id = req.url.split(<span class="string">&#x27;/&#x27;</span>).pop();</span><br><span class="line">    <span class="comment">// 檢查 ID 格式是否正確</span></span><br><span class="line">    <span class="keyword">let</span> idIsValid = mongoose.Types.ObjectId.isValid(id);</span><br><span class="line">    <span class="keyword">if</span> (idIsValid) &#123;</span><br><span class="line">        <span class="keyword">if</span> (req.method == <span class="string">&#x27;PATCH&#x27;</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.method == <span class="string">&#x27;DELETE&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 傳入第三個參數：ID 物件</span></span><br><span class="line">            run(res, <span class="string">&#x27;deleteOne&#x27;</span>, &#123;<span class="string">&quot;_id&quot;</span>: ObjectId(id)&#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sendErr(res, <span class="number">405</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sendErr(res, <span class="number">405</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函式功能修改</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">res, method, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">switch</span>(method) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;deleteOne&#x27;</span>:</span><br><span class="line">                result = <span class="keyword">await</span> todos.deleteOne(data);</span><br><span class="line">                <span class="keyword">await</span> sendRes(res, result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="功能：刪除全部"><a href="#功能：刪除全部" class="headerlink" title="功能：刪除全部"></a>功能：刪除全部</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原本的內容</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;DELETE&#x27;</span>:</span><br><span class="line">    todos.length = <span class="number">0</span>;</span><br><span class="line">    sendResponse(res, <span class="number">200</span>, &#123;</span><br><span class="line">        <span class="string">&quot;status&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">        <span class="string">&quot;data&quot;</span>: todos</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改寫成呼叫資料庫連結函式</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;GET&#x27;</span>:</span><br><span class="line">    run(res, <span class="string">&#x27;deleteAll&#x27;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函式功能修改</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">res, method, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 新增一個變數來存放資料庫回傳的訊息</span></span><br><span class="line">        <span class="keyword">let</span> result;</span><br><span class="line">        <span class="keyword">switch</span>(method) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;deleteAll&#x27;</span>:</span><br><span class="line">                result = <span class="keyword">await</span> todos.deleteMany();</span><br><span class="line">                <span class="keyword">await</span> sendRes(res, result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="功能：更新一筆"><a href="#功能：更新一筆" class="headerlink" title="功能：更新一筆"></a>功能：更新一筆</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原本的內容</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (req.method == <span class="string">&#x27;PATCH&#x27;</span>) &#123;</span><br><span class="line">    req.on(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> title = <span class="built_in">JSON</span>.parse(body)?.title;</span><br><span class="line">            <span class="keyword">if</span> (title) &#123;</span><br><span class="line">                <span class="comment">// 修改對應 ID 的 title</span></span><br><span class="line">                todos[index].title = title;</span><br><span class="line">                sendResponse(res, <span class="number">200</span>, &#123;</span><br><span class="line">                    <span class="string">&quot;status&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;data&quot;</span>: todos</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sendResponse(res, <span class="number">400</span>, &#123;</span><br><span class="line">                    <span class="string">&quot;status&quot;</span>: <span class="string">&quot;false&quot;</span></span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            sendResponse(res, <span class="number">405</span>, &#123;</span><br><span class="line">                <span class="string">&quot;status&quot;</span>: <span class="string">&quot;false&quot;</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改寫成呼叫資料庫連結函式</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.url.startsWith(<span class="string">&#x27;/todo/&#x27;</span>)) &#123;</span><br><span class="line">    <span class="keyword">let</span> id = req.url.split(<span class="string">&#x27;/&#x27;</span>).pop();</span><br><span class="line">    <span class="comment">// 檢查 ID 格式是否正確</span></span><br><span class="line">    <span class="keyword">let</span> idIsValid = mongoose.Types.ObjectId.isValid(id);</span><br><span class="line">    <span class="keyword">if</span> (idIsValid) &#123;</span><br><span class="line">        <span class="keyword">if</span> (req.method == <span class="string">&#x27;PATCH&#x27;</span>) &#123;</span><br><span class="line">          req.on(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="keyword">let</span> title = <span class="built_in">JSON</span>.parse(body)?.title;</span><br><span class="line">                  title ? run(res, <span class="string">&#x27;updateOne&#x27;</span>, [&#123;<span class="string">&quot;_id&quot;</span>: ObjectId(id)&#125;, &#123;title&#125;]) : sendErr(res, <span class="number">400</span>);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                  sendErr(res, <span class="number">405</span>);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函式功能修改</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">res, method, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">switch</span>(method) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;updateOne&#x27;</span>:</span><br><span class="line">                <span class="comment">// 因為我只提供傳入一個 data 參數，這邊用陣列來放 id 跟 新資料，也可以用物件處理</span></span><br><span class="line">                result = <span class="keyword">await</span> todos.updateOne(data[<span class="number">0</span>], &#123;<span class="attr">$set</span>: data[<span class="number">1</span>]&#125;);</span><br><span class="line">                <span class="keyword">await</span> sendRes(res, result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="最終測試"><a href="#最終測試" class="headerlink" title="最終測試"></a>最終測試</h4><p>其實改寫的過程中就會一直使用 POSTMAN 來測試，最後從頭到尾測試一遍也許會發現漏掉的 bug，像我就出現連不上雲端資料庫的問題，才發現是我的連線 IP 變更所以被阻擋掉了。</p>
</li>
</ol>
<hr>
<h2 id="💎-總結"><a href="#💎-總結" class="headerlink" title="💎 總結"></a>💎 總結</h2><p>API 大致的流程：<br>收到req -&gt; 檢查內容決定行為 -&gt; 連結資料庫（關閉連線）-&gt; 發送 Res(回應結束)<br>要做這樣基本功能的 API 要學不少新技能，但是完成後會對整個流程有進一步的認識，這系列文章的完成品 Code 我也放在 <a href="https://github.com/stark920/TodolistApiFullVersion">GitHub</a> 上，希望能對同樣是新手的同學們有所幫助。</p>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>[Node.JS] 打造 todolist api 4 - 部署上線</title>
    <url>/2022/03/04/nodejs5/</url>
    <content><![CDATA[<p><img data-src="/images/nodejs-logo.png"></p>
<span id="more"></span> 
<p>寫了好幾篇，功能終於做完了，這篇來記錄如何把寫好的功能放到雲端上，讓這個 API 不再只是本地戳，真正的上線運行。</p>
<hr>
<h2 id="💎-需要工具"><a href="#💎-需要工具" class="headerlink" title="💎 需要工具"></a>💎 需要工具</h2><ul>
<li>雲端平台：Heroku</li>
<li>部署工具：Git</li>
</ul>
<hr>
<h2 id="💎-Git"><a href="#💎-Git" class="headerlink" title="💎 Git"></a>💎 Git</h2><p>要把做好的專案部署到 Heroku 上，會需要用到 Git 來發佈，加入 git 版控只需要在 todolist 練習的資料夾下一個初始化的指令即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果還沒有 Git，可以到 <a href="https://git-scm.com/">Git 官方網站</a> 下載</p>
</blockquote>
<p>完成初始化後可以建立在專案資料夾建立 .gitignore 檔案（例外清單），並打開編輯，在裡面加入 node_modules，當上傳專案到 heroku 平台上時，平台會自動根據 package.json 裡面的 dependancies 來安裝套件，所以可以把模組的實體檔案加到例外，不用一起部署上線。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node_modules</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="💎-環境設定"><a href="#💎-環境設定" class="headerlink" title="💎 環境設定"></a>💎 環境設定</h2><p>在部署上線前，需要（）做一些調整，才能順利運行：</p>
<ul>
<li>package.json<ul>
<li>“scripts” 內加入啟動伺服器的指令<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;start&quot;: &quot;node server.js&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
<li>新增 “engines” 屬性來指定運行的 node.js 版本<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;engines&quot;: &#123;</span><br><span class="line">    &quot;node&quot;: &quot;16.x&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>確認 server.js 裡面的 PORT 設定有沒有使用 process.env.PORT 來獲取環境變數，沒有的話伺服器會無法連線。</li>
<li>完成環境設定後記得用 Git 提交版本<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &#x27;todolist v1(名稱自訂)&#x27;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="💎-Heroku-申請與安裝"><a href="#💎-Heroku-申請與安裝" class="headerlink" title="💎 Heroku 申請與安裝"></a>💎 Heroku 申請與安裝</h2><ol>
<li>如果還沒有 Heroku 帳號，可以先到 <a href="https://www.heroku.com/">Heroku 官方網站</a> 註冊。</li>
<li>註冊完成後回到開發環境（VS Code）。</li>
<li>安裝 Heroku CLI（建議使用全域安裝）。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i -g heroku</span><br></pre></td></tr></table></figure>
<code>安裝完會出現不少衝突警告，但可以先無視</code></li>
<li>測試一下 Heroku CLI 能不能正常使用（下面是檢查版本資訊的指令）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">heroku --version</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="💎-Heroku-上線！"><a href="#💎-Heroku-上線！" class="headerlink" title="💎 Heroku 上線！"></a>💎 Heroku 上線！</h2><ol>
<li><p>先回到 VScode，並且進入 todolist 專案資料夾，在終端機執行登入 heroku 的指令，送出後按任意按鍵會跳轉到登入的網頁，接著再網頁登入成功後，終端機也會跳出登入成功訊息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">heroku login</span><br></pre></td></tr></table></figure></li>
<li><p>執行建立伺服器指令，執行後系統會產生一組專案名稱，可以複製名稱最後的幾個數字，在網頁介面的搜尋列找到這個專案。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">heroku create</span><br></pre></td></tr></table></figure>
<blockquote>
<p>建立伺服器成功後，同時也會把這個遠端專案加到本地中，可以用指令 <code>git remote</code> 檢查，會發現多了一組 <code>heroku</code>。</p>
</blockquote>
</li>
<li><p>發佈專案！運用 git push 把心血結晶上傳吧！<br>（指令最後的本地分支名稱視版本有所不同，需要自行調整）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push heroku main/master</span><br></pre></td></tr></table></figure></li>
<li><p>如果上傳部署成功，就可以執行指令來啟用伺服器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">heroku open</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="💎-線上功能測試"><a href="#💎-線上功能測試" class="headerlink" title="💎 線上功能測試"></a>💎 線上功能測試</h2><p>把所有的可能性從頭到尾測一遍。<br><strong>測試網址</strong>：</p>
<ul>
<li><code>http://(heroku給的網域名稱)/todo</code></li>
<li><code>http://(heroku給的網域名稱)/todo/</code></li>
<li><code>http://(heroku給的網域名稱)/todo/(任一筆id)</code></li>
<li><code>http://(heroku給的網域名稱)/(亂打)</code></li>
</ul>
<p><strong>測試方法</strong>：</p>
<ul>
<li>OPTIONS</li>
<li>GET</li>
<li>POST</li>
<li>PATCH</li>
<li>DELETE</li>
<li>其他 POSTMAN 上有的方法都可以試試</li>
</ul>
<p><strong>測試資料</strong>： </p>
<ul>
<li><code>&#123;&quot;title&quot;: &quot;隨意&quot;&#125;</code></li>
<li>各種奇怪資料</li>
</ul>
<hr>
<h2 id="💎-結語"><a href="#💎-結語" class="headerlink" title="💎 結語"></a>💎 結語</h2><p>這系列文章是參考六角學院的課程撰寫的，這些基本的功能照著課程走，花了很大篇幅和時間才寫出來，寫了才發現每個環節都有詳細的說明，儘管實作的內容還只是皮毛，但是能穩紮穩打的進步，真的比到論壇複製貼上慢慢摸索前進還要有成就感。</p>
<blockquote>
<p>我的 <a href="https://github.com/stark920/todolistDemo">GitHub - todolistDemo</a> 也存放了照著這些文章寫出來的成果，如果操作有問題也可以參考上面的檔案。</p>
</blockquote>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>[Node.JS] 一次認識 NVM、Node.js、NPM、NPX</title>
    <url>/2022/02/21/nodejsStart/</url>
    <content><![CDATA[<p><img data-src="/images/nodejs-logo.png"></p>
<span id="more"></span>
<p>對於前端新手來說 Node.js 做為後端工具感覺已經很遙遠了，打電動只知道 NPC，各種 N 什麼的到底是啥玩意兒？這次就來一次認識清楚！</p>
<hr>
<h2 id="💎-Node-js"><a href="#💎-Node-js" class="headerlink" title="💎 Node.js"></a>💎 Node.js</h2><p>JavaScript 過去都只在前端上（瀏覽器）應用，直到 2009 年 Node.js 問世後才逐漸讓 JavaScript 跨足到後端（伺服器），讓後端工程師除了 Apache 或 IIS 外有了新的選擇。</p>
<h3 id="V8"><a href="#V8" class="headerlink" title="V8"></a>V8</h3><p>Node.js 採用了 Google 的 V8 引擎開發，V8 是為了 Chrome 瀏覽器打造的 JavaScript 引擎，使用 C++ 程式語言撰寫，V8 引擎可以將 JavaScipt 的原始碼編譯成機器語言來執行，就能像其他程式語言一樣在瀏覽器以外的環境使用。</p>
<blockquote>
<p>參考資料： <a href="https://https//zh.wikipedia.org/wiki/Node.js">Wiki - Node.js</a></p>
</blockquote>
<h3 id="安裝"><a href="#安裝" class="headerlink" title="安裝"></a>安裝</h3><ol>
<li><p>前往官方網站下載 Node.js 安裝檔（建議選左邊的穩定版本），按『下一步』到完成即可。</p>
<ul>
<li>LTS：穩定支援版本。</li>
<li>Current：最新版本，可能會有一些套件不支援的問題，新版本的網路相關資訊也較少，較舊版本的作法可能不適用。<blockquote>
<p>官網連結： <a href="https://nodejs.org/en/">Node.js</a><br>各版本支援時間列表： <a href="https://nodejs.org/en/about/releases/">Long Term Support (LTS) schedule</a></p>
</blockquote>
</li>
</ul>
</li>
<li><p>完成安裝後可以開啟終端機（Windows -&gt; cmd, Mac -&gt; Terminal），鍵入指令 <code>node --version (node -v)</code> 來檢查版本資訊。</p>
</li>
</ol>
<h3 id="簡單操作"><a href="#簡單操作" class="headerlink" title="簡單操作"></a>簡單操作</h3><p><code>以下指令都是在終端機內執行</code></p>
<ol>
<li>進入 node.js 執行環境<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node</span><br></pre></td></tr></table></figure></li>
<li>進入環境後可以輸入 JavaScript 程式碼，就像瀏覽器的檢查工具一樣<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> a = 1</span><br><span class="line"><span class="comment">#undefined</span></span><br><span class="line">a</span><br><span class="line"><span class="comment">#1</span></span><br><span class="line">a++</span><br><span class="line"><span class="comment">#1</span></span><br><span class="line">a</span><br><span class="line"><span class="comment">#2</span></span><br><span class="line">console.log(<span class="string">&#x27;Hello, world!&#x27;</span>)</span><br><span class="line"><span class="comment">#Hello, world!</span></span><br></pre></td></tr></table></figure></li>
<li>查看可用的指令<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.<span class="built_in">help</span></span><br></pre></td></tr></table></figure></li>
<li>離開 node.js 環境（方法 1）<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.<span class="built_in">exit</span></span><br></pre></td></tr></table></figure></li>
<li>離開 node.js 環境（方法 2）<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 按兩次 Ctrl+C</span></span><br><span class="line">Ctrl+C</span><br><span class="line">Ctrl+C</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="執行-JS-檔案"><a href="#執行-JS-檔案" class="headerlink" title="執行 JS 檔案"></a>執行 JS 檔案</h3><p><code>以下操作 不 在 Node.js 環境內</code><br>方法１：先用指令移動到 JS 檔案存放的目錄位置，再輸入指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node 檔名</span><br></pre></td></tr></table></figure>
<p>方法２：直接輸入完整路徑和檔名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node 完整路徑/檔名</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="💎-NPM"><a href="#💎-NPM" class="headerlink" title="💎 NPM"></a>💎 NPM</h2><p>NPM（Node Package Manager）是 Node.js 內的套件管理工具，開發時為了節省時間都會使用非常多的外部套件，每個套件也會有各自的版本，就會需要有工具來管理這些套件。<br>NPM 是 Node.js 的工具，不需要另外下載安裝，完成 Node.js 的安裝後就可以在終端機輸入指令 <code>npm -v</code> 來檢查版本資訊。</p>
<h3 id="起手勢"><a href="#起手勢" class="headerlink" title="起手勢"></a>起手勢</h3><ol>
<li><p>新增一個專案資料夾</p>
</li>
<li><p>使用 VS Code 開啟專案資料夾</p>
</li>
<li><p>開啟終端機介面（組合熱鍵 <code>ctrl + 反引號</code>）</p>
</li>
<li><p>輸入初始化指令來建立專案檔</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure></li>
<li><p>輸入初始化指令後，會請你依序輸入以下資訊，如果不知道要打什麼就按 Enter 跳過，最後再輸入 yes 就完成了。</p>
<ul>
<li>專案名稱</li>
<li>版本</li>
<li>描述</li>
<li>進入點（Webpack文章會說明）</li>
<li>測試指令</li>
<li>Git 儲存庫位置</li>
<li>關鍵字</li>
<li>作者</li>
<li>開源授權方式</li>
</ul>
</li>
<li><p>初始化指令也可以加入參數，跳過環境設定，直接用預設值建立。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="安裝／移除套件"><a href="#安裝／移除套件" class="headerlink" title="安裝／移除套件"></a>安裝／移除套件</h3><ol>
<li>安裝套件：<code>npm install 套件名稱</code> 或 <code>npm i 套件名稱</code><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以安裝 Bootstrap 為例</span></span><br><span class="line">npm install bootstrap</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以安裝 FontAwesome 為例</span></span><br><span class="line">npm i fontawesome</span><br><span class="line"></span><br><span class="line"><span class="comment"># MacOS 如果出現權限不足錯誤，在指令前方加 sudo，並且提供本機使用者帳號密碼來執行：</span></span><br><span class="line">sudo npm install (套件名稱)</span><br></pre></td></tr></table></figure></li>
<li>移除套件：<code>npm uninstall 套件名稱</code><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm uninstall (套件名稱)</span><br></pre></td></tr></table></figure></li>
<li>檢視所有安裝的套件：<code>npm list</code></li>
</ol>
<h3 id="安裝模式"><a href="#安裝模式" class="headerlink" title="安裝模式"></a>安裝模式</h3><p>隨著專案變得龐大，使用的套件也會變多，這時候就需要針對套件的使用情境來區分『上線』、『開發』和『全域』使用，專案發佈時把不需要上線提供使用者使用的套件留在本地，才能減少資源與效能的浪費。</p>
<ul>
<li>上線使用<br>上線使用顧名思義是需要一起上線使用的（例如：Bootstrap）。<br>在較早的 NPM 教學文章會看到安裝時需要加上 <code>--save</code> 參數，在 v5 版本以後已經改為預設值，可以不用加上參數。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># npm v5 之前</span></span><br><span class="line">npm install --save (套件名稱)</span><br><span class="line"></span><br><span class="line"><span class="comment"># npm v5 以後</span></span><br><span class="line">npm i (套件名稱)</span><br></pre></td></tr></table></figure></li>
<li>開發使用<br>開發用的套件只需要存放在本地，部署到線上會造成空間浪費（例如：Webpack、Gulp）。<br>在 v5 版本以前需要在指令加上參數 <code>--save-dev</code>， v5 版本以後簡化成加上 <code>-D</code> 即可。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># npm v5 之前</span></span><br><span class="line">npm install --save-dev (套件名稱)</span><br><span class="line"></span><br><span class="line"><span class="comment"># npm v5 以後</span></span><br><span class="line">npm i -D (套件名稱)</span><br></pre></td></tr></table></figure>
開發版的套件會記錄在 package.json 中的 “devDependencies” 屬性，和上線版的 “dependencies” 不同，執行完指令後可以檢查是否成功裝對位置。</li>
</ul>
<p><img data-src="https://ithelp.ithome.com.tw/upload/images/20211005/20129729eJZJMY6b3s.png"></p>
<ul>
<li>全域使用<br>有些提供本地使用的工具在不同的專案都可以應用，不使用時也不會影響到其他專案（例如：Yarn、ESLint、TypeScript、各種 cli …），就可以安裝在全域，這樣每個專案不需要額外安裝也可以使用。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i -g (套件名稱)</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="💎-NPM-檔案結構"><a href="#💎-NPM-檔案結構" class="headerlink" title="💎 NPM 檔案結構"></a>💎 NPM 檔案結構</h2><p>完成起手勢後，專案資料夾會多了一些檔案，其中最重要的就是 <code>package.json</code>：</p>
<h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h3><ul>
<li>執行 <code>npm init</code> 指令後產生的檔案，是整個專案的縮影，裡面記錄專案名稱、指令、使用的套件種類和版本…等資訊。</li>
<li>安裝新的套件後，package.json 會在 <code>dependencies</code> 這個項目中記錄套件名稱、版本資訊，通常版本的數字前面會有一個 <code>^</code> 符號，表示會優先使用最新的版本。<br><img data-src="https://ithelp.ithome.com.tw/upload/images/20211005/20129729IobskSFiu9.png"></li>
<li>因為 package.json 記錄了專案所需要的所有套件資訊，在團隊合作或是下載別的專案時，分享者不需要將套件實體檔案上傳，只要提供 package.json ，讓使用者下載後執行指令 <code>npm install</code> 或 <code>npm i</code> 就會安裝需要的套件了。</li>
</ul>
<h3 id="package-lock-json"><a href="#package-lock-json" class="headerlink" title="package-lock.json"></a>package-lock.json</h3><ul>
<li>這是 NPM 5 版本之後才有的檔案，安裝任一套件後就會產生，這個檔案同樣也記錄了套件的版本資訊，但是內容更詳細，這個檔案可以明確的記錄安裝時的版本資訊。</li>
<li>團隊協作時，如果希望團隊的套件版本一致，就可以把這個 package-lock.json 也提供給其他成員，就會安裝指定的版本套件；反之，希望團隊成員都使用最新版本，就不需要提供這個檔案，讓 NPM 依據 package.json 安裝套件。</li>
</ul>
<h3 id="node-modules"><a href="#node-modules" class="headerlink" title="node_modules"></a>node_modules</h3><ul>
<li>node_modules 資聊夾裡面存放著下載回來的套件實體檔案，即使不小心刪除了，也可以透過 <code>npm i</code> 指令下載回來。</li>
<li>可以在這個資料夾內查看套件撰寫的內容，但不宜在此處編輯修改，會有被覆蓋、與其他團隊成員不同步的問題。</li>
</ul>
<hr>
<h2 id="💎-NVM"><a href="#💎-NVM" class="headerlink" title="💎 NVM"></a>💎 NVM</h2><p>套件隨著版本的更新需要管理工具來管理，同樣的，Node.js 也有各種版本，隨著時光流逝，一些專案也成了古董，不只套件版本是舊的、Node.js 版本也是舊的，想要切換到不同版本的 Node.js 的話就需要使用 NVM，使用起來非常簡單，下面就簡短介紹。</p>
<h3 id="安裝-1"><a href="#安裝-1" class="headerlink" title="安裝"></a>安裝</h3><p>NVM 的安裝有很棒的文章可以參考，可以參考下面的連結：</p>
<blockquote>
<p>中文：<a href="https://www.casper.tw/development/2022/01/10/install-nvm/">卡斯伯’s Blog - 安裝 nvm 環境，Node.js 開發者必學（Windows、Mac 均適用）</a><br>英文：<a href="https://github.com/nvm-sh/nvm#installing-and-updating">官方文件</a></p>
</blockquote>
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安裝特定版本 Node.js，例如 12 版</span></span><br><span class="line">nvm install 12</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切換到特定版本 Node.js，例如 12 版</span></span><br><span class="line">nvm use 12</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顯示有哪些 Node.js 版本可用</span></span><br><span class="line">nvm list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 設定預設版本，例如 16 版</span></span><br><span class="line">nvm <span class="built_in">alias</span> default 16</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="💎-NPX"><a href="#💎-NPX" class="headerlink" title="💎 NPX"></a>💎 NPX</h2><p>前面介紹的 npm 在使用上就只有<code>『要用』</code>（安裝）和<code>『不要用』</code>（移除）兩種選擇，沒有<code>『借我用一下就好』</code>這個選項，npx 補足了這個需求（npm v5.2.0 以後才有），可以在不實際安裝套件的情況下執行 CLI、GitHub gists 或 repo（實際上還有安裝的動作，但是放到一個暫存空間）。<br><code>以下指令轉自官方文件，可以安心使用</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># npx 套件名稱 (參數...)</span></span><br><span class="line">npx cowsay hello</span><br><span class="line"></span><br><span class="line"><span class="comment"># npx GitHub gist url</span></span><br><span class="line">npx https://gist.github.com/zkat/4bc19503fe9e9309e2bfaa2c58074d32</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定 Node.js 版本，用這個方式就不需要用 NVM 在本地裝多個版本</span></span><br><span class="line">npx node@12 -v</span><br></pre></td></tr></table></figure>

<blockquote>
<p>參考資料：<a href="https://nodejs.dev/learn/the-npx-nodejs-package-runner">官方文件</a>、<a href="https://www.freecodecamp.org/news/npm-vs-npx-whats-the-difference/">npm vs npx — What’s the Difference?</a></p>
</blockquote>
<hr>
<h2 id="💎-結語"><a href="#💎-結語" class="headerlink" title="💎 結語"></a>💎 結語</h2><p>試著用一句話形容這些工具<br>Node.js - 建置 JavaScript 的後端環境。<br>NVM - 可以切換不同版本的 Node.js 來使用。<br>NPM - 下載和管理各種套件。<br>NPX - 暫存的方式使用套件，用完就刪。</p>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>NPM</tag>
      </tags>
  </entry>
  <entry>
    <title>[Node.JS] 打造 todolist api 3 - 完成所有功能</title>
    <url>/2022/03/04/nodejs4/</url>
    <content><![CDATA[<p><img data-src="/images/nodejs-logo.png"></p>
<span id="more"></span> 
<p>前一篇已經把整個架構寫好，這次就直接照著架構補完所有功能！</p>
<hr>
<h2 id="💎-GET-取得待辦清單"><a href="#💎-GET-取得待辦清單" class="headerlink" title="💎 GET - 取得待辦清單"></a>💎 GET - 取得待辦清單</h2><p>在前端撰寫 todolist 的練習時，都會使用一個陣列變數來存放待辦資料，現在搭配後端，就由 Node.js 負責管理這個陣列變數。<br>GET 方法非常簡單，只要回傳這個存放待辦事項的變數即可。<br><code>目前的練習中，變數只是存放在伺服器執行環境的記憶體中，並沒有存成實體檔案（資料庫），當伺服器重啟時記憶體釋放，資料就會遺失</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 宣告用來存放待辦事項的陣列</span></span><br><span class="line"><span class="keyword">const</span> todos = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123; </span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;GET&#x27;</span>:</span><br><span class="line">        sendResponse(res, <span class="number">200</span>, &#123;</span><br><span class="line">            <span class="string">&quot;status&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">            <span class="comment">// 改成回傳待辦事項的變數 </span></span><br><span class="line">            <span class="string">&quot;data&quot;</span>: todos</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>段落測試</strong><br><strong>測試網址</strong>：<code>http://127.0.0.1:3000/todo</code><br><strong>測試方法</strong>：GET（只要順利回傳空陣列就成功了）</p>
</blockquote>
<hr>
<h2 id="💎-POST-新增一筆待辦"><a href="#💎-POST-新增一筆待辦" class="headerlink" title="💎 POST - 新增一筆待辦"></a>💎 POST - 新增一筆待辦</h2><p>在撰寫這段時，需要先規劃好一筆待辦事項會有哪些欄位，本次練習只放『標題』、『ID』就好，格式設計如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;title&quot;</span>: <span class="string">&quot;吃飯&quot;</span>,</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;xxxxxxxxxxx&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>標題</strong><ul>
<li>需要接收 <code>req</code> 傳來的資料，使用 node.js 的 req.on 方法來監聽資料接收的事件。</li>
<li>封包大小有限，當傳送的資料大時就會被切成好幾個片段，接收端需要在收到所有的片段之後組合起來，才會取得完整可用的資料。</li>
<li>要確保資料已經確實接收，分別使用 <code>req.on(&#39;data&#39;, function)</code> 來處理資料傳送中的行為，<code>req.on(&#39;end&#39;, function)</code> 處理接收完的行為。</li>
<li>資料檢查：格式設計了使用 title 存放標題，如果傳入的資料不是 JSON 格式，或是沒有這個屬性都可能讓伺服器掛掉，所以需要先檢查是不是符合規範。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="comment">// 建立一個變數來接收傳入的資料</span></span><br><span class="line">    <span class="keyword">let</span> body = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="comment">// 當有資料傳入就加到 body 變數裡面</span></span><br><span class="line">    req.on(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="params">chunk</span> =&gt;</span> &#123;</span><br><span class="line">        body += chunk;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        <span class="comment">// 資料接收完才會執行</span></span><br><span class="line">        req.on(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 取出 body 裡面的 title，如果沒有會得到 undefined</span></span><br><span class="line">            <span class="keyword">let</span> title = <span class="built_in">JSON</span>.parse(body)?.title;</span><br><span class="line">            <span class="comment">// 有 title 就加到陣列裡面，並且回傳全部待辦</span></span><br><span class="line">            <span class="keyword">if</span> (title) &#123;</span><br><span class="line">                todos.push(&#123;</span><br><span class="line">                    title</span><br><span class="line">                &#125;);</span><br><span class="line">                sendResponse(res, <span class="number">200</span>, &#123;</span><br><span class="line">                    <span class="string">&quot;status&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;data&quot;</span>: todos</span><br><span class="line">                &#125;)</span><br><span class="line">            <span class="comment">// 沒 title 回傳錯誤</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sendResponse(res, <span class="number">400</span>, &#123;</span><br><span class="line">                    <span class="string">&quot;status&quot;</span>: <span class="string">&quot;false&quot;</span></span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>ID</strong><ul>
<li>ID 需要是不會重複的數值，使用 UUID 套件來完成。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入 uuid 模組，請確認有無安裝該套件</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">v4</span>: uuidv4 &#125; = <span class="built_in">require</span>(<span class="string">&#x27;uuid&#x27;</span>);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123; </span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        req.on(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> (title) &#123;</span><br><span class="line">                todos.push(&#123;</span><br><span class="line">                    title,</span><br><span class="line">                    <span class="comment">// 加入 ID</span></span><br><span class="line">                    <span class="attr">id</span>: uuidv4()</span><br><span class="line">                &#125;);</span><br><span class="line">            ...</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>防錯</strong><ul>
<li>雖然前面已經針對 title 檢查，還是需要甚防有心人傳入奇怪的資料，可以使用 try…catch 來捕捉問題。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">    req.on(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> title = <span class="built_in">JSON</span>.parse(body)?.title;</span><br><span class="line">            <span class="keyword">if</span> (title) &#123;</span><br><span class="line">                todos.push(&#123;</span><br><span class="line">                    title,</span><br><span class="line">                    <span class="string">&#x27;id&#x27;</span>: uuidv4()</span><br><span class="line">                &#125;)</span><br><span class="line">                sendResponse(res, <span class="number">200</span>, &#123;</span><br><span class="line">                    <span class="string">&quot;status&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;data&quot;</span>: todos</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sendResponse(res, <span class="number">400</span>, &#123;</span><br><span class="line">                    <span class="string">&quot;status&quot;</span>: <span class="string">&quot;false&quot;</span></span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            sendResponse(res, <span class="number">400</span>, &#123;</span><br><span class="line">                <span class="string">&quot;status&quot;</span>: <span class="string">&quot;false&quot;</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>段落測試</strong>（需要使用 POSTMAN）<br><strong>測試網址</strong>：<code>http://127.0.0.1:3000/todo</code><br><strong>測試方法</strong>：POST（需要在 body 加入 JSON 資料）<br><strong>測試資料</strong>： <code>&#123;&quot;title&quot;: &quot;test&quot;&#125;</code> or 各種奇怪資料</p>
</blockquote>
<hr>
<h2 id="💎-DELETE-刪除全部待辦"><a href="#💎-DELETE-刪除全部待辦" class="headerlink" title="💎 DELETE - 刪除全部待辦"></a>💎 DELETE - 刪除全部待辦</h2><p>刪除全部非常簡單，只要把陣列清空就好，要注意的是陣列和物件都盡量避免賦值（=）操作，以方法操作為主，所以我在一開始宣告 todos 時是使用 const ，這樣就無法使用 <code>todos = []</code>，而是使用陣列方法 <code>todos.length = 0</code> 來清空陣列。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;DELETE&#x27;</span>:</span><br><span class="line">    <span class="comment">// 陣列長度為 0 = 沒資料</span></span><br><span class="line">    todos.length = <span class="number">0</span>;</span><br><span class="line">    sendResponse(res, <span class="number">200</span>, &#123;</span><br><span class="line">        <span class="string">&quot;status&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">        <span class="string">&quot;data&quot;</span>: todos</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>段落測試</strong>（需要使用 POSTMAN）<br><strong>測試網址</strong>：<code>http://127.0.0.1:3000/todo</code><br><strong>測試方法</strong>：DELETE</p>
</blockquote>
<hr>
<h2 id="💎-DELETE-刪除一筆待辦"><a href="#💎-DELETE-刪除一筆待辦" class="headerlink" title="💎 DELETE - 刪除一筆待辦"></a>💎 DELETE - 刪除一筆待辦</h2><ul>
<li><strong>取得傳入的 ID</strong>：<br>前一篇文章有提到，把待辦的 ID 塞到網址後面的格式會是 <code>http://網域/路徑/參數</code>，使用 <code>req.url</code> 會得到 <code>/路徑/參數</code>，接著用字串方法 <code>split(&#39;/&#39;)</code> 切割成陣列，再使用 <code>pop()</code> 取得最後一筆資料就是參數了。</li>
<li><strong>找出 ID 相符的資料</strong>：<br>使用 <code>findIndex</code> 方法來找出待辦事項的陣列中有沒有 ID 相符的資料，符合時會取得該筆資料的 <code>index</code>，沒有符合資料時會得到 <code>-1</code>。</li>
<li><strong>刪除陣列資料</strong><br>成功取得指定資料在陣列中的 index 後就可以使用 <code>splice(index, 1)</code> 的方法刪除 1 筆資料，第一個參數是起始的索引位置，第二個參數是要往後刪除幾筆資料。</li>
<li><strong>架構調整</strong><br>調整前：<code>確認網址開頭</code>(/todo/) &gt; <code>確認請求方法</code>（PATCH or DELETE）<br>調整後：<code>確認網址開頭</code>(/todo/) &gt; <code>確認 ID 是否存在</code> &gt; <code>確認請求方法</code>（PATCH or DELETE）<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.url.startsWith(<span class="string">&#x27;/todo/&#x27;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 取得請求網址最後一段帶的 ID</span></span><br><span class="line">        <span class="keyword">let</span> id = req.url.split(<span class="string">&#x27;/&#x27;</span>).pop();</span><br><span class="line">        <span class="comment">// 找出 todos 裡面有沒有符合 id 的項目</span></span><br><span class="line">        <span class="keyword">let</span> index = todos.findIndex(<span class="function"><span class="params">el</span> =&gt;</span> el.id == id);</span><br><span class="line">        <span class="comment">// 先判斷有沒有指定 ID</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (req.method == <span class="string">&#x27;PATCH&#x27;</span>) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.method == <span class="string">&#x27;DELETE&#x27;</span>) &#123;</span><br><span class="line">                todos.splice(index, <span class="number">1</span>);</span><br><span class="line">                sendResponse(res, <span class="number">200</span>, &#123;</span><br><span class="line">                    <span class="string">&quot;status&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;data&quot;</span>: todos</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sendResponse(res, <span class="number">405</span>, &#123;</span><br><span class="line">                    <span class="string">&quot;status&quot;</span>: <span class="string">&quot;false&quot;</span></span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sendResponse(res, <span class="number">405</span>, &#123;</span><br><span class="line">                <span class="string">&quot;status&quot;</span>: <span class="string">&quot;false&quot;</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p><strong>段落測試</strong>（需要使用 POSTMAN）<br><strong>測試網址</strong>：<code>http://127.0.0.1:3000/todo/(任一筆id)</code><br>（先用 POST 方法建立幾筆資料，才有 ID 可用）<br><strong>測試方法</strong>：DELETE</p>
</blockquote>
<hr>
<h2 id="💎-PATCH-編輯一筆待辦"><a href="#💎-PATCH-編輯一筆待辦" class="headerlink" title="💎 PATCH - 編輯一筆待辦"></a>💎 PATCH - 編輯一筆待辦</h2><p>終於到了最後一步，也是集大成的一步，『路徑 ID』和『接收資料』都會用上，可以參考 <code>POST</code> 和 <code>DELETE(單筆)</code> 的寫法自行整合在一起，流程大致如下：</p>
<ol>
<li>檢查連結（url）</li>
<li>檢查ID (url)</li>
<li>檢查方法 (method)</li>
<li>確認接收完資料 (req.on(end))</li>
<li>偵錯 （try…catch）</li>
<li>檢查接收的待辦資料（title）</li>
<li>更新待辦資料（title）</li>
<li>回傳待辦資料<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (req.method == <span class="string">&#x27;PATCH&#x27;</span>) &#123;</span><br><span class="line">        req.on(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> title = <span class="built_in">JSON</span>.parse(body)?.title;</span><br><span class="line">                <span class="keyword">if</span> (title) &#123;</span><br><span class="line">                    <span class="comment">// 修改對應 ID 的 title</span></span><br><span class="line">                    todos[index].title = title;</span><br><span class="line">                    sendResponse(res, <span class="number">200</span>, &#123;</span><br><span class="line">                        <span class="string">&quot;status&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;data&quot;</span>: todos</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    sendResponse(res, <span class="number">400</span>, &#123;</span><br><span class="line">                        <span class="string">&quot;status&quot;</span>: <span class="string">&quot;false&quot;</span></span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                sendResponse(res, <span class="number">405</span>, &#123;</span><br><span class="line">                    <span class="string">&quot;status&quot;</span>: <span class="string">&quot;false&quot;</span></span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; </span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p><strong>段落測試</strong>（需要使用 POSTMAN）<br><strong>測試網址</strong>：<code>http://127.0.0.1:3000/todo/(任一筆id)</code><br>（先用 POST 方法建立幾筆資料，才有 ID 可用）<br><strong>測試方法</strong>：PATCH<br><strong>測試資料</strong>： <code>&#123;&quot;title&quot;: &quot;test&quot;&#125;</code> or 各種奇怪資料</p>
</blockquote>
<hr>
<h2 id="💎-結語"><a href="#💎-結語" class="headerlink" title="💎 結語"></a>💎 結語</h2><p>寫到這邊，總算把所有功能完成，後續還有許多可以調整優化的（回傳詳細的錯誤訊息、模組化…等），就自行發揮吧！</p>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>[持續更新] Mac 軟體安裝清單</title>
    <url>/2022/04/23/usefultools/</url>
    <content><![CDATA[<p>Mac 使用者一定都有自己的小工具口袋清單，常常很多看了有趣的工具裝了實際也沒在用，原則上能少裝就盡量少裝，不要讓一堆少用的工具佔用資源，以下就列出幾個自己比較有在用的工具。</p>
<span id="more"></span>

<hr>
<h2 id="Mac-Apps"><a href="#Mac-Apps" class="headerlink" title="Mac Apps"></a>Mac Apps</h2><ul>
<li>AlDente：電池管理工具。</li>
<li>Alfred 4：取代 spotlight，自動記憶常用的功能（搜尋結果的排名會在前面），還有自訂指令功能。</li>
<li>DropOver：資料夾拖曳工具，免費版需要等幾秒，但是使用頻率不高，偶爾等一下還好。</li>
<li>Hidden Bar：隱藏右上角的多餘圖示，眼不見為淨。</li>
<li>MonitorControl：多螢幕配置時可以很方便的控制螢幕亮度和音量。</li>
<li>Mos：視窗滾動流暢度優化工具，剛換 Mac 用滑鼠滾輪都會懷疑滑鼠是不是壞了，裝了這個體驗好多了。</li>
<li>Pomodorome：簡單的番茄鐘，沒有華麗的裝飾，就是這麼簡單。</li>
<li>Rectangle：多視窗分配工具，免費的功能已夠用。</li>
</ul>
<hr>
<h2 id="VScode-Extensions"><a href="#VScode-Extensions" class="headerlink" title="VScode Extensions"></a>VScode Extensions</h2><ul>
<li><p>介面優化</p>
<ul>
<li>indent-rainbow：讓不同層級的縮排更容易辨識。</li>
<li>Material Icon Theme：檔案類型小圖示有許多選擇，這只是個人偏好。</li>
</ul>
</li>
<li><p>寫 Code 輔助</p>
<ul>
<li>Auto Rename Tag：首尾標籤同步修改，雖然 vscode 有熱鍵可以達成，但是我就不想按～</li>
<li>Code Spell Checker：英文拼字效正，非常推薦安裝，團隊合作時還可以看看到底是誰的拼字在雷。</li>
<li>ESlint：JS 太自由奔放，有所規範能拉高最低水平。</li>
<li>Prettier：雖然排版習慣需要自主養成，有工具幫忙排會省事很多。</li>
</ul>
</li>
<li><p>開發工具</p>
<ul>
<li>Live Server：啟動本地 server 基本款。</li>
<li>Thunder Client：簡單的 api 測試可以使用，不需要另外開 postman 吃效能。</li>
</ul>
</li>
<li><p>語言輔助</p>
<ul>
<li>markdownlint：寫 Hexo 文章時可以用這個工具幫忙排版。</li>
<li>Tailwind CSS IntelliSense：使用 tailwindcss 時必備。</li>
<li>PostCSS Language Support：使用 tailwindcss 時必備。</li>
<li>Vue Language Features (Volar)：使用 Vue3 時必備。</li>
</ul>
</li>
<li><p>Git 視覺化</p>
<ul>
<li>Git Graph：功能單純好上手。</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>Mac</tag>
        <tag>OSX</tag>
        <tag>macOS</tag>
        <tag>App</tag>
      </tags>
  </entry>
  <entry>
    <title>[Node.js] 使用 Passport 套件串接第三方登入完整心法</title>
    <url>/2022/05/30/nodejsThirdPartySignin1/</url>
    <content><![CDATA[ <img data-src="https://i.imgur.com/iz5V41j.png" style="max-height: 200px; align: center" />

<span id="more"></span>

<p>許多人應該跟我一樣，進入一個新的網站發現要註冊會員，卻沒有提供第三方登入，如果不是真的很需要就按上一頁離開了，註冊新帳號真的很煩人（特別是奇怪的密碼複雜度設定），如果能為網站加上第三方登入就有機會留住更多的訪客。</p>
<h2 id="實作方式"><a href="#實作方式" class="headerlink" title="實作方式"></a>實作方式</h2><p>第三方登入可以在前、後端實作，但有登入需求通常表示需要儲存一些用戶資訊，結合後端實作會是比較理想的狀況，前端實作方式只有少數主流平台提供（例如：Google、Facebook），前端實作方式在各平台間沒有太多共通性，就是照著官方文件做就好，本篇文章會介紹後端實作方式及幾個社群平台的申請方式（Google、Facebook、Github、Discord）。</p>
<hr>
<h2 id="第三方登入流程"><a href="#第三方登入流程" class="headerlink" title="第三方登入流程"></a>第三方登入流程</h2><p>這張圖是經過幾次實作後才總結出的流程（前端為 CSR），一開始看也許會看不太懂，但是先大致有個概念，做過一次後再回來看會更加清楚做了什麼事情。<br><img data-src="https://imgur.com/Yv8K7Sa.png" alt="第三方登入流程"></p>
<hr>
<h2 id="是敵是友？"><a href="#是敵是友？" class="headerlink" title="是敵是友？"></a>是敵是友？</h2><p>實作第三方登入時會因為各種奇怪問題卡關，以下先提供一點心理建設。</p>
<h3 id="盟友"><a href="#盟友" class="headerlink" title="盟友"></a>盟友</h3><ul>
<li><a href="https://www.passportjs.org/">Passport</a>：後端串第三方登入的好朋友，可以大幅省去自幹程式碼的時間。</li>
</ul>
<h3 id="敵人"><a href="#敵人" class="headerlink" title="敵人"></a>敵人</h3><ul>
<li>第三方登入平台的申請流程：申請設定的流程可以說是越大咖越難搞，特別是 F 什麼、G 什麼的，因為提供的服務種類多元，還有安全性的要求，申請流程會複雜許多。</li>
<li>scope：scope 是使用第三方登入時設定要取得哪些用戶的資訊，有些登入服務有完整的說明文件，有些藏很深不知道去哪找，當設定錯誤的 scope 時登入就會失敗，這時會誤以為是第三方平台上的設定錯誤，查了半天才發現是 scope 設定錯誤。</li>
</ul>
<h3 id="亦敵亦友"><a href="#亦敵亦友" class="headerlink" title="亦敵亦友"></a>亦敵亦友</h3><ul>
<li>各種網路教學文章：第三方登入服務平台介面有時會改版，特別是越大間的越常改（沒錯，又是 F、G…)，而且不只是介面改了，scope 也可能會改，這種時候照著教學文章貼肯定會卡住，搜尋教學文時需要注意一下發文時間最好在一年內。</li>
</ul>
<hr>
<h2 id="實作-後端環境、路由建置"><a href="#實作-後端環境、路由建置" class="headerlink" title="實作 - 後端環境、路由建置"></a>實作 - 後端環境、路由建置</h2><p>★ 環境：Node.js<br>★ 使用套件：Express、Passport（請先在後端環境完成安裝）</p>
<ol>
<li>先想好自己要串接的社群平台，前往 <a href="https://www.passportjs.org/">Passport</a> 搜尋對應的策略（Strategy），Passport 提供超過 500 種策略，基本上想的到的都會有。<br><img data-src="https://i.imgur.com/RrTHOsv.png"></li>
<li>搜尋到策略後點擊進入，盡可能選下載量和星星數最高的，使用起來比較有保障。<br><img data-src="https://i.imgur.com/NKlx0Cs.png"></li>
<li>進入策略頁面後請先閱讀第一段落，這邊會提供許多實用的建議，以下圖（Discord）為例，作者說明他正在尋找接班人繼續維護這個策略（目前可能停更），另外提供了兩個連結，第二個連結就是 Discord 申請第三方登入的官方文件，這個連結對後續申請服務幫助很大。<br><img data-src="https://i.imgur.com/xRfduuw.png"></li>
<li>閱讀完第一段收集到有用資訊後先不急著申請，照著第二段（Usage) 建立好自己的 Node.js 專案環境：<ul>
<li>使用 NPM 安裝策略套件。</li>
<li>新增一個檔案 passport.js（名稱自訂），並且在專案主程式（express 是 app.js）中引入這個檔案。</li>
<li>複製 Configure Strategy 內的程式碼到 passport.js 中。</li>
<li>如果要實作多種第三方登入可以貼到同一個檔案內，不需要另外新增檔案來引入。<br><img data-src="https://i.imgur.com/X55NV86.png"></li>
</ul>
</li>
<li>上個步驟貼上的程式碼有幾個地方需要調整<ul>
<li>clientID、clientSecret：需要到第三方登入平台申請完之後才會取得，建議改成引用環境變數，不要直接將敏感資訊暴露在程式碼中。</li>
<li>callbackURL：第三方登入認證後會將使用者資訊結合這個網址送出，我們可以先設計好這個路由名稱，例如：<code>http://127.0.0.1:3000/auth/discord/callback</code>（佈署上線後要將 127.0.0.1:3000 改為線上的域名）。</li>
<li>scopes：設定第三方回傳的使用者資訊，建議可以先照貼策略裡面寫的，等串好沒問題之後再調整，也不建議參考時間較舊的網路教學文章來設定，很可能會因為無效的 scope 造成登入失敗。</li>
<li>function：這個函式是接收到第三方登入回傳資料後要做的動作，裡面有 4 個參數，其中的 profile 是回傳的資料，範例程式碼中使用 findOrCreate 來取得/建立使用者資料，這段可以移除，直接撰寫<code>return cb(null, profile)</code> 進入下一個 callback function 來自訂處理程式，修改後的 function 如下：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">accessToken, refreshToken, profile, cb</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> cb(<span class="literal">null</span>, profile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>進入第三段（Authentication Requests），在後端專案中加入兩個路由，第一個是讓前端傳送使用第三方登入的請求，第二個是前面說到的 callbackURL。<br><img data-src="https://i.imgur.com/YUa8Px5.png"></li>
<li>callback 路由的範例程式碼中，有設定失敗回傳轉址行為，這部份可以拿掉，交由自己撰寫的 callback function 處理，除此之外，如果後端伺服器不使用 session 儲存資訊，可以在這邊加入設定來關閉，程式碼如下：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">&#x27;/auth/discord&#x27;</span>, passport.authenticate(<span class="string">&#x27;discord&#x27;</span>));</span><br><span class="line">app.get(<span class="string">&#x27;/auth/discord/callback&#x27;</span>, passport.authenticate(<span class="string">&#x27;discord&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">session</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;), callbackFunction);</span><br></pre></td></tr></table></figure></li>
<li>後端環境基本設置到此已完成，策略頁面中剩下的其他段落是針對不同使用情境設定，可以在串接成功後再視需求閱讀參考。</li>
</ol>
<hr>
<h2 id="實作-申請第三方登入服務"><a href="#實作-申請第三方登入服務" class="headerlink" title="實作 - 申請第三方登入服務"></a>實作 - 申請第三方登入服務</h2><h3 id="關鍵字"><a href="#關鍵字" class="headerlink" title="關鍵字"></a>關鍵字</h3><p>每個平台的操作介面都不同，但是需要設定和取得的資訊幾乎都能在以下這些關鍵字中找到：</p>
<ul>
<li>OAuth、OAuth 2、OAuth 2.0</li>
<li>ClientID、AppID</li>
<li>ClientSecret、AppSecret</li>
<li>Callback URL、Callback URI、Redirect</li>
</ul>
<p>因為操作介面可能會改來改去，以下流程不會有太多圖片說明，而是提供「按鈕名稱」，可以在操作面板上尋找這些按鈕關鍵字。</p>
<h3 id="Google"><a href="#Google" class="headerlink" title="Google"></a>Google</h3><p>Google 最多人串，也最麻煩，步驟非常多：</p>
<ol>
<li>前往 <a href="https://console.cloud.google.com/">Google Cloud Platform</a>。</li>
<li>點擊按鈕「新增專案」（按鈕位置要找一下）。</li>
<li>輸入「專案名稱」（可以用預設）後點擊按鈕「建立」，稍等一下就會完成新專案的建立。</li>
<li>專案建立好後會跳轉到操作儀表板，左側選單項目非常的多，需要選擇「API 和服務」，如果找不到也可以直接在上方的搜尋列搜尋「API」就可以到設定頁面。<br><img data-src="https://i.imgur.com/DnDOcM3.png"></li>
<li>進入 API 和服務頁面後，左側選單選擇「OAuth 同意畫面」。</li>
<li>右側介面選擇「外部」，再點擊按鈕「建立」。</li>
<li>把必填的欄位填好，應用程式名稱（網站名稱）、聯絡信箱…等填完後就可以點擊「儲存並繼續」。</li>
<li>接著是設定授權範圍的頁面（也就是前面提到的 scopes），可以設定用戶點擊第三方登入時需要提供哪些資訊的授權，這邊可以不做設定，直接點擊「儲存並繼續」。</li>
<li> 最後是測試者的設定頁面，請把自己的信箱加進去，就可以點擊「儲存並繼續」，同意畫面的設定到此完成。</li>
<li>接著在左側選單選擇「憑證」，右側介面點擊按鈕「＋建立憑證 &gt; OAuth 用戶端 ID」。</li>
<li>「應用程式類型」選擇「網頁應用程式」。</li>
<li>「名稱」可以改成自己網站名稱。</li>
<li>「已授權的重新導向 URI」填入在後端設定好的 callback url。</li>
<li>完成設定後點擊按鈕「建立」，建立完成後就會彈出畫面，上面有 ClientID、ClientSecret（介面上是寫 您的用戶端 ID 和 您的用戶端密碼）</li>
<li>完成啟用後將 ClientID、ClientSecret 設定到後端專案後就可以測試成果了。</li>
</ol>
<h3 id="Facebook"><a href="#Facebook" class="headerlink" title="Facebook"></a>Facebook</h3><p>Facebook 改名為 Meta，開發者介面也改變了，一些老文章的圖片無法參考，除此之外，Facebook 的 callback url 只允許設定 https 協定，所以要在本地測試的話得掛上 https（可以參考 <a href="https://w3c.hexschool.com/blog/cd7b449b">Mkcert - 在 localhost 掛 HTTPS 神器</a>)，以下是 Facebook 應用設定流程：</p>
<ol>
<li>前往 <a href="https://developers.facebook.com/apps/">Meta for Developers</a>。</li>
<li>點擊右上角的按鈕「Create App」，建立新的應用程式。</li>
<li>選取應用程式類型（Select an app type），不同類型能取得的使用者資訊會不一樣，自己決定要用哪個類型後點擊按鈕「next」進入下一步。</li>
<li>在「Display name」輸入名稱（網站名稱）後就可以點擊按鈕「Create app」完成建置，這時候會需要再次輸入自己 Facebook 的密碼，成功後就會跳轉到應用的介面。</li>
<li>左側選單選擇「Settings &gt; Basic」就可以拿到 ClientID、ClientSecret（介面上是寫 AppID 和 App secret）。</li>
<li>左側選單選擇「Dashboard」。</li>
<li>右側介面找到「Facebook Login」的區塊，點擊按鈕「Set up」，就會跳轉到設定頁面（此時左側選單也會多出 Facebook Login 的選項）。</li>
<li>左側選單選擇「Facebook Login &gt; Settings」。<br><img data-src="https://i.imgur.com/yWSuDdf.png"></li>
<li> 在設定介面的「Valid OAuth Redirect URIs」中加入後端設定好的 callback url，完成後點擊右下方的按鈕「Save changes」。</li>
<li>如果介面上方有「App Mode」按鈕，切換成 Live 狀態，如果無法切換可能是有一些基本資訊要補充設定，設定好就可以啟用了，我只有在新建的第一個 app 有出現這個開關，後續新增的都沒有。</li>
<li>完成啟用後將 ClientID、ClientSecret 設定到後端專案後就可以測試成果了。</li>
</ol>
<h3 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h3><p>Github 的設定超簡單，幾個步驟迅速搞定：</p>
<ol>
<li>前往 Github 的個人設定頁面 <a href="https://github.com/settings/developers">Settings / Developer settings</a>。</li>
<li>左邊選單選取「OAuth Apps」。</li>
<li>右方區塊點擊「New OAuth App」，建立新的應用程式。</li>
<li>「Application name」填入應用名稱（網站名稱）、「Homepage URL」填入網站網址、「Authorization callback URL」填入在後端設定好的 callback url。</li>
<li>點擊「Register application」。</li>
<li>建置好之後進入剛剛設置的 App 就可以拿到 ClientID、ClientSecret。</li>
<li>將 ClientID、ClientSecret 設定到後端專案後就可以測試成果了。</li>
</ol>
<h3 id="Discord"><a href="#Discord" class="headerlink" title="Discord"></a>Discord</h3><p>Discord 的步驟也很簡單，還有機器人的功能，有閒可以玩玩看：</p>
<ol>
<li>前往 <a href="https://discord.com/developers/applications">Discord Developer Portal</a>。</li>
<li>點擊右上方「New Application」按鈕，建立新的應用程式。</li>
<li>輸入名稱（網站名稱）後，點擊「Create」建置應用後就會跳轉到應用的介面。</li>
<li>左側選單選擇「OAuth2」。</li>
<li>右側區塊會看到 ClientID，但是 ClientSecret 區塊是空的，點擊「Reset Secret」按鈕就會產生新的 ClientSecret。<br><img data-src="https://i.imgur.com/cLo8p8P.png"></li>
<li>右側區塊點擊「Add Redirect」，加入在後端設定好的 callback url。</li>
<li>偵測到設定變更之後下方會談出提醒對話框，點擊「Save Changes」儲存設定。</li>
<li>將 ClientID、ClientSecret 設定到後端專案後就可以測試成果了。</li>
<li> Discord 的 <a href="https://discord.com/developers/docs/topics/oauth2">官方文件</a> 中可以查看有哪些 scopes 可以取得。</li>
</ol>
]]></content>
      <tags>
        <tag>Node.js</tag>
        <tag>Passport</tag>
        <tag>Express</tag>
        <tag>第三方登入</tag>
      </tags>
  </entry>
  <entry>
    <title>[CORS] 關閉瀏覽器的 CORS</title>
    <url>/2022/04/25/whatTheCors1/</url>
    <content><![CDATA[ <img data-src="https://i.imgur.com/Dp97mhq.png" style="max-height: 200px" align=center />

<span id="more"></span>

<p>CORS 可以從瀏覽器關閉，但這只對設置關閉的那台設備有效，如果叫所有用戶這麼做，UX 不只歸零，還會負分。</p>
<hr>
<h2 id="各種作業系統的指令"><a href="#各種作業系統的指令" class="headerlink" title="各種作業系統的指令"></a>各種作業系統的指令</h2><p>請使用終端機執行這些指令，路徑可能因環境、作業系統有異，需要自行調整。</p>
<ul>
<li><p>MacOS</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">open -na Google\ Chrome --args --disable-web-security --user-data-dir=<span class="string">&quot;/tmp/chrome_dev&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>Windows</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;C:\Program Files (x86)\Google\Chrome\Application\chrome.exe&quot;</span> --disable-web-security --disable-gpu --user-data-dir=~/chromeTemp</span><br></pre></td></tr></table></figure></li>
<li><p>Linux</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">google-chrome --disable-web-security</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h2><p>CORS block 的錯誤訊息是來自於瀏覽器的安全性設置，接受哪些來源的請求設置是在伺服器端，所以在 request 發送出去，並且收到 response 之後才會知道伺服器允許哪些來源，當瀏覽器發現 response 的 CORS 設定不符（或是沒設定）就會阻擋，不讓網頁的 JavaScript 繼續處理，只要關閉這個安全性設置，就不會被瀏覽器阻擋了。</p>
<hr>
<blockquote>
<p>參考資料：</p>
<ul>
<li><a href="https://alfilatov.com/posts/run-chrome-without-cors/">Run Chrome browser without CORS</a></li>
<li><a href="https://stackoverflow.com/questions/3102819/disable-same-origin-policy-in-chrome">Disable same origin policy in Chrome</a></li>
<li><a href="https://blog.huli.tw/2021/02/19/cors-guide-2/">Huli - CORS 完全手冊（二）：如何解決 CORS 問題？</a></li>
</ul>
</blockquote>
]]></content>
      <tags>
        <tag>API</tag>
        <tag>CORS</tag>
      </tags>
  </entry>
  <entry>
    <title>[Vue3] Vite + Vue3 的 ESlint 和 Prettier 基礎配置</title>
    <url>/2022/04/27/vue3-2-eslint/</url>
    <content><![CDATA[<p>Vite + Vue 的環境建置快速方便，執行 <code>npm init vue@next</code> 指令之後，可以選擇加入 ESlint 和 Prettier 來優化程式碼，這兩個優化套件是許多開發者的標配，對於已經熟悉配置設定的老手沒有什麼問題，但對於新手來說，不知道自動建立的 ESlint 設定檔配置了什麼，也不知道怎麼修改，這篇就來簡單了解一下究竟 Vite 幫我們做了什麼設定。</p>
<span id="more"></span>

<hr>
<h2 id="系統環境"><a href="#系統環境" class="headerlink" title="系統環境"></a>系統環境</h2><ul>
<li>Node: v16</li>
<li>Vue: 3.2.33</li>
<li>Vite: 2.9.6</li>
<li>ESlint: 8.5.0</li>
<li>Prettier: 2.5.1</li>
</ul>
<hr>
<h2 id="ESlint-配置檔"><a href="#ESlint-配置檔" class="headerlink" title="ESlint 配置檔"></a>ESlint 配置檔</h2><p>建立好的專案目錄中有一個 .eslintrc.cjs 檔案，初始配置如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* eslint-env node */</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;@rushstack/eslint-patch/modern-module-resolution&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">root</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">extends</span>: [</span><br><span class="line">    <span class="string">&#x27;plugin:vue/vue3-essential&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;eslint:recommended&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;@vue/eslint-config-prettier&#x27;</span>,</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">env</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;vue/setup-compiler-macros&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="基本配置說明"><a href="#基本配置說明" class="headerlink" title="基本配置說明"></a>基本配置說明</h2><h3 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h3><ol>
<li><p>第一項 plugin:vue/vue3-essential 是 Vue 官方的撰寫風格 <a href="https://eslint.vuejs.org/rules/">eslint-plugin-vue</a>，規範嚴格程度由 base（最低）到 recommended（最高），可以用 recommended 套用所有規範：</p>
<ul>
<li><p>plugin:vue/base</p>
</li>
<li><p>plugin:vue/vue3-essential</p>
</li>
<li><p>plugin:vue/vue3-strongly-recommended</p>
</li>
<li><p>plugin:vue/vue3-recommended</p>
</li>
</ul>
</li>
<li><p>第二項 eslint:recommended 是 ESlint 的推薦設定，可以在 <a href="https://eslint.org/docs/rules/">官方文件</a> 檢視詳細說明。</p>
</li>
<li><p>最後一項 <a href="https://github.com/vuejs/eslint-config-prettier">@vue/eslint-config-prettier</a> 用來關閉 ESlint 會跟 Prettier 衝突的規則，名稱前方加上 <code>@vue</code> 是專為 @vue-cli 和 create-vue setups 設計的版本，使用時需要照以下格式引用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 這行需要放在最上面，引用此來源可以減少安裝許多 dependencies</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;@rushstack/eslint-patch/modern-module-resolution&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">extends</span>: [</span><br><span class="line">    <span class="comment">// 這個設定務必放在陣列的最後一項，確保不會被其他的設定覆蓋</span></span><br><span class="line">    <span class="string">&#x27;@vue/eslint-config-prettier&#x27;</span>,</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="env"><a href="#env" class="headerlink" title="env"></a>env</h3><ul>
<li>vue/setup-compiler-macros 用來支援 Vue3 的 script setup。</li>
</ul>
<hr>
<h2 id="額外配置"><a href="#額外配置" class="headerlink" title="額外配置"></a>額外配置</h2><ol>
<li><p>使用單引號</p>
<ul>
<li><p>方法 1：額外撰寫 prettier 的設定檔，設定檔的名稱非常多種，可以參考 <a href="https://prettier.io/docs/en/configuration.html">官方文件</a>。</p>
</li>
<li><p>方法 2：直接在 eslint 設定檔加入規則，要注意的是，有些 prettier 相關 extension 只會讀 prettier 的設定檔，寫在 eslint 就無效。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">rules: &#123;</span><br><span class="line">  <span class="string">&#x27;prettier/prettier&#x27;</span>: [<span class="string">&#x27;error&#x27;</span>, &#123; <span class="attr">singleQuote</span>: <span class="literal">true</span> &#125;],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>支援 commonJS<br>許多套件的設定檔是使用 commonJS 格式撰寫（例如：tailwindcss），需要增加 node 環境，ESlint 才不會跳出錯誤。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">env: &#123;</span><br><span class="line">  <span class="attr">node</span>: <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>加入 airbnb 風格<br>目前 <a href="https://github.com/vuejs/eslint-config-airbnb#readme">@vue/eslint-config-airbnb</a> 只適用於 @vue/cli (webpack based)，<code>Vite 環境不能使用</code>，如果還是有這個需求，可以參考 <a href="https://www.twblogs.net/a/60d578467f8319e4a6f4e098">台部落 - Vite Vue3 項目 eslint 配置遇到的問題</a> 這篇文章來自己修改。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>Vite</tag>
        <tag>Vue</tag>
        <tag>Vue3</tag>
        <tag>ESlint</tag>
        <tag>Prettier</tag>
      </tags>
  </entry>
  <entry>
    <title>[CORS] POST 方法 Fetch 可以過，但是 Axios 無法</title>
    <url>/2022/04/23/whatTheCors3/</url>
    <content><![CDATA[ <img data-src="https://i.imgur.com/Dp97mhq.png" style="max-height: 200px" align=center />

<span id="more"></span>

<h2 id="問題說明"><a href="#問題說明" class="headerlink" title="問題說明"></a>問題說明</h2><p>「Fetch 可以過，但是 Axios 無法」的原因追根究底還是 CORS 造成的，只是 fetch 沒有帶上正確的參數，所以有不一樣的結果。</p>
<p>fetch 傳送的第二個參數中若沒有設定 headers 標示內容為 json 格式（application/json），會以文字格式傳送（text/plain），這屬於「簡單請求」，不會觸發 preflight 機制。</p>
<p>axios 傳入的資料如果是物件格式就會轉為 json，並且帶上對應的 header，所以會觸發 preflight 機制，當後端伺服器對 preflight 的回應沒有設置好時就會觸發瀏覽器的 cors 阻擋。</p>
<hr>
<h2 id="可能原因"><a href="#可能原因" class="headerlink" title="可能原因"></a>可能原因</h2><ol>
<li><p>後端沒有設置 cors header</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>: <span class="string">&#x27;*&#x27;</span>,</span><br></pre></td></tr></table></figure></li>
<li><p>後端沒有設置 OPTIONS methods 或 response</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span>: <span class="string">&#x27;...(其他方法).., OPTIONS&#x27;</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 除 header 之外還要設置 OPTIONS 的回傳內容，不然可能被 40x 錯誤捕捉到。</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="檢查測試"><a href="#檢查測試" class="headerlink" title="檢查測試"></a>檢查測試</h2><ol>
<li><p>確認瀏覽器錯誤訊息是否包含 preflight 的字眼。<br><code>Access ..... has been blocked by CORS policy: Response to preflight request doesn&#39;t pass access control check: It does not have HTTP ok status.</code></p>
</li>
<li><p>確認 fetch 的請求內容是否有加上 header 參數。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">headers: &#123;</span><br><span class="line">  <span class="string">&#x27;content-type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
<li><p>使用 Postman 發出 OPTIONS 請求，查看回應資訊。</p>
</li>
</ol>
<hr>
<h2 id="解決方式"><a href="#解決方式" class="headerlink" title="解決方式"></a>解決方式</h2><ul>
<li>正解：請後端加上 cors headers 或是確認 OPTIONS 的設置。</li>
<li>暫時解：使用 CorsAnywhere、關閉瀏覽器 cors…等。</li>
</ul>
<hr>
<blockquote>
<p>參考文章：</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-TW/docs/Web/HTTP/CORS">MDN - CORS</a></li>
<li><a href="https://stackoverflow.com/questions/64793572/axios-fails-cors-but-fetch-works-fine">Stackoverflow - Axios fails CORS but fetch works fine</a></li>
</ul>
</blockquote>
]]></content>
      <tags>
        <tag>API</tag>
        <tag>CORS</tag>
      </tags>
  </entry>
  <entry>
    <title>[CORS] POST 方法 Postman 可以過，但是 Axios 無法</title>
    <url>/2022/04/27/whatTheCors2/</url>
    <content><![CDATA[ <img data-src="https://i.imgur.com/Dp97mhq.png" style="max-height: 200px" align=center />

<span id="more"></span>

<h2 id="問題說明"><a href="#問題說明" class="headerlink" title="問題說明"></a>問題說明</h2><p>POST 方法在瀏覽器中會觸發預檢請求（preflight），瀏覽器實際上會送出兩個請求，第一個是 OPTIONS、第二個是 POST，當後端伺服器對 preflight 的回應沒有設置好時就會觸發瀏覽器的 cors 阻擋。</p>
<p>Postman 發送 POST 請求時不會有 preflight，要檢測 preflight 可以另外發送 OPTIONS 請求。</p>
<hr>
<h2 id="可能原因"><a href="#可能原因" class="headerlink" title="可能原因"></a>可能原因</h2><ol>
<li><p>後端沒有設置 cors header</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>: <span class="string">&#x27;*&#x27;</span>,</span><br></pre></td></tr></table></figure></li>
<li><p>後端沒有設置 OPTIONS methods 或 response</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span>: <span class="string">&#x27;...(其他方法).., OPTIONS&#x27;</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 除 header 之外還要設置 OPTIONS 的回傳內容，不然可能被 40x 錯誤捕捉到。</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="檢查測試"><a href="#檢查測試" class="headerlink" title="檢查測試"></a>檢查測試</h2><ol>
<li><p>確認瀏覽器錯誤訊息是否包含 preflight 的字眼。<br><code>Access ..... has been blocked by CORS policy: Response to preflight request doesn&#39;t pass access control check: It does not have HTTP ok status.</code></p>
</li>
<li><p>使用 Postman 發出 OPTIONS 請求，查看回應資訊。</p>
</li>
</ol>
<hr>
<h2 id="解決方式"><a href="#解決方式" class="headerlink" title="解決方式"></a>解決方式</h2><ul>
<li>正解：請後端加上 cors headers 或是確認 OPTIONS 的設置。</li>
<li>暫時解：使用 CorsAnywhere、關閉瀏覽器 cors…等。</li>
</ul>
<hr>
<blockquote>
<p>參考文章</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-TW/docs/Web/HTTP/CORS">MDN - CORS</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Glossary/Preflight_request">MDN - Preflight request</a></li>
</ul>
</blockquote>
]]></content>
      <tags>
        <tag>API</tag>
        <tag>CORS</tag>
      </tags>
  </entry>
  <entry>
    <title>[CORS] 運用代理工具繞過 CORS 機制：Cors-Anywhere</title>
    <url>/2022/04/28/whatTheCors4/</url>
    <content><![CDATA[ <img data-src="https://i.imgur.com/Dp97mhq.png" style="max-height: 200px" align=center />

<span id="more"></span>

<h2 id="說明"><a href="#說明" class="headerlink" title="說明"></a>說明</h2><p>CORS 阻擋是「瀏覽器」的安全機制，流程大致如下：</p>
<p><img data-src="https://i.imgur.com/Fiw0EdH.png" alt="request 與 response 流程示意圖"></p>
<p>當後端伺服器沒辦法立即修復 cors 問題時，我們可以使用「代理伺服器」來繞過 cors 檢查。</p>
<hr>
<h2 id="Cors-Anywhere"><a href="#Cors-Anywhere" class="headerlink" title="Cors-Anywhere"></a>Cors-Anywhere</h2><p><a href="https://github.com/Rob--W/cors-anywhere">Cors-Anywhere</a> 是非常簡單好用的 cors 代理工具，Cors-Anywhere 可以把伺服器回應加上 cors headers 再送回瀏覽器，瀏覽器自然不會阻擋這些「合法」的回應，流程大致如下：</p>
<p><img data-src="https://i.imgur.com/E90PnGC.png" alt="Cors-Anywhere 代理流程示意圖"></p>
<h2 id="代理機制"><a href="#代理機制" class="headerlink" title="代理機制"></a>代理機制</h2><h3 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h3><p>當代理伺服器協助的對象是 client 端時便是正向代理，代理伺服器會協助 client 端與目的伺服器溝通，除了能像 Cors-Anywhere 一樣幫助 client 端修改回應 headers，因為目的伺服器不知道 client 端的實際 IP，也可以用來繞過 IP 限制（俗稱的翻牆）。</p>
<h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>當代理伺服器協助的對象是 server 端時便是反向代理，當我們連線到 A 網站，A 網站的伺服器環境有設置反向代理，這時我們以為連到 A 網站的 IP，實際上是代理伺服器的 IP，代理伺服器接收後再轉發給 A 伺服器，這個作法可以隱藏應用服務伺服器的實際 IP，避免遭受外部的直接攻擊，也常用於負載平衡，讓代理伺服器分配處理的伺服器。</p>
<p>在<a href="https://en.wikipedia.org/wiki/Reverse_proxy">維基百科</a>中 Reverse proxy 的示意圖可以看到，Proxy 和 Server 處於同一個 Internal network（內網）。</p>
<p><img data-src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/67/Reverse_proxy_h2g2bob.svg/1280px-Reverse_proxy_h2g2bob.svg.png" alt="Wiki - Reverse proxy"></p>
<h3 id="Cors-Anywhere-是「正向代理」還是「反向代理」？"><a href="#Cors-Anywhere-是「正向代理」還是「反向代理」？" class="headerlink" title="Cors-Anywhere 是「正向代理」還是「反向代理」？"></a>Cors-Anywhere 是「正向代理」還是「反向代理」？</h3><p>在網路上搜尋 Cors-Anywhere 相關的文章會發現許多文章寫到 Cors-Anywhere 是反向代理伺服器，因為 Cors-Anywhere 的 repo description 中確實寫著他是 reverse proxy（反向代理），但是在 repo 的 README 文件中已經拿掉 reverse 這個詞，就只是個 proxy（代理伺服器）。</p>
<p>代理伺服器是一個協助轉發連線請求、伺服器回應的中間人（伺服器），通常不會特別加註正向或是反向，若要分類，可以從他協助的對象和使用目的來區分。<br>Cors-Anywhere 可以是「正向代理」、也可以是「反向代理」，取決於使用場景，</p>
<ul>
<li><p>當 Cors-Anywhere 建置在與 server 相同的內網環境中，並且協助 server 接收連線請求，便是反向代理。</p>
</li>
<li><p>實際狀況通常是，前端開發者串接後端 api 時遇到 cors 問題，又沒辦法請後端即時處理，這種時候不太可能還有辦法到後端的環境建置 Cors-Anywhere，而是透過外部網域的 Cors-Anywhere 來代理前端的連線，這種情況下 api server 仍然是直接接收來自外部的請求，只是請求方透過 proxy 轉發請求，便是正向代理。</p>
</li>
</ul>
<hr>
<h2 id="Cors-Anywhere-使用方法"><a href="#Cors-Anywhere-使用方法" class="headerlink" title="Cors-Anywhere 使用方法"></a>Cors-Anywhere 使用方法</h2><p>我們可以選擇直接使用作者建置的 demo，或是複製該專案回來自己架設到免費雲端平台上。</p>
<h3 id="直接使用作者的-Demo"><a href="#直接使用作者的-Demo" class="headerlink" title="直接使用作者的 Demo"></a>直接使用作者的 Demo</h3><p>作者提供的網站只是一個 Demo，並不是專業的服務平台，當連線過多的時候就無法使用，只適合練習時使用，連線量多時使用自己架設的服務較佳。</p>
<ol>
<li><p>進入作者的 <a href="https://cors-anywhere.herokuapp.com/corsdemo">Demo 網站</a>。</p>
</li>
<li><p>點擊網頁上的「Request temporary access to the demo server」按鈕。</p>
</li>
<li><p>點擊完按鈕後，稍等一下，網站會顯示「You currently have temporary access to the demo server.」，就可以開始使用。</p>
</li>
<li><p>回到自己的程式編輯器，修改原本的請求網址，在原始網址前面加上作者的 Demo 網址 <code>https://cors-anywhere.herokuapp.com/</code> ，完成後就可以測試連線了。</p>
</li>
</ol>
<blockquote>
<p>修改範例：</p>
<ul>
<li>原本有 cors 問題的網址請求：</li>
<li><code>axios.get(&#39;https://a.b.c/&#39;)</code></li>
<li>加上 Cors-Anywhere 的請求：</li>
<li><code>axios.get(&#39;https://cors-anywhere.herokuapp.com/https://a.b.c/&#39;)</code></li>
</ul>
</blockquote>
<h3 id="自己架設"><a href="#自己架設" class="headerlink" title="自己架設"></a>自己架設</h3><p>可以參考這篇文章 <a href="https://smlpoints.com/guide-heroku-build-your-cors-proxy-server.html">Andy Lien - [指南] 前端工程師開發必備的 Heroku + Node.js 佈署自己的 CORS 轉址伺服器</a> 完成建置，佈署到 Heroku 之後就會取得自己的 APP 網址，在請求的網址前面加上這個 APP 網址即可。</p>
<hr>
<blockquote>
<p>參考文章：</p>
<ul>
<li><a href="https://github.com/Rob--W/cors-anywhere">Rob–W - Cors-Anywhere</a></li>
<li><a href="https://smlpoints.com/guide-heroku-build-your-cors-proxy-server.html">Andy Lien - [指南] 前端工程師開發必備的 Heroku + Node.js 佈署自己的 CORS 轉址伺服器</a></li>
</ul>
</blockquote>
]]></content>
      <tags>
        <tag>API</tag>
        <tag>CORS</tag>
      </tags>
  </entry>
</search>
